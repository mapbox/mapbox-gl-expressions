(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.MigrationTool = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

var convertFunction = require('mapbox-gl/src/style-spec/function/convert');
var ref = require('mapbox-gl/src/style-spec/expression');
var createExpression = ref.createExpression;
var ref$1 = require('mapbox-gl/src/style-spec/function');
var isFunction = ref$1.isFunction;
var validate = require('mapbox-gl/src/style-spec').validate;
var spec = require('mapbox-gl/src/style-spec/reference/v8.json');

var stringify = require('json-stringify-pretty-compact');
var diff = require('diff');

var initialStyle = {
    version: 8,
    sources: {
        mapbox: {
            type: 'vector',
            url: 'mapbox://mapbox-streets-v7'
        }
    },
    layers: [{
        id: 'places',
        source: 'mapbox',
        'source-layer': 'poi_label',
        type: 'circle',
        paint: {
            'circle-radius': {
                property: 'scalerank',
                stops: [
                    [{zoom: 0, value: 0}, 1],
                    [{zoom: 0, value: 5}, 3],
                    [{zoom: 14, value: 0}, 5],
                    [{zoom: 14, value: 5}, 10]
                ]
            }
        }
    }]
};

var MigrationTool = (function (superclass) {
    function MigrationTool(props) {
        this.state = {
            inputStyle: stringify(initialStyle, null, 2)
        }

        this.onEdit = this.onEdit.bind(this);
    }

    if ( superclass ) MigrationTool.__proto__ = superclass;
    MigrationTool.prototype = Object.create( superclass && superclass.prototype );
    MigrationTool.prototype.constructor = MigrationTool;

    MigrationTool.prototype.render = function render () {
        var diffOutput;
        var error;

        var validationErrors = validate(this.state.inputStyle);
        if (validationErrors.length === 0) {
            var parsed = JSON.parse(this.state.inputStyle)
            var migrated = migrate(parsed);
            var result = diff.diffLines(stringify(parsed), stringify(migrated));
            diffOutput = result.map(function (part, index) {
                var klass = '';
                if (part.added) { klass ='bg-green-faint'; }
                if (part.removed) { klass='bg-red-faint'; }
                return React.createElement( 'div', { key: index, className: klass }, part.value)
            });
            console.log(result);
        } else {
            error = validationErrors.map(function (error, index) { return React.createElement( 'div', { className: 'color-red-dark', key: index }, error.line, ": ", error.message); });
        }

        return (
        React.createElement( 'div', { className: 'w-full grid grid--gut12 flex-parent--stretch-cross' },
            React.createElement( 'div', { className: 'col col--12 col--auto-ml' },
                React.createElement( 'div', { className: 'h-full px12' },
                    React.createElement( 'h3', { className: "txt-h3" }, "Original"),
                    React.createElement( 'div', { className: 'w-full scroll-auto' },
                        React.createElement( 'textarea', { cols: 0, rows: 25, className: 'textarea', value: this.state.inputStyle, onChange: this.onEdit })
                    )
                )
            ),
            React.createElement( 'div', { className: 'col col--12 col--auto-ml' },
                React.createElement( 'div', { className: 'h-full' },
                    React.createElement( 'h3', { className: "txt-h3" }, "Converted to expressions"),
                    error || React.createElement( 'div', { className: "pre" }, diffOutput)
                )
            )
        ))
    };

    MigrationTool.prototype.onEdit = function onEdit (event) {
        var newValue = event.target.value;
        this.setState({inputStyle: newValue});
    };

    return MigrationTool;
}(React.Component));

function migrate(style) {
    var migrated = clone(style);
    migrated.layers = style.layers.map(function (layer) {
        var migratedLayer = clone(layer);
        if (layer.paint) {
            migratedLayer.paint = migrateProperties(layer, 'paint');
        }
        if (layer.layout) {
            migratedLayer.layout = migrateProperties(layer, 'layout');
        }
        return migratedLayer;
    })
    return migrated;
}

function migrateProperties(layer, type) {
    var properties = clone(layer[type]);
    for (var key in properties) {
        if (isFunction(properties[key])) {
            var propertySpec = spec[(type + "_" + (layer.type))][key];
            properties[key] = convertFunction(properties[key], propertySpec)
        }
    }
    return properties;
}

function clone(src) {
    return Object.assign({}, src)
}

module.exports = MigrationTool;

},{"diff":8,"json-stringify-pretty-compact":10,"mapbox-gl/src/style-spec":50,"mapbox-gl/src/style-spec/expression":38,"mapbox-gl/src/style-spec/function":49,"mapbox-gl/src/style-spec/function/convert":48,"mapbox-gl/src/style-spec/reference/v8.json":57}],2:[function(require,module,exports){
/*
 * Copyright (C) 2008 Apple Inc. All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Ported from Webkit
 * http://svn.webkit.org/repository/webkit/trunk/Source/WebCore/platform/graphics/UnitBezier.h
 */

module.exports = UnitBezier;

function UnitBezier(p1x, p1y, p2x, p2y) {
    // Calculate the polynomial coefficients, implicit first and last control points are (0,0) and (1,1).
    this.cx = 3.0 * p1x;
    this.bx = 3.0 * (p2x - p1x) - this.cx;
    this.ax = 1.0 - this.cx - this.bx;

    this.cy = 3.0 * p1y;
    this.by = 3.0 * (p2y - p1y) - this.cy;
    this.ay = 1.0 - this.cy - this.by;

    this.p1x = p1x;
    this.p1y = p2y;
    this.p2x = p2x;
    this.p2y = p2y;
}

UnitBezier.prototype.sampleCurveX = function(t) {
    // `ax t^3 + bx t^2 + cx t' expanded using Horner's rule.
    return ((this.ax * t + this.bx) * t + this.cx) * t;
};

UnitBezier.prototype.sampleCurveY = function(t) {
    return ((this.ay * t + this.by) * t + this.cy) * t;
};

UnitBezier.prototype.sampleCurveDerivativeX = function(t) {
    return (3.0 * this.ax * t + 2.0 * this.bx) * t + this.cx;
};

UnitBezier.prototype.solveCurveX = function(x, epsilon) {
    if (typeof epsilon === 'undefined') epsilon = 1e-6;

    var t0, t1, t2, x2, i;

    // First try a few iterations of Newton's method -- normally very fast.
    for (t2 = x, i = 0; i < 8; i++) {

        x2 = this.sampleCurveX(t2) - x;
        if (Math.abs(x2) < epsilon) return t2;

        var d2 = this.sampleCurveDerivativeX(t2);
        if (Math.abs(d2) < 1e-6) break;

        t2 = t2 - x2 / d2;
    }

    // Fall back to the bisection method for reliability.
    t0 = 0.0;
    t1 = 1.0;
    t2 = x;

    if (t2 < t0) return t0;
    if (t2 > t1) return t1;

    while (t0 < t1) {

        x2 = this.sampleCurveX(t2);
        if (Math.abs(x2 - x) < epsilon) return t2;

        if (x > x2) {
            t0 = t2;
        } else {
            t1 = t2;
        }

        t2 = (t1 - t0) * 0.5 + t0;
    }

    // Failure.
    return t2;
};

UnitBezier.prototype.solve = function(x, epsilon) {
    return this.sampleCurveY(this.solveCurveX(x, epsilon));
};

},{}],3:[function(require,module,exports){
(function (global){
'use strict';

// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
    return global.Buffer.isBuffer(b);
  }
  return !!(b != null && b._isBuffer);
}

// based on node assert, original notice:

// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = require('util/');
var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;
var functionsHaveNames = (function () {
  return function foo() {}.name === 'foo';
}());
function pToString (obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }
  if (typeof global.ArrayBuffer !== 'function') {
    return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/;
// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }
  if (functionsHaveNames) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
    return util.inspect(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' +  name + ']';
}
function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' +
         self.operator + ' ' +
         truncate(inspect(self.expected), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') &&
             (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected;

  // If both values are instances of typed arrays, wrap their underlying
  // ArrayBuffers in a Buffer each to increase performance
  // This optimization requires the arrays to have the same type as checked by
  // Object.prototype.toString (aka pToString). Never perform binary
  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
  // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) &&
             pToString(actual) === pToString(expected) &&
             !(actual instanceof Float32Array ||
               actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer),
                   new Uint8Array(expected.buffer)) === 0;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {actual: [], expected: []};

    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);

    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined)
    return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b))
    return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}


// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
    // Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if ((isUnwantedException &&
      userProvidedMessage &&
      expectedException(actual, expected)) ||
      isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
};

assert.ifError = function(err) { if (err) throw err; };

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"util/":98}],4:[function(require,module,exports){

},{}],5:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('Invalid typed array length')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (isArrayBuffer(value)) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  return fromObject(value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj) {
    if (isArrayBufferView(obj) || 'length' in obj) {
      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
        return createBuffer(0)
      }
      return fromArrayLike(obj)
    }

    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (isArrayBufferView(string) || isArrayBuffer(string)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : new Buffer(val, encoding)
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffers from another context (i.e. an iframe) do not pass the `instanceof` check
// but they should be treated as valid. See: https://github.com/feross/buffer/issues/166
function isArrayBuffer (obj) {
  return obj instanceof ArrayBuffer ||
    (obj != null && obj.constructor != null && obj.constructor.name === 'ArrayBuffer' &&
      typeof obj.byteLength === 'number')
}

// Node 0.10 supports `ArrayBuffer` but lacks `ArrayBuffer.isView`
function isArrayBufferView (obj) {
  return (typeof ArrayBuffer.isView === 'function') && ArrayBuffer.isView(obj)
}

function numberIsNaN (obj) {
  return obj !== obj // eslint-disable-line no-self-compare
}

},{"base64-js":6,"ieee754":9}],6:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return (b64.length * 3 / 4) - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr((len * 3 / 4) - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0; i < l; i += 4) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}

},{}],7:[function(require,module,exports){
// (c) Dean McNamee <dean@gmail.com>, 2012.
//
// https://github.com/deanm/css-color-parser-js
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.

// http://www.w3.org/TR/css3-color/
var kCSSColorTable = {
  "transparent": [0,0,0,0], "aliceblue": [240,248,255,1],
  "antiquewhite": [250,235,215,1], "aqua": [0,255,255,1],
  "aquamarine": [127,255,212,1], "azure": [240,255,255,1],
  "beige": [245,245,220,1], "bisque": [255,228,196,1],
  "black": [0,0,0,1], "blanchedalmond": [255,235,205,1],
  "blue": [0,0,255,1], "blueviolet": [138,43,226,1],
  "brown": [165,42,42,1], "burlywood": [222,184,135,1],
  "cadetblue": [95,158,160,1], "chartreuse": [127,255,0,1],
  "chocolate": [210,105,30,1], "coral": [255,127,80,1],
  "cornflowerblue": [100,149,237,1], "cornsilk": [255,248,220,1],
  "crimson": [220,20,60,1], "cyan": [0,255,255,1],
  "darkblue": [0,0,139,1], "darkcyan": [0,139,139,1],
  "darkgoldenrod": [184,134,11,1], "darkgray": [169,169,169,1],
  "darkgreen": [0,100,0,1], "darkgrey": [169,169,169,1],
  "darkkhaki": [189,183,107,1], "darkmagenta": [139,0,139,1],
  "darkolivegreen": [85,107,47,1], "darkorange": [255,140,0,1],
  "darkorchid": [153,50,204,1], "darkred": [139,0,0,1],
  "darksalmon": [233,150,122,1], "darkseagreen": [143,188,143,1],
  "darkslateblue": [72,61,139,1], "darkslategray": [47,79,79,1],
  "darkslategrey": [47,79,79,1], "darkturquoise": [0,206,209,1],
  "darkviolet": [148,0,211,1], "deeppink": [255,20,147,1],
  "deepskyblue": [0,191,255,1], "dimgray": [105,105,105,1],
  "dimgrey": [105,105,105,1], "dodgerblue": [30,144,255,1],
  "firebrick": [178,34,34,1], "floralwhite": [255,250,240,1],
  "forestgreen": [34,139,34,1], "fuchsia": [255,0,255,1],
  "gainsboro": [220,220,220,1], "ghostwhite": [248,248,255,1],
  "gold": [255,215,0,1], "goldenrod": [218,165,32,1],
  "gray": [128,128,128,1], "green": [0,128,0,1],
  "greenyellow": [173,255,47,1], "grey": [128,128,128,1],
  "honeydew": [240,255,240,1], "hotpink": [255,105,180,1],
  "indianred": [205,92,92,1], "indigo": [75,0,130,1],
  "ivory": [255,255,240,1], "khaki": [240,230,140,1],
  "lavender": [230,230,250,1], "lavenderblush": [255,240,245,1],
  "lawngreen": [124,252,0,1], "lemonchiffon": [255,250,205,1],
  "lightblue": [173,216,230,1], "lightcoral": [240,128,128,1],
  "lightcyan": [224,255,255,1], "lightgoldenrodyellow": [250,250,210,1],
  "lightgray": [211,211,211,1], "lightgreen": [144,238,144,1],
  "lightgrey": [211,211,211,1], "lightpink": [255,182,193,1],
  "lightsalmon": [255,160,122,1], "lightseagreen": [32,178,170,1],
  "lightskyblue": [135,206,250,1], "lightslategray": [119,136,153,1],
  "lightslategrey": [119,136,153,1], "lightsteelblue": [176,196,222,1],
  "lightyellow": [255,255,224,1], "lime": [0,255,0,1],
  "limegreen": [50,205,50,1], "linen": [250,240,230,1],
  "magenta": [255,0,255,1], "maroon": [128,0,0,1],
  "mediumaquamarine": [102,205,170,1], "mediumblue": [0,0,205,1],
  "mediumorchid": [186,85,211,1], "mediumpurple": [147,112,219,1],
  "mediumseagreen": [60,179,113,1], "mediumslateblue": [123,104,238,1],
  "mediumspringgreen": [0,250,154,1], "mediumturquoise": [72,209,204,1],
  "mediumvioletred": [199,21,133,1], "midnightblue": [25,25,112,1],
  "mintcream": [245,255,250,1], "mistyrose": [255,228,225,1],
  "moccasin": [255,228,181,1], "navajowhite": [255,222,173,1],
  "navy": [0,0,128,1], "oldlace": [253,245,230,1],
  "olive": [128,128,0,1], "olivedrab": [107,142,35,1],
  "orange": [255,165,0,1], "orangered": [255,69,0,1],
  "orchid": [218,112,214,1], "palegoldenrod": [238,232,170,1],
  "palegreen": [152,251,152,1], "paleturquoise": [175,238,238,1],
  "palevioletred": [219,112,147,1], "papayawhip": [255,239,213,1],
  "peachpuff": [255,218,185,1], "peru": [205,133,63,1],
  "pink": [255,192,203,1], "plum": [221,160,221,1],
  "powderblue": [176,224,230,1], "purple": [128,0,128,1],
  "rebeccapurple": [102,51,153,1],
  "red": [255,0,0,1], "rosybrown": [188,143,143,1],
  "royalblue": [65,105,225,1], "saddlebrown": [139,69,19,1],
  "salmon": [250,128,114,1], "sandybrown": [244,164,96,1],
  "seagreen": [46,139,87,1], "seashell": [255,245,238,1],
  "sienna": [160,82,45,1], "silver": [192,192,192,1],
  "skyblue": [135,206,235,1], "slateblue": [106,90,205,1],
  "slategray": [112,128,144,1], "slategrey": [112,128,144,1],
  "snow": [255,250,250,1], "springgreen": [0,255,127,1],
  "steelblue": [70,130,180,1], "tan": [210,180,140,1],
  "teal": [0,128,128,1], "thistle": [216,191,216,1],
  "tomato": [255,99,71,1], "turquoise": [64,224,208,1],
  "violet": [238,130,238,1], "wheat": [245,222,179,1],
  "white": [255,255,255,1], "whitesmoke": [245,245,245,1],
  "yellow": [255,255,0,1], "yellowgreen": [154,205,50,1]}

function clamp_css_byte(i) {  // Clamp to integer 0 .. 255.
  i = Math.round(i);  // Seems to be what Chrome does (vs truncation).
  return i < 0 ? 0 : i > 255 ? 255 : i;
}

function clamp_css_float(f) {  // Clamp to float 0.0 .. 1.0.
  return f < 0 ? 0 : f > 1 ? 1 : f;
}

function parse_css_int(str) {  // int or percentage.
  if (str[str.length - 1] === '%')
    return clamp_css_byte(parseFloat(str) / 100 * 255);
  return clamp_css_byte(parseInt(str));
}

function parse_css_float(str) {  // float or percentage.
  if (str[str.length - 1] === '%')
    return clamp_css_float(parseFloat(str) / 100);
  return clamp_css_float(parseFloat(str));
}

function css_hue_to_rgb(m1, m2, h) {
  if (h < 0) h += 1;
  else if (h > 1) h -= 1;

  if (h * 6 < 1) return m1 + (m2 - m1) * h * 6;
  if (h * 2 < 1) return m2;
  if (h * 3 < 2) return m1 + (m2 - m1) * (2/3 - h) * 6;
  return m1;
}

function parseCSSColor(css_str) {
  // Remove all whitespace, not compliant, but should just be more accepting.
  var str = css_str.replace(/ /g, '').toLowerCase();

  // Color keywords (and transparent) lookup.
  if (str in kCSSColorTable) return kCSSColorTable[str].slice();  // dup.

  // #abc and #abc123 syntax.
  if (str[0] === '#') {
    if (str.length === 4) {
      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
      if (!(iv >= 0 && iv <= 0xfff)) return null;  // Covers NaN.
      return [((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),
              (iv & 0xf0) | ((iv & 0xf0) >> 4),
              (iv & 0xf) | ((iv & 0xf) << 4),
              1];
    } else if (str.length === 7) {
      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
      if (!(iv >= 0 && iv <= 0xffffff)) return null;  // Covers NaN.
      return [(iv & 0xff0000) >> 16,
              (iv & 0xff00) >> 8,
              iv & 0xff,
              1];
    }

    return null;
  }

  var op = str.indexOf('('), ep = str.indexOf(')');
  if (op !== -1 && ep + 1 === str.length) {
    var fname = str.substr(0, op);
    var params = str.substr(op+1, ep-(op+1)).split(',');
    var alpha = 1;  // To allow case fallthrough.
    switch (fname) {
      case 'rgba':
        if (params.length !== 4) return null;
        alpha = parse_css_float(params.pop());
        // Fall through.
      case 'rgb':
        if (params.length !== 3) return null;
        return [parse_css_int(params[0]),
                parse_css_int(params[1]),
                parse_css_int(params[2]),
                alpha];
      case 'hsla':
        if (params.length !== 4) return null;
        alpha = parse_css_float(params.pop());
        // Fall through.
      case 'hsl':
        if (params.length !== 3) return null;
        var h = (((parseFloat(params[0]) % 360) + 360) % 360) / 360;  // 0 .. 1
        // NOTE(deanm): According to the CSS spec s/l should only be
        // percentages, but we don't bother and let float or percentage.
        var s = parse_css_float(params[1]);
        var l = parse_css_float(params[2]);
        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
        var m1 = l * 2 - m2;
        return [clamp_css_byte(css_hue_to_rgb(m1, m2, h+1/3) * 255),
                clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255),
                clamp_css_byte(css_hue_to_rgb(m1, m2, h-1/3) * 255),
                alpha];
      default:
        return null;
    }
  }

  return null;
}

try { exports.parseCSSColor = parseCSSColor } catch(e) { }

},{}],8:[function(require,module,exports){
/*!

 diff v3.4.0

Software License Agreement (BSD License)

Copyright (c) 2009-2015, Kevin Decker <kpdecker@gmail.com>

All rights reserved.

Redistribution and use of this software in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of Kevin Decker nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@license
*/
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["JsDiff"] = factory();
	else
		root["JsDiff"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	/*istanbul ignore start*/'use strict';

	exports.__esModule = true;
	exports.canonicalize = exports.convertChangesToXML = exports.convertChangesToDMP = exports.merge = exports.parsePatch = exports.applyPatches = exports.applyPatch = exports.createPatch = exports.createTwoFilesPatch = exports.structuredPatch = exports.diffArrays = exports.diffJson = exports.diffCss = exports.diffSentences = exports.diffTrimmedLines = exports.diffLines = exports.diffWordsWithSpace = exports.diffWords = exports.diffChars = exports.Diff = undefined;

	/*istanbul ignore end*/var /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;

	/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);

	/*istanbul ignore end*/var /*istanbul ignore start*/_character = __webpack_require__(2) /*istanbul ignore end*/;

	var /*istanbul ignore start*/_word = __webpack_require__(3) /*istanbul ignore end*/;

	var /*istanbul ignore start*/_line = __webpack_require__(5) /*istanbul ignore end*/;

	var /*istanbul ignore start*/_sentence = __webpack_require__(6) /*istanbul ignore end*/;

	var /*istanbul ignore start*/_css = __webpack_require__(7) /*istanbul ignore end*/;

	var /*istanbul ignore start*/_json = __webpack_require__(8) /*istanbul ignore end*/;

	var /*istanbul ignore start*/_array = __webpack_require__(9) /*istanbul ignore end*/;

	var /*istanbul ignore start*/_apply = __webpack_require__(10) /*istanbul ignore end*/;

	var /*istanbul ignore start*/_parse = __webpack_require__(11) /*istanbul ignore end*/;

	var /*istanbul ignore start*/_merge = __webpack_require__(13) /*istanbul ignore end*/;

	var /*istanbul ignore start*/_create = __webpack_require__(14) /*istanbul ignore end*/;

	var /*istanbul ignore start*/_dmp = __webpack_require__(16) /*istanbul ignore end*/;

	var /*istanbul ignore start*/_xml = __webpack_require__(17) /*istanbul ignore end*/;

	/*istanbul ignore start*/function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	/* See LICENSE file for terms of use */

	/*
	 * Text diff implementation.
	 *
	 * This library supports the following APIS:
	 * JsDiff.diffChars: Character by character diff
	 * JsDiff.diffWords: Word (as defined by \b regex) diff which ignores whitespace
	 * JsDiff.diffLines: Line based diff
	 *
	 * JsDiff.diffCss: Diff targeted at CSS content
	 *
	 * These methods are based on the implementation proposed in
	 * "An O(ND) Difference Algorithm and its Variations" (Myers, 1986).
	 * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927
	 */
	exports. /*istanbul ignore end*/Diff = _base2['default'];
	/*istanbul ignore start*/exports. /*istanbul ignore end*/diffChars = _character.diffChars;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/diffWords = _word.diffWords;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/diffWordsWithSpace = _word.diffWordsWithSpace;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/diffLines = _line.diffLines;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/diffTrimmedLines = _line.diffTrimmedLines;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/diffSentences = _sentence.diffSentences;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/diffCss = _css.diffCss;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/diffJson = _json.diffJson;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/diffArrays = _array.diffArrays;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/structuredPatch = _create.structuredPatch;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/createTwoFilesPatch = _create.createTwoFilesPatch;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/createPatch = _create.createPatch;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/applyPatch = _apply.applyPatch;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/applyPatches = _apply.applyPatches;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/parsePatch = _parse.parsePatch;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/merge = _merge.merge;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/convertChangesToDMP = _dmp.convertChangesToDMP;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/convertChangesToXML = _xml.convertChangesToXML;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/canonicalize = _json.canonicalize;



/***/ }),
/* 1 */
/***/ (function(module, exports) {

	/*istanbul ignore start*/'use strict';

	exports.__esModule = true;
	exports['default'] = /*istanbul ignore end*/Diff;
	function Diff() {}

	Diff.prototype = {
	  /*istanbul ignore start*/ /*istanbul ignore end*/diff: function diff(oldString, newString) {
	    /*istanbul ignore start*/var /*istanbul ignore end*/options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	    var callback = options.callback;
	    if (typeof options === 'function') {
	      callback = options;
	      options = {};
	    }
	    this.options = options;

	    var self = this;

	    function done(value) {
	      if (callback) {
	        setTimeout(function () {
	          callback(undefined, value);
	        }, 0);
	        return true;
	      } else {
	        return value;
	      }
	    }

	    // Allow subclasses to massage the input prior to running
	    oldString = this.castInput(oldString);
	    newString = this.castInput(newString);

	    oldString = this.removeEmpty(this.tokenize(oldString));
	    newString = this.removeEmpty(this.tokenize(newString));

	    var newLen = newString.length,
	        oldLen = oldString.length;
	    var editLength = 1;
	    var maxEditLength = newLen + oldLen;
	    var bestPath = [{ newPos: -1, components: [] }];

	    // Seed editLength = 0, i.e. the content starts with the same values
	    var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
	    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
	      // Identity per the equality and tokenizer
	      return done([{ value: this.join(newString), count: newString.length }]);
	    }

	    // Main worker method. checks all permutations of a given edit length for acceptance.
	    function execEditLength() {
	      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
	        var basePath = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;
	        var addPath = bestPath[diagonalPath - 1],
	            removePath = bestPath[diagonalPath + 1],
	            _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;
	        if (addPath) {
	          // No one else is going to attempt to use this value, clear it
	          bestPath[diagonalPath - 1] = undefined;
	        }

	        var canAdd = addPath && addPath.newPos + 1 < newLen,
	            canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;
	        if (!canAdd && !canRemove) {
	          // If this path is a terminal then prune
	          bestPath[diagonalPath] = undefined;
	          continue;
	        }

	        // Select the diagonal that we want to branch from. We select the prior
	        // path whose position in the new string is the farthest from the origin
	        // and does not pass the bounds of the diff graph
	        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
	          basePath = clonePath(removePath);
	          self.pushComponent(basePath.components, undefined, true);
	        } else {
	          basePath = addPath; // No need to clone, we've pulled it from the list
	          basePath.newPos++;
	          self.pushComponent(basePath.components, true, undefined);
	        }

	        _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath);

	        // If we have hit the end of both strings, then we are done
	        if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {
	          return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));
	        } else {
	          // Otherwise track this path as a potential candidate and continue.
	          bestPath[diagonalPath] = basePath;
	        }
	      }

	      editLength++;
	    }

	    // Performs the length of edit iteration. Is a bit fugly as this has to support the
	    // sync and async mode which is never fun. Loops over execEditLength until a value
	    // is produced.
	    if (callback) {
	      (function exec() {
	        setTimeout(function () {
	          // This should not happen, but we want to be safe.
	          /* istanbul ignore next */
	          if (editLength > maxEditLength) {
	            return callback();
	          }

	          if (!execEditLength()) {
	            exec();
	          }
	        }, 0);
	      })();
	    } else {
	      while (editLength <= maxEditLength) {
	        var ret = execEditLength();
	        if (ret) {
	          return ret;
	        }
	      }
	    }
	  },
	  /*istanbul ignore start*/ /*istanbul ignore end*/pushComponent: function pushComponent(components, added, removed) {
	    var last = components[components.length - 1];
	    if (last && last.added === added && last.removed === removed) {
	      // We need to clone here as the component clone operation is just
	      // as shallow array clone
	      components[components.length - 1] = { count: last.count + 1, added: added, removed: removed };
	    } else {
	      components.push({ count: 1, added: added, removed: removed });
	    }
	  },
	  /*istanbul ignore start*/ /*istanbul ignore end*/extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
	    var newLen = newString.length,
	        oldLen = oldString.length,
	        newPos = basePath.newPos,
	        oldPos = newPos - diagonalPath,
	        commonCount = 0;
	    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
	      newPos++;
	      oldPos++;
	      commonCount++;
	    }

	    if (commonCount) {
	      basePath.components.push({ count: commonCount });
	    }

	    basePath.newPos = newPos;
	    return oldPos;
	  },
	  /*istanbul ignore start*/ /*istanbul ignore end*/equals: function equals(left, right) {
	    if (this.options.comparator) {
	      return this.options.comparator(left, right);
	    } else {
	      return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
	    }
	  },
	  /*istanbul ignore start*/ /*istanbul ignore end*/removeEmpty: function removeEmpty(array) {
	    var ret = [];
	    for (var i = 0; i < array.length; i++) {
	      if (array[i]) {
	        ret.push(array[i]);
	      }
	    }
	    return ret;
	  },
	  /*istanbul ignore start*/ /*istanbul ignore end*/castInput: function castInput(value) {
	    return value;
	  },
	  /*istanbul ignore start*/ /*istanbul ignore end*/tokenize: function tokenize(value) {
	    return value.split('');
	  },
	  /*istanbul ignore start*/ /*istanbul ignore end*/join: function join(chars) {
	    return chars.join('');
	  }
	};

	function buildValues(diff, components, newString, oldString, useLongestToken) {
	  var componentPos = 0,
	      componentLen = components.length,
	      newPos = 0,
	      oldPos = 0;

	  for (; componentPos < componentLen; componentPos++) {
	    var component = components[componentPos];
	    if (!component.removed) {
	      if (!component.added && useLongestToken) {
	        var value = newString.slice(newPos, newPos + component.count);
	        value = value.map(function (value, i) {
	          var oldValue = oldString[oldPos + i];
	          return oldValue.length > value.length ? oldValue : value;
	        });

	        component.value = diff.join(value);
	      } else {
	        component.value = diff.join(newString.slice(newPos, newPos + component.count));
	      }
	      newPos += component.count;

	      // Common case
	      if (!component.added) {
	        oldPos += component.count;
	      }
	    } else {
	      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
	      oldPos += component.count;

	      // Reverse add and remove so removes are output first to match common convention
	      // The diffing algorithm is tied to add then remove output and this is the simplest
	      // route to get the desired output with minimal overhead.
	      if (componentPos && components[componentPos - 1].added) {
	        var tmp = components[componentPos - 1];
	        components[componentPos - 1] = components[componentPos];
	        components[componentPos] = tmp;
	      }
	    }
	  }

	  // Special case handle for when one terminal is ignored (i.e. whitespace).
	  // For this case we merge the terminal into the prior string and drop the change.
	  // This is only available for string mode.
	  var lastComponent = components[componentLen - 1];
	  if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {
	    components[componentLen - 2].value += lastComponent.value;
	    components.pop();
	  }

	  return components;
	}

	function clonePath(path) {
	  return { newPos: path.newPos, components: path.components.slice(0) };
	}



/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	/*istanbul ignore start*/'use strict';

	exports.__esModule = true;
	exports.characterDiff = undefined;
	exports. /*istanbul ignore end*/diffChars = diffChars;

	var /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;

	/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	/*istanbul ignore end*/var characterDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/characterDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();
	function diffChars(oldStr, newStr, options) {
	  return characterDiff.diff(oldStr, newStr, options);
	}



/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	/*istanbul ignore start*/'use strict';

	exports.__esModule = true;
	exports.wordDiff = undefined;
	exports. /*istanbul ignore end*/diffWords = diffWords;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/diffWordsWithSpace = diffWordsWithSpace;

	var /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;

	/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);

	/*istanbul ignore end*/var /*istanbul ignore start*/_params = __webpack_require__(4) /*istanbul ignore end*/;

	/*istanbul ignore start*/function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	/*istanbul ignore end*/ // Based on https://en.wikipedia.org/wiki/Latin_script_in_Unicode
	//
	// Ranges and exceptions:
	// Latin-1 Supplement, 008000FF
	//  - U+00D7   Multiplication sign
	//  - U+00F7   Division sign
	// Latin Extended-A, 0100017F
	// Latin Extended-B, 0180024F
	// IPA Extensions, 025002AF
	// Spacing Modifier Letters, 02B002FF
	//  - U+02C7   &#711;  Caron
	//  - U+02D8   &#728;  Breve
	//  - U+02D9   &#729;  Dot Above
	//  - U+02DA   &#730;  Ring Above
	//  - U+02DB   &#731;  Ogonek
	//  - U+02DC   &#732;  Small Tilde
	//  - U+02DD   &#733;  Double Acute Accent
	// Latin Extended Additional, 1E001EFF
	var extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;

	var reWhitespace = /\S/;

	var wordDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/wordDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();
	wordDiff.equals = function (left, right) {
	  if (this.options.ignoreCase) {
	    left = left.toLowerCase();
	    right = right.toLowerCase();
	  }
	  return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
	};
	wordDiff.tokenize = function (value) {
	  var tokens = value.split(/(\s+|\b)/);

	  // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.
	  for (var i = 0; i < tokens.length - 1; i++) {
	    // If we have an empty string in the next field and we have only word chars before and after, merge
	    if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {
	      tokens[i] += tokens[i + 2];
	      tokens.splice(i + 1, 2);
	      i--;
	    }
	  }

	  return tokens;
	};

	function diffWords(oldStr, newStr, options) {
	  options = /*istanbul ignore start*/(0, _params.generateOptions) /*istanbul ignore end*/(options, { ignoreWhitespace: true });
	  return wordDiff.diff(oldStr, newStr, options);
	}

	function diffWordsWithSpace(oldStr, newStr, options) {
	  return wordDiff.diff(oldStr, newStr, options);
	}



/***/ }),
/* 4 */
/***/ (function(module, exports) {

	/*istanbul ignore start*/'use strict';

	exports.__esModule = true;
	exports. /*istanbul ignore end*/generateOptions = generateOptions;
	function generateOptions(options, defaults) {
	  if (typeof options === 'function') {
	    defaults.callback = options;
	  } else if (options) {
	    for (var name in options) {
	      /* istanbul ignore else */
	      if (options.hasOwnProperty(name)) {
	        defaults[name] = options[name];
	      }
	    }
	  }
	  return defaults;
	}



/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	/*istanbul ignore start*/'use strict';

	exports.__esModule = true;
	exports.lineDiff = undefined;
	exports. /*istanbul ignore end*/diffLines = diffLines;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/diffTrimmedLines = diffTrimmedLines;

	var /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;

	/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);

	/*istanbul ignore end*/var /*istanbul ignore start*/_params = __webpack_require__(4) /*istanbul ignore end*/;

	/*istanbul ignore start*/function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	/*istanbul ignore end*/var lineDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/lineDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();
	lineDiff.tokenize = function (value) {
	  var retLines = [],
	      linesAndNewlines = value.split(/(\n|\r\n)/);

	  // Ignore the final empty token that occurs if the string ends with a new line
	  if (!linesAndNewlines[linesAndNewlines.length - 1]) {
	    linesAndNewlines.pop();
	  }

	  // Merge the content and line separators into single tokens
	  for (var i = 0; i < linesAndNewlines.length; i++) {
	    var line = linesAndNewlines[i];

	    if (i % 2 && !this.options.newlineIsToken) {
	      retLines[retLines.length - 1] += line;
	    } else {
	      if (this.options.ignoreWhitespace) {
	        line = line.trim();
	      }
	      retLines.push(line);
	    }
	  }

	  return retLines;
	};

	function diffLines(oldStr, newStr, callback) {
	  return lineDiff.diff(oldStr, newStr, callback);
	}
	function diffTrimmedLines(oldStr, newStr, callback) {
	  var options = /*istanbul ignore start*/(0, _params.generateOptions) /*istanbul ignore end*/(callback, { ignoreWhitespace: true });
	  return lineDiff.diff(oldStr, newStr, options);
	}



/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	/*istanbul ignore start*/'use strict';

	exports.__esModule = true;
	exports.sentenceDiff = undefined;
	exports. /*istanbul ignore end*/diffSentences = diffSentences;

	var /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;

	/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	/*istanbul ignore end*/var sentenceDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/sentenceDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();
	sentenceDiff.tokenize = function (value) {
	  return value.split(/(\S.+?[.!?])(?=\s+|$)/);
	};

	function diffSentences(oldStr, newStr, callback) {
	  return sentenceDiff.diff(oldStr, newStr, callback);
	}



/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	/*istanbul ignore start*/'use strict';

	exports.__esModule = true;
	exports.cssDiff = undefined;
	exports. /*istanbul ignore end*/diffCss = diffCss;

	var /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;

	/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	/*istanbul ignore end*/var cssDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/cssDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();
	cssDiff.tokenize = function (value) {
	  return value.split(/([{}:;,]|\s+)/);
	};

	function diffCss(oldStr, newStr, callback) {
	  return cssDiff.diff(oldStr, newStr, callback);
	}



/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	/*istanbul ignore start*/'use strict';

	exports.__esModule = true;
	exports.jsonDiff = undefined;

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	exports. /*istanbul ignore end*/diffJson = diffJson;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/canonicalize = canonicalize;

	var /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;

	/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);

	/*istanbul ignore end*/var /*istanbul ignore start*/_line = __webpack_require__(5) /*istanbul ignore end*/;

	/*istanbul ignore start*/function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	/*istanbul ignore end*/var objectPrototypeToString = Object.prototype.toString;

	var jsonDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/jsonDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();
	// Discriminate between two lines of pretty-printed, serialized JSON where one of them has a
	// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:
	jsonDiff.useLongestToken = true;

	jsonDiff.tokenize = /*istanbul ignore start*/_line.lineDiff /*istanbul ignore end*/.tokenize;
	jsonDiff.castInput = function (value) {
	  /*istanbul ignore start*/var /*istanbul ignore end*/undefinedReplacement = this.options.undefinedReplacement;


	  return typeof value === 'string' ? value : JSON.stringify(canonicalize(value), function (k, v) {
	    if (typeof v === 'undefined') {
	      return undefinedReplacement;
	    }

	    return v;
	  }, '  ');
	};
	jsonDiff.equals = function (left, right) {
	  return (/*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/.prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, '$1'), right.replace(/,([\r\n])/g, '$1'))
	  );
	};

	function diffJson(oldObj, newObj, options) {
	  return jsonDiff.diff(oldObj, newObj, options);
	}

	// This function handles the presence of circular references by bailing out when encountering an
	// object that is already on the "stack" of items being processed.
	function canonicalize(obj, stack, replacementStack) {
	  stack = stack || [];
	  replacementStack = replacementStack || [];

	  var i = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;

	  for (i = 0; i < stack.length; i += 1) {
	    if (stack[i] === obj) {
	      return replacementStack[i];
	    }
	  }

	  var canonicalizedObj = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;

	  if ('[object Array]' === objectPrototypeToString.call(obj)) {
	    stack.push(obj);
	    canonicalizedObj = new Array(obj.length);
	    replacementStack.push(canonicalizedObj);
	    for (i = 0; i < obj.length; i += 1) {
	      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack);
	    }
	    stack.pop();
	    replacementStack.pop();
	    return canonicalizedObj;
	  }

	  if (obj && obj.toJSON) {
	    obj = obj.toJSON();
	  }

	  if ( /*istanbul ignore start*/(typeof /*istanbul ignore end*/obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && obj !== null) {
	    stack.push(obj);
	    canonicalizedObj = {};
	    replacementStack.push(canonicalizedObj);
	    var sortedKeys = [],
	        key = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;
	    for (key in obj) {
	      /* istanbul ignore else */
	      if (obj.hasOwnProperty(key)) {
	        sortedKeys.push(key);
	      }
	    }
	    sortedKeys.sort();
	    for (i = 0; i < sortedKeys.length; i += 1) {
	      key = sortedKeys[i];
	      canonicalizedObj[key] = canonicalize(obj[key], stack, replacementStack);
	    }
	    stack.pop();
	    replacementStack.pop();
	  } else {
	    canonicalizedObj = obj;
	  }
	  return canonicalizedObj;
	}



/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	/*istanbul ignore start*/'use strict';

	exports.__esModule = true;
	exports.arrayDiff = undefined;
	exports. /*istanbul ignore end*/diffArrays = diffArrays;

	var /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;

	/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	/*istanbul ignore end*/var arrayDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/arrayDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();
	arrayDiff.tokenize = arrayDiff.join = function (value) {
	  return value.slice();
	};
	arrayDiff.removeEmpty = function (value) {
	  return value;
	};

	function diffArrays(oldArr, newArr, callback) {
	  return arrayDiff.diff(oldArr, newArr, callback);
	}



/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	/*istanbul ignore start*/'use strict';

	exports.__esModule = true;
	exports. /*istanbul ignore end*/applyPatch = applyPatch;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/applyPatches = applyPatches;

	var /*istanbul ignore start*/_parse = __webpack_require__(11) /*istanbul ignore end*/;

	var /*istanbul ignore start*/_distanceIterator = __webpack_require__(12) /*istanbul ignore end*/;

	/*istanbul ignore start*/var _distanceIterator2 = _interopRequireDefault(_distanceIterator);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	/*istanbul ignore end*/function applyPatch(source, uniDiff) {
	  /*istanbul ignore start*/var /*istanbul ignore end*/options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	  if (typeof uniDiff === 'string') {
	    uniDiff = /*istanbul ignore start*/(0, _parse.parsePatch) /*istanbul ignore end*/(uniDiff);
	  }

	  if (Array.isArray(uniDiff)) {
	    if (uniDiff.length > 1) {
	      throw new Error('applyPatch only works with a single input.');
	    }

	    uniDiff = uniDiff[0];
	  }

	  // Apply the diff to the input
	  var lines = source.split(/\r\n|[\n\v\f\r\x85]/),
	      delimiters = source.match(/\r\n|[\n\v\f\r\x85]/g) || [],
	      hunks = uniDiff.hunks,
	      compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) /*istanbul ignore start*/{
	    return (/*istanbul ignore end*/line === patchContent
	    );
	  },
	      errorCount = 0,
	      fuzzFactor = options.fuzzFactor || 0,
	      minLine = 0,
	      offset = 0,
	      removeEOFNL = /*istanbul ignore start*/void 0 /*istanbul ignore end*/,
	      addEOFNL = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;

	  /**
	   * Checks if the hunk exactly fits on the provided location
	   */
	  function hunkFits(hunk, toPos) {
	    for (var j = 0; j < hunk.lines.length; j++) {
	      var line = hunk.lines[j],
	          operation = line[0],
	          content = line.substr(1);

	      if (operation === ' ' || operation === '-') {
	        // Context sanity check
	        if (!compareLine(toPos + 1, lines[toPos], operation, content)) {
	          errorCount++;

	          if (errorCount > fuzzFactor) {
	            return false;
	          }
	        }
	        toPos++;
	      }
	    }

	    return true;
	  }

	  // Search best fit offsets for each hunk based on the previous ones
	  for (var i = 0; i < hunks.length; i++) {
	    var hunk = hunks[i],
	        maxLine = lines.length - hunk.oldLines,
	        localOffset = 0,
	        toPos = offset + hunk.oldStart - 1;

	    var iterator = /*istanbul ignore start*/(0, _distanceIterator2['default']) /*istanbul ignore end*/(toPos, minLine, maxLine);

	    for (; localOffset !== undefined; localOffset = iterator()) {
	      if (hunkFits(hunk, toPos + localOffset)) {
	        hunk.offset = offset += localOffset;
	        break;
	      }
	    }

	    if (localOffset === undefined) {
	      return false;
	    }

	    // Set lower text limit to end of the current hunk, so next ones don't try
	    // to fit over already patched text
	    minLine = hunk.offset + hunk.oldStart + hunk.oldLines;
	  }

	  // Apply patch hunks
	  var diffOffset = 0;
	  for (var _i = 0; _i < hunks.length; _i++) {
	    var _hunk = hunks[_i],
	        _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;
	    diffOffset += _hunk.newLines - _hunk.oldLines;

	    if (_toPos < 0) {
	      // Creating a new file
	      _toPos = 0;
	    }

	    for (var j = 0; j < _hunk.lines.length; j++) {
	      var line = _hunk.lines[j],
	          operation = line[0],
	          content = line.substr(1),
	          delimiter = _hunk.linedelimiters[j];

	      if (operation === ' ') {
	        _toPos++;
	      } else if (operation === '-') {
	        lines.splice(_toPos, 1);
	        delimiters.splice(_toPos, 1);
	        /* istanbul ignore else */
	      } else if (operation === '+') {
	        lines.splice(_toPos, 0, content);
	        delimiters.splice(_toPos, 0, delimiter);
	        _toPos++;
	      } else if (operation === '\\') {
	        var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;
	        if (previousOperation === '+') {
	          removeEOFNL = true;
	        } else if (previousOperation === '-') {
	          addEOFNL = true;
	        }
	      }
	    }
	  }

	  // Handle EOFNL insertion/removal
	  if (removeEOFNL) {
	    while (!lines[lines.length - 1]) {
	      lines.pop();
	      delimiters.pop();
	    }
	  } else if (addEOFNL) {
	    lines.push('');
	    delimiters.push('\n');
	  }
	  for (var _k = 0; _k < lines.length - 1; _k++) {
	    lines[_k] = lines[_k] + delimiters[_k];
	  }
	  return lines.join('');
	}

	// Wrapper that supports multiple file patches via callbacks.
	function applyPatches(uniDiff, options) {
	  if (typeof uniDiff === 'string') {
	    uniDiff = /*istanbul ignore start*/(0, _parse.parsePatch) /*istanbul ignore end*/(uniDiff);
	  }

	  var currentIndex = 0;
	  function processIndex() {
	    var index = uniDiff[currentIndex++];
	    if (!index) {
	      return options.complete();
	    }

	    options.loadFile(index, function (err, data) {
	      if (err) {
	        return options.complete(err);
	      }

	      var updatedContent = applyPatch(data, index, options);
	      options.patched(index, updatedContent, function (err) {
	        if (err) {
	          return options.complete(err);
	        }

	        processIndex();
	      });
	    });
	  }
	  processIndex();
	}



/***/ }),
/* 11 */
/***/ (function(module, exports) {

	/*istanbul ignore start*/'use strict';

	exports.__esModule = true;
	exports. /*istanbul ignore end*/parsePatch = parsePatch;
	function parsePatch(uniDiff) {
	  /*istanbul ignore start*/var /*istanbul ignore end*/options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	  var diffstr = uniDiff.split(/\r\n|[\n\v\f\r\x85]/),
	      delimiters = uniDiff.match(/\r\n|[\n\v\f\r\x85]/g) || [],
	      list = [],
	      i = 0;

	  function parseIndex() {
	    var index = {};
	    list.push(index);

	    // Parse diff metadata
	    while (i < diffstr.length) {
	      var line = diffstr[i];

	      // File header found, end parsing diff metadata
	      if (/^(\-\-\-|\+\+\+|@@)\s/.test(line)) {
	        break;
	      }

	      // Diff index
	      var header = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(line);
	      if (header) {
	        index.index = header[1];
	      }

	      i++;
	    }

	    // Parse file headers if they are defined. Unified diff requires them, but
	    // there's no technical issues to have an isolated hunk without file header
	    parseFileHeader(index);
	    parseFileHeader(index);

	    // Parse hunks
	    index.hunks = [];

	    while (i < diffstr.length) {
	      var _line = diffstr[i];

	      if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(_line)) {
	        break;
	      } else if (/^@@/.test(_line)) {
	        index.hunks.push(parseHunk());
	      } else if (_line && options.strict) {
	        // Ignore unexpected content unless in strict mode
	        throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));
	      } else {
	        i++;
	      }
	    }
	  }

	  // Parses the --- and +++ headers, if none are found, no lines
	  // are consumed.
	  function parseFileHeader(index) {
	    var headerPattern = /^(---|\+\+\+)\s+([\S ]*)(?:\t(.*?)\s*)?$/;
	    var fileHeader = headerPattern.exec(diffstr[i]);
	    if (fileHeader) {
	      var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';
	      var fileName = fileHeader[2].replace(/\\\\/g, '\\');
	      if (/^".*"$/.test(fileName)) {
	        fileName = fileName.substr(1, fileName.length - 2);
	      }
	      index[keyPrefix + 'FileName'] = fileName;
	      index[keyPrefix + 'Header'] = fileHeader[3];

	      i++;
	    }
	  }

	  // Parses a hunk
	  // This assumes that we are at the start of a hunk.
	  function parseHunk() {
	    var chunkHeaderIndex = i,
	        chunkHeaderLine = diffstr[i++],
	        chunkHeader = chunkHeaderLine.split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/);

	    var hunk = {
	      oldStart: +chunkHeader[1],
	      oldLines: +chunkHeader[2] || 1,
	      newStart: +chunkHeader[3],
	      newLines: +chunkHeader[4] || 1,
	      lines: [],
	      linedelimiters: []
	    };

	    var addCount = 0,
	        removeCount = 0;
	    for (; i < diffstr.length; i++) {
	      // Lines starting with '---' could be mistaken for the "remove line" operation
	      // But they could be the header for the next file. Therefore prune such cases out.
	      if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {
	        break;
	      }
	      var operation = diffstr[i][0];

	      if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\') {
	        hunk.lines.push(diffstr[i]);
	        hunk.linedelimiters.push(delimiters[i] || '\n');

	        if (operation === '+') {
	          addCount++;
	        } else if (operation === '-') {
	          removeCount++;
	        } else if (operation === ' ') {
	          addCount++;
	          removeCount++;
	        }
	      } else {
	        break;
	      }
	    }

	    // Handle the empty block count case
	    if (!addCount && hunk.newLines === 1) {
	      hunk.newLines = 0;
	    }
	    if (!removeCount && hunk.oldLines === 1) {
	      hunk.oldLines = 0;
	    }

	    // Perform optional sanity checking
	    if (options.strict) {
	      if (addCount !== hunk.newLines) {
	        throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));
	      }
	      if (removeCount !== hunk.oldLines) {
	        throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));
	      }
	    }

	    return hunk;
	  }

	  while (i < diffstr.length) {
	    parseIndex();
	  }

	  return list;
	}



/***/ }),
/* 12 */
/***/ (function(module, exports) {

	/*istanbul ignore start*/"use strict";

	exports.__esModule = true;

	exports["default"] = /*istanbul ignore end*/function (start, minLine, maxLine) {
	  var wantForward = true,
	      backwardExhausted = false,
	      forwardExhausted = false,
	      localOffset = 1;

	  return function iterator() {
	    if (wantForward && !forwardExhausted) {
	      if (backwardExhausted) {
	        localOffset++;
	      } else {
	        wantForward = false;
	      }

	      // Check if trying to fit beyond text length, and if not, check it fits
	      // after offset location (or desired location on first iteration)
	      if (start + localOffset <= maxLine) {
	        return localOffset;
	      }

	      forwardExhausted = true;
	    }

	    if (!backwardExhausted) {
	      if (!forwardExhausted) {
	        wantForward = true;
	      }

	      // Check if trying to fit before text beginning, and if not, check it fits
	      // before offset location
	      if (minLine <= start - localOffset) {
	        return -localOffset++;
	      }

	      backwardExhausted = true;
	      return iterator();
	    }

	    // We tried to fit hunk before text beginning and beyond text length, then
	    // hunk can't fit on the text. Return undefined
	  };
	};



/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	/*istanbul ignore start*/'use strict';

	exports.__esModule = true;
	exports. /*istanbul ignore end*/calcLineCount = calcLineCount;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/merge = merge;

	var /*istanbul ignore start*/_create = __webpack_require__(14) /*istanbul ignore end*/;

	var /*istanbul ignore start*/_parse = __webpack_require__(11) /*istanbul ignore end*/;

	var /*istanbul ignore start*/_array = __webpack_require__(15) /*istanbul ignore end*/;

	/*istanbul ignore start*/function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	/*istanbul ignore end*/function calcLineCount(hunk) {
	  /*istanbul ignore start*/var _calcOldNewLineCount = /*istanbul ignore end*/calcOldNewLineCount(hunk.lines),
	      oldLines = _calcOldNewLineCount.oldLines,
	      newLines = _calcOldNewLineCount.newLines;

	  if (oldLines !== undefined) {
	    hunk.oldLines = oldLines;
	  } else {
	    delete hunk.oldLines;
	  }

	  if (newLines !== undefined) {
	    hunk.newLines = newLines;
	  } else {
	    delete hunk.newLines;
	  }
	}

	function merge(mine, theirs, base) {
	  mine = loadPatch(mine, base);
	  theirs = loadPatch(theirs, base);

	  var ret = {};

	  // For index we just let it pass through as it doesn't have any necessary meaning.
	  // Leaving sanity checks on this to the API consumer that may know more about the
	  // meaning in their own context.
	  if (mine.index || theirs.index) {
	    ret.index = mine.index || theirs.index;
	  }

	  if (mine.newFileName || theirs.newFileName) {
	    if (!fileNameChanged(mine)) {
	      // No header or no change in ours, use theirs (and ours if theirs does not exist)
	      ret.oldFileName = theirs.oldFileName || mine.oldFileName;
	      ret.newFileName = theirs.newFileName || mine.newFileName;
	      ret.oldHeader = theirs.oldHeader || mine.oldHeader;
	      ret.newHeader = theirs.newHeader || mine.newHeader;
	    } else if (!fileNameChanged(theirs)) {
	      // No header or no change in theirs, use ours
	      ret.oldFileName = mine.oldFileName;
	      ret.newFileName = mine.newFileName;
	      ret.oldHeader = mine.oldHeader;
	      ret.newHeader = mine.newHeader;
	    } else {
	      // Both changed... figure it out
	      ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);
	      ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);
	      ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);
	      ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);
	    }
	  }

	  ret.hunks = [];

	  var mineIndex = 0,
	      theirsIndex = 0,
	      mineOffset = 0,
	      theirsOffset = 0;

	  while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {
	    var mineCurrent = mine.hunks[mineIndex] || { oldStart: Infinity },
	        theirsCurrent = theirs.hunks[theirsIndex] || { oldStart: Infinity };

	    if (hunkBefore(mineCurrent, theirsCurrent)) {
	      // This patch does not overlap with any of the others, yay.
	      ret.hunks.push(cloneHunk(mineCurrent, mineOffset));
	      mineIndex++;
	      theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;
	    } else if (hunkBefore(theirsCurrent, mineCurrent)) {
	      // This patch does not overlap with any of the others, yay.
	      ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));
	      theirsIndex++;
	      mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;
	    } else {
	      // Overlap, merge as best we can
	      var mergedHunk = {
	        oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),
	        oldLines: 0,
	        newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),
	        newLines: 0,
	        lines: []
	      };
	      mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);
	      theirsIndex++;
	      mineIndex++;

	      ret.hunks.push(mergedHunk);
	    }
	  }

	  return ret;
	}

	function loadPatch(param, base) {
	  if (typeof param === 'string') {
	    if (/^@@/m.test(param) || /^Index:/m.test(param)) {
	      return (/*istanbul ignore start*/(0, _parse.parsePatch) /*istanbul ignore end*/(param)[0]
	      );
	    }

	    if (!base) {
	      throw new Error('Must provide a base reference or pass in a patch');
	    }
	    return (/*istanbul ignore start*/(0, _create.structuredPatch) /*istanbul ignore end*/(undefined, undefined, base, param)
	    );
	  }

	  return param;
	}

	function fileNameChanged(patch) {
	  return patch.newFileName && patch.newFileName !== patch.oldFileName;
	}

	function selectField(index, mine, theirs) {
	  if (mine === theirs) {
	    return mine;
	  } else {
	    index.conflict = true;
	    return { mine: mine, theirs: theirs };
	  }
	}

	function hunkBefore(test, check) {
	  return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;
	}

	function cloneHunk(hunk, offset) {
	  return {
	    oldStart: hunk.oldStart, oldLines: hunk.oldLines,
	    newStart: hunk.newStart + offset, newLines: hunk.newLines,
	    lines: hunk.lines
	  };
	}

	function mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {
	  // This will generally result in a conflicted hunk, but there are cases where the context
	  // is the only overlap where we can successfully merge the content here.
	  var mine = { offset: mineOffset, lines: mineLines, index: 0 },
	      their = { offset: theirOffset, lines: theirLines, index: 0 };

	  // Handle any leading content
	  insertLeading(hunk, mine, their);
	  insertLeading(hunk, their, mine);

	  // Now in the overlap content. Scan through and select the best changes from each.
	  while (mine.index < mine.lines.length && their.index < their.lines.length) {
	    var mineCurrent = mine.lines[mine.index],
	        theirCurrent = their.lines[their.index];

	    if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {
	      // Both modified ...
	      mutualChange(hunk, mine, their);
	    } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {
	      /*istanbul ignore start*/var _hunk$lines;

	      /*istanbul ignore end*/ // Mine inserted
	      /*istanbul ignore start*/(_hunk$lines = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/collectChange(mine)));
	    } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {
	      /*istanbul ignore start*/var _hunk$lines2;

	      /*istanbul ignore end*/ // Theirs inserted
	      /*istanbul ignore start*/(_hunk$lines2 = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines2 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/collectChange(their)));
	    } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {
	      // Mine removed or edited
	      removal(hunk, mine, their);
	    } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {
	      // Their removed or edited
	      removal(hunk, their, mine, true);
	    } else if (mineCurrent === theirCurrent) {
	      // Context identity
	      hunk.lines.push(mineCurrent);
	      mine.index++;
	      their.index++;
	    } else {
	      // Context mismatch
	      conflict(hunk, collectChange(mine), collectChange(their));
	    }
	  }

	  // Now push anything that may be remaining
	  insertTrailing(hunk, mine);
	  insertTrailing(hunk, their);

	  calcLineCount(hunk);
	}

	function mutualChange(hunk, mine, their) {
	  var myChanges = collectChange(mine),
	      theirChanges = collectChange(their);

	  if (allRemoves(myChanges) && allRemoves(theirChanges)) {
	    // Special case for remove changes that are supersets of one another
	    if ( /*istanbul ignore start*/(0, _array.arrayStartsWith) /*istanbul ignore end*/(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {
	      /*istanbul ignore start*/var _hunk$lines3;

	      /*istanbul ignore end*/ /*istanbul ignore start*/(_hunk$lines3 = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines3 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/myChanges));
	      return;
	    } else if ( /*istanbul ignore start*/(0, _array.arrayStartsWith) /*istanbul ignore end*/(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {
	      /*istanbul ignore start*/var _hunk$lines4;

	      /*istanbul ignore end*/ /*istanbul ignore start*/(_hunk$lines4 = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines4 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/theirChanges));
	      return;
	    }
	  } else if ( /*istanbul ignore start*/(0, _array.arrayEqual) /*istanbul ignore end*/(myChanges, theirChanges)) {
	    /*istanbul ignore start*/var _hunk$lines5;

	    /*istanbul ignore end*/ /*istanbul ignore start*/(_hunk$lines5 = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines5 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/myChanges));
	    return;
	  }

	  conflict(hunk, myChanges, theirChanges);
	}

	function removal(hunk, mine, their, swap) {
	  var myChanges = collectChange(mine),
	      theirChanges = collectContext(their, myChanges);
	  if (theirChanges.merged) {
	    /*istanbul ignore start*/var _hunk$lines6;

	    /*istanbul ignore end*/ /*istanbul ignore start*/(_hunk$lines6 = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines6 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/theirChanges.merged));
	  } else {
	    conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);
	  }
	}

	function conflict(hunk, mine, their) {
	  hunk.conflict = true;
	  hunk.lines.push({
	    conflict: true,
	    mine: mine,
	    theirs: their
	  });
	}

	function insertLeading(hunk, insert, their) {
	  while (insert.offset < their.offset && insert.index < insert.lines.length) {
	    var line = insert.lines[insert.index++];
	    hunk.lines.push(line);
	    insert.offset++;
	  }
	}
	function insertTrailing(hunk, insert) {
	  while (insert.index < insert.lines.length) {
	    var line = insert.lines[insert.index++];
	    hunk.lines.push(line);
	  }
	}

	function collectChange(state) {
	  var ret = [],
	      operation = state.lines[state.index][0];
	  while (state.index < state.lines.length) {
	    var line = state.lines[state.index];

	    // Group additions that are immediately after subtractions and treat them as one "atomic" modify change.
	    if (operation === '-' && line[0] === '+') {
	      operation = '+';
	    }

	    if (operation === line[0]) {
	      ret.push(line);
	      state.index++;
	    } else {
	      break;
	    }
	  }

	  return ret;
	}
	function collectContext(state, matchChanges) {
	  var changes = [],
	      merged = [],
	      matchIndex = 0,
	      contextChanges = false,
	      conflicted = false;
	  while (matchIndex < matchChanges.length && state.index < state.lines.length) {
	    var change = state.lines[state.index],
	        match = matchChanges[matchIndex];

	    // Once we've hit our add, then we are done
	    if (match[0] === '+') {
	      break;
	    }

	    contextChanges = contextChanges || change[0] !== ' ';

	    merged.push(match);
	    matchIndex++;

	    // Consume any additions in the other block as a conflict to attempt
	    // to pull in the remaining context after this
	    if (change[0] === '+') {
	      conflicted = true;

	      while (change[0] === '+') {
	        changes.push(change);
	        change = state.lines[++state.index];
	      }
	    }

	    if (match.substr(1) === change.substr(1)) {
	      changes.push(change);
	      state.index++;
	    } else {
	      conflicted = true;
	    }
	  }

	  if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {
	    conflicted = true;
	  }

	  if (conflicted) {
	    return changes;
	  }

	  while (matchIndex < matchChanges.length) {
	    merged.push(matchChanges[matchIndex++]);
	  }

	  return {
	    merged: merged,
	    changes: changes
	  };
	}

	function allRemoves(changes) {
	  return changes.reduce(function (prev, change) {
	    return prev && change[0] === '-';
	  }, true);
	}
	function skipRemoveSuperset(state, removeChanges, delta) {
	  for (var i = 0; i < delta; i++) {
	    var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);
	    if (state.lines[state.index + i] !== ' ' + changeContent) {
	      return false;
	    }
	  }

	  state.index += delta;
	  return true;
	}

	function calcOldNewLineCount(lines) {
	  var oldLines = 0;
	  var newLines = 0;

	  lines.forEach(function (line) {
	    if (typeof line !== 'string') {
	      var myCount = calcOldNewLineCount(line.mine);
	      var theirCount = calcOldNewLineCount(line.theirs);

	      if (oldLines !== undefined) {
	        if (myCount.oldLines === theirCount.oldLines) {
	          oldLines += myCount.oldLines;
	        } else {
	          oldLines = undefined;
	        }
	      }

	      if (newLines !== undefined) {
	        if (myCount.newLines === theirCount.newLines) {
	          newLines += myCount.newLines;
	        } else {
	          newLines = undefined;
	        }
	      }
	    } else {
	      if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {
	        newLines++;
	      }
	      if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {
	        oldLines++;
	      }
	    }
	  });

	  return { oldLines: oldLines, newLines: newLines };
	}



/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	/*istanbul ignore start*/'use strict';

	exports.__esModule = true;
	exports. /*istanbul ignore end*/structuredPatch = structuredPatch;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/createTwoFilesPatch = createTwoFilesPatch;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/createPatch = createPatch;

	var /*istanbul ignore start*/_line = __webpack_require__(5) /*istanbul ignore end*/;

	/*istanbul ignore start*/function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	/*istanbul ignore end*/function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
	  if (!options) {
	    options = {};
	  }
	  if (typeof options.context === 'undefined') {
	    options.context = 4;
	  }

	  var diff = /*istanbul ignore start*/(0, _line.diffLines) /*istanbul ignore end*/(oldStr, newStr, options);
	  diff.push({ value: '', lines: [] }); // Append an empty value to make cleanup easier

	  function contextLines(lines) {
	    return lines.map(function (entry) {
	      return ' ' + entry;
	    });
	  }

	  var hunks = [];
	  var oldRangeStart = 0,
	      newRangeStart = 0,
	      curRange = [],
	      oldLine = 1,
	      newLine = 1;

	  /*istanbul ignore start*/var _loop = function _loop( /*istanbul ignore end*/i) {
	    var current = diff[i],
	        lines = current.lines || current.value.replace(/\n$/, '').split('\n');
	    current.lines = lines;

	    if (current.added || current.removed) {
	      /*istanbul ignore start*/var _curRange;

	      /*istanbul ignore end*/ // If we have previous context, start with that
	      if (!oldRangeStart) {
	        var prev = diff[i - 1];
	        oldRangeStart = oldLine;
	        newRangeStart = newLine;

	        if (prev) {
	          curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];
	          oldRangeStart -= curRange.length;
	          newRangeStart -= curRange.length;
	        }
	      }

	      // Output our changes
	      /*istanbul ignore start*/(_curRange = /*istanbul ignore end*/curRange).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_curRange /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/lines.map(function (entry) {
	        return (current.added ? '+' : '-') + entry;
	      })));

	      // Track the updated file position
	      if (current.added) {
	        newLine += lines.length;
	      } else {
	        oldLine += lines.length;
	      }
	    } else {
	      // Identical context lines. Track line changes
	      if (oldRangeStart) {
	        // Close out any changes that have been output (or join overlapping)
	        if (lines.length <= options.context * 2 && i < diff.length - 2) {
	          /*istanbul ignore start*/var _curRange2;

	          /*istanbul ignore end*/ // Overlapping
	          /*istanbul ignore start*/(_curRange2 = /*istanbul ignore end*/curRange).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_curRange2 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/contextLines(lines)));
	        } else {
	          /*istanbul ignore start*/var _curRange3;

	          /*istanbul ignore end*/ // end the range and output
	          var contextSize = Math.min(lines.length, options.context);
	          /*istanbul ignore start*/(_curRange3 = /*istanbul ignore end*/curRange).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_curRange3 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/contextLines(lines.slice(0, contextSize))));

	          var hunk = {
	            oldStart: oldRangeStart,
	            oldLines: oldLine - oldRangeStart + contextSize,
	            newStart: newRangeStart,
	            newLines: newLine - newRangeStart + contextSize,
	            lines: curRange
	          };
	          if (i >= diff.length - 2 && lines.length <= options.context) {
	            // EOF is inside this hunk
	            var oldEOFNewline = /\n$/.test(oldStr);
	            var newEOFNewline = /\n$/.test(newStr);
	            if (lines.length == 0 && !oldEOFNewline) {
	              // special case: old has no eol and no trailing context; no-nl can end up before adds
	              curRange.splice(hunk.oldLines, 0, '\\ No newline at end of file');
	            } else if (!oldEOFNewline || !newEOFNewline) {
	              curRange.push('\\ No newline at end of file');
	            }
	          }
	          hunks.push(hunk);

	          oldRangeStart = 0;
	          newRangeStart = 0;
	          curRange = [];
	        }
	      }
	      oldLine += lines.length;
	      newLine += lines.length;
	    }
	  };

	  for (var i = 0; i < diff.length; i++) {
	    /*istanbul ignore start*/_loop( /*istanbul ignore end*/i);
	  }

	  return {
	    oldFileName: oldFileName, newFileName: newFileName,
	    oldHeader: oldHeader, newHeader: newHeader,
	    hunks: hunks
	  };
	}

	function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
	  var diff = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options);

	  var ret = [];
	  if (oldFileName == newFileName) {
	    ret.push('Index: ' + oldFileName);
	  }
	  ret.push('===================================================================');
	  ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\t' + diff.oldHeader));
	  ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\t' + diff.newHeader));

	  for (var i = 0; i < diff.hunks.length; i++) {
	    var hunk = diff.hunks[i];
	    ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');
	    ret.push.apply(ret, hunk.lines);
	  }

	  return ret.join('\n') + '\n';
	}

	function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {
	  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);
	}



/***/ }),
/* 15 */
/***/ (function(module, exports) {

	/*istanbul ignore start*/"use strict";

	exports.__esModule = true;
	exports. /*istanbul ignore end*/arrayEqual = arrayEqual;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/arrayStartsWith = arrayStartsWith;
	function arrayEqual(a, b) {
	  if (a.length !== b.length) {
	    return false;
	  }

	  return arrayStartsWith(a, b);
	}

	function arrayStartsWith(array, start) {
	  if (start.length > array.length) {
	    return false;
	  }

	  for (var i = 0; i < start.length; i++) {
	    if (start[i] !== array[i]) {
	      return false;
	    }
	  }

	  return true;
	}



/***/ }),
/* 16 */
/***/ (function(module, exports) {

	/*istanbul ignore start*/"use strict";

	exports.__esModule = true;
	exports. /*istanbul ignore end*/convertChangesToDMP = convertChangesToDMP;
	// See: http://code.google.com/p/google-diff-match-patch/wiki/API
	function convertChangesToDMP(changes) {
	  var ret = [],
	      change = /*istanbul ignore start*/void 0 /*istanbul ignore end*/,
	      operation = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;
	  for (var i = 0; i < changes.length; i++) {
	    change = changes[i];
	    if (change.added) {
	      operation = 1;
	    } else if (change.removed) {
	      operation = -1;
	    } else {
	      operation = 0;
	    }

	    ret.push([operation, change.value]);
	  }
	  return ret;
	}



/***/ }),
/* 17 */
/***/ (function(module, exports) {

	/*istanbul ignore start*/'use strict';

	exports.__esModule = true;
	exports. /*istanbul ignore end*/convertChangesToXML = convertChangesToXML;
	function convertChangesToXML(changes) {
	  var ret = [];
	  for (var i = 0; i < changes.length; i++) {
	    var change = changes[i];
	    if (change.added) {
	      ret.push('<ins>');
	    } else if (change.removed) {
	      ret.push('<del>');
	    }

	    ret.push(escapeHTML(change.value));

	    if (change.added) {
	      ret.push('</ins>');
	    } else if (change.removed) {
	      ret.push('</del>');
	    }
	  }
	  return ret.join('');
	}

	function escapeHTML(s) {
	  var n = s;
	  n = n.replace(/&/g, '&amp;');
	  n = n.replace(/</g, '&lt;');
	  n = n.replace(/>/g, '&gt;');
	  n = n.replace(/"/g, '&quot;');

	  return n;
	}



/***/ })
/******/ ])
});
;
},{}],9:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],10:[function(require,module,exports){
// Copyright 2014, 2016 Simon Lydell
// X11 (MIT) Licensed. (See LICENSE.)

function stringify (obj, options) {
  options = options || {}
  var indent = JSON.stringify([1], null, get(options, 'indent', 2)).slice(2, -3)
  var maxLength = (indent === '' ? Infinity : get(options, 'maxLength', 80))

  return (function _stringify (obj, currentIndent, reserved) {
    if (obj && typeof obj.toJSON === 'function') {
      obj = obj.toJSON()
    }

    var string = JSON.stringify(obj)

    if (string === undefined) {
      return string
    }

    var length = maxLength - currentIndent.length - reserved

    if (string.length <= length) {
      var prettified = prettify(string)
      if (prettified.length <= length) {
        return prettified
      }
    }

    if (typeof obj === 'object' && obj !== null) {
      var nextIndent = currentIndent + indent
      var items = []
      var delimiters
      var comma = function (array, index) {
        return (index === array.length - 1 ? 0 : 1)
      }

      if (Array.isArray(obj)) {
        for (var index = 0; index < obj.length; index++) {
          items.push(
            _stringify(obj[index], nextIndent, comma(obj, index)) || 'null'
          )
        }
        delimiters = '[]'
      } else {
        Object.keys(obj).forEach(function (key, index, array) {
          var keyPart = JSON.stringify(key) + ': '
          var value = _stringify(obj[key], nextIndent,
                                 keyPart.length + comma(array, index))
          if (value !== undefined) {
            items.push(keyPart + value)
          }
        })
        delimiters = '{}'
      }

      if (items.length > 0) {
        return [
          delimiters[0],
          indent + items.join(',\n' + nextIndent),
          delimiters[1]
        ].join('\n' + currentIndent)
      }
    }

    return string
  }(obj, '', 0))
}

// Note: This regex matches even invalid JSON strings, but since were
// working on the output of `JSON.stringify` we know that only valid strings
// are present (unless the user supplied a weird `options.indent` but in
// that case we dont care since the output would be invalid anyway).
var stringOrChar = /("(?:[^\\"]|\\.)*")|[:,]/g

function prettify (string) {
  return string.replace(stringOrChar, function (match, string) {
    return string ? match : match + ' '
  })
}

function get (options, name, defaultValue) {
  return (name in options ? options[name] : defaultValue)
}

module.exports = stringify

},{}],11:[function(require,module,exports){
(function (process){
/* parser generated by jison 0.4.15 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var parser = (function(){
var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,12],$V1=[1,13],$V2=[1,9],$V3=[1,10],$V4=[1,11],$V5=[1,14],$V6=[1,15],$V7=[14,18,22,24],$V8=[18,22],$V9=[22,24];
var parser = {trace: function trace() { },
yy: {},
symbols_: {"error":2,"JSONString":3,"STRING":4,"JSONNumber":5,"NUMBER":6,"JSONNullLiteral":7,"NULL":8,"JSONBooleanLiteral":9,"TRUE":10,"FALSE":11,"JSONText":12,"JSONValue":13,"EOF":14,"JSONObject":15,"JSONArray":16,"{":17,"}":18,"JSONMemberList":19,"JSONMember":20,":":21,",":22,"[":23,"]":24,"JSONElementList":25,"$accept":0,"$end":1},
terminals_: {2:"error",4:"STRING",6:"NUMBER",8:"NULL",10:"TRUE",11:"FALSE",14:"EOF",17:"{",18:"}",21:":",22:",",23:"[",24:"]"},
productions_: [0,[3,1],[5,1],[7,1],[9,1],[9,1],[12,2],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[15,2],[15,3],[20,3],[19,1],[19,3],[16,2],[16,3],[25,1],[25,3]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:
 // replace escaped characters with actual character
          this.$ = new String(yytext.replace(/\\(\\|")/g, "$"+"1")
                     .replace(/\\n/g,'\n')
                     .replace(/\\r/g,'\r')
                     .replace(/\\t/g,'\t')
                     .replace(/\\v/g,'\v')
                     .replace(/\\f/g,'\f')
                     .replace(/\\b/g,'\b'));
          this.$.__line__ =  this._$.first_line;
        
break;
case 2:

            this.$ = new Number(yytext);
            this.$.__line__ =  this._$.first_line;
        
break;
case 3:

            this.$ = null;
        
break;
case 4:

            this.$ = new Boolean(true);
            this.$.__line__ = this._$.first_line;
        
break;
case 5:

            this.$ = new Boolean(false);
            this.$.__line__ = this._$.first_line;
        
break;
case 6:
return this.$ = $$[$0-1];
break;
case 13:
this.$ = {}; Object.defineProperty(this.$, '__line__', {
            value: this._$.first_line,
            enumerable: false
        })
break;
case 14: case 19:
this.$ = $$[$0-1]; Object.defineProperty(this.$, '__line__', {
            value: this._$.first_line,
            enumerable: false
        })
break;
case 15:
this.$ = [$$[$0-2], $$[$0]];
break;
case 16:
this.$ = {}; this.$[$$[$0][0]] = $$[$0][1];
break;
case 17:
this.$ = $$[$0-2]; $$[$0-2][$$[$0][0]] = $$[$0][1];
break;
case 18:
this.$ = []; Object.defineProperty(this.$, '__line__', {
            value: this._$.first_line,
            enumerable: false
        })
break;
case 20:
this.$ = [$$[$0]];
break;
case 21:
this.$ = $$[$0-2]; $$[$0-2].push($$[$0]);
break;
}
},
table: [{3:5,4:$V0,5:6,6:$V1,7:3,8:$V2,9:4,10:$V3,11:$V4,12:1,13:2,15:7,16:8,17:$V5,23:$V6},{1:[3]},{14:[1,16]},o($V7,[2,7]),o($V7,[2,8]),o($V7,[2,9]),o($V7,[2,10]),o($V7,[2,11]),o($V7,[2,12]),o($V7,[2,3]),o($V7,[2,4]),o($V7,[2,5]),o([14,18,21,22,24],[2,1]),o($V7,[2,2]),{3:20,4:$V0,18:[1,17],19:18,20:19},{3:5,4:$V0,5:6,6:$V1,7:3,8:$V2,9:4,10:$V3,11:$V4,13:23,15:7,16:8,17:$V5,23:$V6,24:[1,21],25:22},{1:[2,6]},o($V7,[2,13]),{18:[1,24],22:[1,25]},o($V8,[2,16]),{21:[1,26]},o($V7,[2,18]),{22:[1,28],24:[1,27]},o($V9,[2,20]),o($V7,[2,14]),{3:20,4:$V0,20:29},{3:5,4:$V0,5:6,6:$V1,7:3,8:$V2,9:4,10:$V3,11:$V4,13:30,15:7,16:8,17:$V5,23:$V6},o($V7,[2,19]),{3:5,4:$V0,5:6,6:$V1,7:3,8:$V2,9:4,10:$V3,11:$V4,13:31,15:7,16:8,17:$V5,23:$V6},o($V8,[2,17]),o($V8,[2,15]),o($V9,[2,21])],
defaultActions: {16:[2,6]},
parseError: function parseError(str, hash) {
    if (hash.recoverable) {
        this.trace(str);
    } else {
        throw new Error(str);
    }
},
parse: function parse(input) {
    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
    var args = lstack.slice.call(arguments, 1);
    var lexer = Object.create(this.lexer);
    var sharedState = { yy: {} };
    for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
        }
    }
    lexer.setInput(input, sharedState.yy);
    sharedState.yy.lexer = lexer;
    sharedState.yy.parser = this;
    if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
    }
    var yyloc = lexer.yylloc;
    lstack.push(yyloc);
    var ranges = lexer.options && lexer.options.ranges;
    if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
    } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
    }
    function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }
    _token_stack:
        function lex() {
            var token;
            token = lexer.lex() || EOF;
            if (typeof token !== 'number') {
                token = self.symbols_[token] || token;
            }
            return token;
        }
    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
            }
            action = table[state] && table[state][symbol];
        }
                    if (typeof action === 'undefined' || !action.length || !action[0]) {
                var errStr = '';
                expected = [];
                for (p in table[state]) {
                    if (this.terminals_[p] && p > TERROR) {
                        expected.push('\'' + this.terminals_[p] + '\'');
                    }
                }
                if (lexer.showPosition) {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
                } else {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                }
                this.parseError(errStr, {
                    text: lexer.match,
                    token: this.terminals_[symbol] || symbol,
                    line: lexer.yylineno,
                    loc: yyloc,
                    expected: expected
                });
            }
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }
        switch (action[0]) {
        case 1:
            stack.push(symbol);
            vstack.push(lexer.yytext);
            lstack.push(lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
                if (recovering > 0) {
                    recovering--;
                }
            } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
            }
            break;
        case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
                yyval._$.range = [
                    lstack[lstack.length - (len || 1)].range[0],
                    lstack[lstack.length - 1].range[1]
                ];
            }
            r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
            ].concat(args));
            if (typeof r !== 'undefined') {
                return r;
            }
            if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
        case 3:
            return true;
        }
    }
    return true;
}};
/* generated by jison-lex 0.3.4 */
var lexer = (function(){
var lexer = ({

EOF:1,

parseError:function parseError(str, hash) {
        if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },

// resets the lexer, sets new input
setInput:function (input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
        };
        if (this.options.ranges) {
            this.yylloc.range = [0,0];
        }
        this.offset = 0;
        return this;
    },

// consumes and returns one char from the input
input:function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) {
            this.yylloc.range[1]++;
        }

        this._input = this._input.slice(1);
        return ch;
    },

// unshifts one char (or a string) into the input
unput:function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);

        if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;

        this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
              this.yylloc.first_column - len
        };

        if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
    },

// When called from action, caches matched text and appends it on next action
more:function () {
        this._more = true;
        return this;
    },

// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
reject:function () {
        if (this.options.backtrack_lexer) {
            this._backtrack = true;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });

        }
        return this;
    },

// retain first n characters of the match
less:function (n) {
        this.unput(this.match.slice(n));
    },

// displays already matched input, i.e. for error messages
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },

// displays upcoming input, i.e. for error messages
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
    },

// displays the character position where the lexing error occurred, i.e. for error messages
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
    },

// test the lexed token: return FALSE when not a match, otherwise return token
test_match:function (match, indexed_rule) {
        var token,
            lines,
            backup;

        if (this.options.backtrack_lexer) {
            // save context
            backup = {
                yylineno: this.yylineno,
                yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                matched: this.matched,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                _input: this._input,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
            };
            if (this.options.ranges) {
                backup.yylloc.range = this.yylloc.range.slice(0);
            }
        }

        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno += lines.length;
        }
        this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ?
                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                         this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
            this.done = false;
        }
        if (token) {
            return token;
        } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
                this[k] = backup[k];
            }
            return false; // rule action called reject() implying the next rule should be tested instead.
        }
        return false;
    },

// return next match in input
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) {
            this.done = true;
        }

        var token,
            match,
            tempMatch,
            index;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rules[i]);
                    if (token !== false) {
                        return token;
                    } else if (this._backtrack) {
                        match = false;
                        continue; // rule action called reject() implying a rule MISmatch.
                    } else {
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                } else if (!this.options.flex) {
                    break;
                }
            }
        }
        if (match) {
            token = this.test_match(match, rules[index]);
            if (token !== false) {
                return token;
            }
            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
            return false;
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });
        }
    },

// return next match that has a token
lex:function lex() {
        var r = this.next();
        if (r) {
            return r;
        } else {
            return this.lex();
        }
    },

// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
begin:function begin(condition) {
        this.conditionStack.push(condition);
    },

// pop the previously active lexer condition state off the condition stack
popState:function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
            return this.conditionStack.pop();
        } else {
            return this.conditionStack[0];
        }
    },

// produce the lexer rule set which is active for the currently active lexer condition state
_currentRules:function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
            return this.conditions["INITIAL"].rules;
        }
    },

// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
topState:function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
            return this.conditionStack[n];
        } else {
            return "INITIAL";
        }
    },

// alias for begin(condition)
pushState:function pushState(condition) {
        this.begin(condition);
    },

// return the number of states currently on the stack
stateStackSize:function stateStackSize() {
        return this.conditionStack.length;
    },
options: {},
performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
var YYSTATE=YY_START;
switch($avoiding_name_collisions) {
case 0:/* skip whitespace */
break;
case 1:return 6
break;
case 2:yy_.yytext = yy_.yytext.substr(1,yy_.yyleng-2); return 4
break;
case 3:return 17
break;
case 4:return 18
break;
case 5:return 23
break;
case 6:return 24
break;
case 7:return 22
break;
case 8:return 21
break;
case 9:return 10
break;
case 10:return 11
break;
case 11:return 8
break;
case 12:return 14
break;
case 13:return 'INVALID'
break;
}
},
rules: [/^(?:\s+)/,/^(?:(-?([0-9]|[1-9][0-9]+))(\.[0-9]+)?([eE][-+]?[0-9]+)?\b)/,/^(?:"(?:\\[\\"bfnrt/]|\\u[a-fA-F0-9]{4}|[^\\\0-\x09\x0a-\x1f"])*")/,/^(?:\{)/,/^(?:\})/,/^(?:\[)/,/^(?:\])/,/^(?:,)/,/^(?::)/,/^(?:true\b)/,/^(?:false\b)/,/^(?:null\b)/,/^(?:$)/,/^(?:.)/],
conditions: {"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13],"inclusive":true}}
});
return lexer;
})();
parser.lexer = lexer;
function Parser () {
  this.yy = {};
}
Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();


if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
exports.parser = parser;
exports.Parser = parser.Parser;
exports.parse = function () { return parser.parse.apply(parser, arguments); };
exports.main = function commonjsMain(args) {
    if (!args[1]) {
        console.log('Usage: '+args[0]+' FILE');
        process.exit(1);
    }
    var source = require('fs').readFileSync(require('path').normalize(args[1]), "utf8");
    return exports.parser.parse(source);
};
if (typeof module !== 'undefined' && require.main === module) {
  exports.main(process.argv.slice(1));
}
}
}).call(this,require('_process'))

},{"_process":86,"fs":4,"path":85}],12:[function(require,module,exports){
/**
 * lodash 3.0.7 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var isArray = require('lodash.isarray'),
    isTypedArray = require('lodash.istypedarray'),
    keys = require('lodash.keys');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    stringTag = '[object String]';

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/**
 * A specialized version of `_.some` for arrays without support for callback
 * shorthands and `this` binding.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

/**
 * The base implementation of `_.isEqual` without support for `this` binding
 * `customizer` functions.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {Function} [customizer] The function to customize comparing values.
 * @param {boolean} [isLoose] Specify performing partial comparisons.
 * @param {Array} [stackA] Tracks traversed `value` objects.
 * @param {Array} [stackB] Tracks traversed `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
}

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparing objects.
 * @param {boolean} [isLoose] Specify performing partial comparisons.
 * @param {Array} [stackA=[]] Tracks traversed `value` objects.
 * @param {Array} [stackB=[]] Tracks traversed `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = arrayTag,
      othTag = arrayTag;

  if (!objIsArr) {
    objTag = objToString.call(object);
    if (objTag == argsTag) {
      objTag = objectTag;
    } else if (objTag != objectTag) {
      objIsArr = isTypedArray(object);
    }
  }
  if (!othIsArr) {
    othTag = objToString.call(other);
    if (othTag == argsTag) {
      othTag = objectTag;
    } else if (othTag != objectTag) {
      othIsArr = isTypedArray(other);
    }
  }
  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && !(objIsArr || objIsObj)) {
    return equalByTag(object, other, objTag);
  }
  if (!isLoose) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
    }
  }
  if (!isSameTag) {
    return false;
  }
  // Assume cyclic values are equal.
  // For more information on detecting circular references see https://es5.github.io/#JO.
  stackA || (stackA = []);
  stackB || (stackB = []);

  var length = stackA.length;
  while (length--) {
    if (stackA[length] == object) {
      return stackB[length] == other;
    }
  }
  // Add `object` and `other` to the stack of traversed objects.
  stackA.push(object);
  stackB.push(other);

  var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);

  stackA.pop();
  stackB.pop();

  return result;
}

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparing arrays.
 * @param {boolean} [isLoose] Specify performing partial comparisons.
 * @param {Array} [stackA] Tracks traversed `value` objects.
 * @param {Array} [stackB] Tracks traversed `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
  var index = -1,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
    return false;
  }
  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index],
        result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;

    if (result !== undefined) {
      if (result) {
        continue;
      }
      return false;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (isLoose) {
      if (!arraySome(other, function(othValue) {
            return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
          })) {
        return false;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {
      return false;
    }
  }
  return true;
}

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} value The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag) {
  switch (tag) {
    case boolTag:
    case dateTag:
      // Coerce dates and booleans to numbers, dates to milliseconds and booleans
      // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
      return +object == +other;

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case numberTag:
      // Treat `NaN` vs. `NaN` as equal.
      return (object != +object)
        ? other != +other
        : object == +other;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings primitives and string
      // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
      return object == (other + '');
  }
  return false;
}

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparing values.
 * @param {boolean} [isLoose] Specify performing partial comparisons.
 * @param {Array} [stackA] Tracks traversed `value` objects.
 * @param {Array} [stackB] Tracks traversed `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
  var objProps = keys(object),
      objLength = objProps.length,
      othProps = keys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isLoose) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  var skipCtor = isLoose;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key],
        result = customizer ? customizer(isLoose ? othValue : objValue, isLoose? objValue : othValue, key) : undefined;

    // Recursively compare objects (susceptible to call stack limits).
    if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {
      return false;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (!skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      return false;
    }
  }
  return true;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

module.exports = baseIsEqual;

},{"lodash.isarray":16,"lodash.istypedarray":18,"lodash.keys":19}],13:[function(require,module,exports){
/**
 * lodash 3.0.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * A specialized version of `baseCallback` which only supports `this` binding
 * and specifying the number of arguments to provide to `func`.
 *
 * @private
 * @param {Function} func The function to bind.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {number} [argCount] The number of arguments to provide to `func`.
 * @returns {Function} Returns the callback.
 */
function bindCallback(func, thisArg, argCount) {
  if (typeof func != 'function') {
    return identity;
  }
  if (thisArg === undefined) {
    return func;
  }
  switch (argCount) {
    case 1: return function(value) {
      return func.call(thisArg, value);
    };
    case 3: return function(value, index, collection) {
      return func.call(thisArg, value, index, collection);
    };
    case 4: return function(accumulator, value, index, collection) {
      return func.call(thisArg, accumulator, value, index, collection);
    };
    case 5: return function(value, other, key, object, source) {
      return func.call(thisArg, value, other, key, object, source);
    };
  }
  return function() {
    return func.apply(thisArg, arguments);
  };
}

/**
 * This method returns the first argument provided to it.
 *
 * @static
 * @memberOf _
 * @category Utility
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'user': 'fred' };
 *
 * _.identity(object) === object;
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = bindCallback;

},{}],14:[function(require,module,exports){
/**
 * lodash 3.9.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var funcTag = '[object Function]';

/** Used to detect host constructors (Safari > 5). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var fnToString = Function.prototype.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = object == null ? undefined : object[key];
  return isNative(value) ? value : undefined;
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in older versions of Chrome and Safari which return 'function' for regexes
  // and Safari 8 equivalents which return 'object' for typed array constructors.
  return isObject(value) && objToString.call(value) == funcTag;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is a native function.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
 * @example
 *
 * _.isNative(Array.prototype.push);
 * // => true
 *
 * _.isNative(_);
 * // => false
 */
function isNative(value) {
  if (value == null) {
    return false;
  }
  if (isFunction(value)) {
    return reIsNative.test(fnToString.call(value));
  }
  return isObjectLike(value) && reIsHostCtor.test(value);
}

module.exports = getNative;

},{}],15:[function(require,module,exports){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

module.exports = isArguments;

},{}],16:[function(require,module,exports){
/**
 * lodash 3.0.4 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var arrayTag = '[object Array]',
    funcTag = '[object Function]';

/** Used to detect host constructors (Safari > 5). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var fnToString = Function.prototype.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/* Native method references for those with the same name as other `lodash` methods. */
var nativeIsArray = getNative(Array, 'isArray');

/**
 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = object == null ? undefined : object[key];
  return isNative(value) ? value : undefined;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(function() { return arguments; }());
 * // => false
 */
var isArray = nativeIsArray || function(value) {
  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
};

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in older versions of Chrome and Safari which return 'function' for regexes
  // and Safari 8 equivalents which return 'object' for typed array constructors.
  return isObject(value) && objToString.call(value) == funcTag;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is a native function.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
 * @example
 *
 * _.isNative(Array.prototype.push);
 * // => true
 *
 * _.isNative(_);
 * // => false
 */
function isNative(value) {
  if (value == null) {
    return false;
  }
  if (isFunction(value)) {
    return reIsNative.test(fnToString.call(value));
  }
  return isObjectLike(value) && reIsHostCtor.test(value);
}

module.exports = isArray;

},{}],17:[function(require,module,exports){
/**
 * lodash 3.0.4 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var baseIsEqual = require('lodash._baseisequal'),
    bindCallback = require('lodash._bindcallback');

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent. If `customizer` is provided it is invoked to compare values.
 * If `customizer` returns `undefined` comparisons are handled by the method
 * instead. The `customizer` is bound to `thisArg` and invoked with three
 * arguments: (value, other [, index|key]).
 *
 * **Note:** This method supports comparing arrays, booleans, `Date` objects,
 * numbers, `Object` objects, regexes, and strings. Objects are compared by
 * their own, not inherited, enumerable properties. Functions and DOM nodes
 * are **not** supported. Provide a customizer function to extend support
 * for comparing other values.
 *
 * @static
 * @memberOf _
 * @alias eq
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {Function} [customizer] The function to customize value comparisons.
 * @param {*} [thisArg] The `this` binding of `customizer`.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'user': 'fred' };
 * var other = { 'user': 'fred' };
 *
 * object == other;
 * // => false
 *
 * _.isEqual(object, other);
 * // => true
 *
 * // using a customizer callback
 * var array = ['hello', 'goodbye'];
 * var other = ['hi', 'goodbye'];
 *
 * _.isEqual(array, other, function(value, other) {
 *   if (_.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/)) {
 *     return true;
 *   }
 * });
 * // => true
 */
function isEqual(value, other, customizer, thisArg) {
  customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
  var result = customizer ? customizer(value, other) : undefined;
  return  result === undefined ? baseIsEqual(value, other, customizer) : !!result;
}

module.exports = isEqual;

},{"lodash._baseisequal":12,"lodash._bindcallback":13}],18:[function(require,module,exports){
/**
 * lodash 3.0.6 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length,
 *  else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
function isTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
}

module.exports = isTypedArray;

},{}],19:[function(require,module,exports){
/**
 * lodash 3.1.2 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var getNative = require('lodash._getnative'),
    isArguments = require('lodash.isarguments'),
    isArray = require('lodash.isarray');

/** Used to detect unsigned integer values. */
var reIsUint = /^\d+$/;

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/* Native method references for those with the same name as other `lodash` methods. */
var nativeKeys = getNative(Object, 'keys');

/**
 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
 * that affects Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

/**
 * Checks if `value` is array-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 */
function isArrayLike(value) {
  return value != null && isLength(getLength(value));
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return value > -1 && value % 1 == 0 && value < length;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * A fallback implementation of `Object.keys` which creates an array of the
 * own enumerable property names of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function shimKeys(object) {
  var props = keysIn(object),
      propsLength = props.length,
      length = propsLength && object.length;

  var allowIndexes = !!length && isLength(length) &&
    (isArray(object) || isArguments(object));

  var index = -1,
      result = [];

  while (++index < propsLength) {
    var key = props[index];
    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
var keys = !nativeKeys ? shimKeys : function(object) {
  var Ctor = object == null ? undefined : object.constructor;
  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
      (typeof object != 'function' && isArrayLike(object))) {
    return shimKeys(object);
  }
  return isObject(object) ? nativeKeys(object) : [];
};

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  if (object == null) {
    return [];
  }
  if (!isObject(object)) {
    object = Object(object);
  }
  var length = object.length;
  length = (length && isLength(length) &&
    (isArray(object) || isArguments(object)) && length) || 0;

  var Ctor = object.constructor,
      index = -1,
      isProto = typeof Ctor == 'function' && Ctor.prototype === object,
      result = Array(length),
      skipIndexes = length > 0;

  while (++index < length) {
    result[index] = (index + '');
  }
  for (var key in object) {
    if (!(skipIndexes && isIndex(key, length)) &&
        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = keys;

},{"lodash._getnative":14,"lodash.isarguments":15,"lodash.isarray":16}],20:[function(require,module,exports){

module.exports = function (style) {
    var styleIDs = [];
    var sourceIDs = [];
    var compositedSourceLayers = [];

    for (var id in style.sources) {
        var source = style.sources[id];

        if (source.type !== "vector")
            { continue; }

        var match = /^mapbox:\/\/(.*)/.exec(source.url);
        if (!match)
            { continue; }

        styleIDs.push(id);
        sourceIDs.push(match[1]);
    }

    if (styleIDs.length < 2)
        { return style; }

    styleIDs.forEach(function (id) {
        delete style.sources[id];
    });

    var compositeID = sourceIDs.join(",");

    style.sources[compositeID] = {
        "type": "vector",
        "url": ("mapbox://" + compositeID)
    };

    style.layers.forEach(function (layer) {
        if (styleIDs.indexOf(layer.source) >= 0) {
            layer.source = compositeID;

            if ('source-layer' in layer) {
                if (compositedSourceLayers.indexOf(layer['source-layer']) >= 0) {
                    throw new Error('Conflicting source layer names');
                } else {
                    compositedSourceLayers.push(layer['source-layer']);
                }
            }
        }
    });

    return style;
};

},{}],21:[function(require,module,exports){

var isEqual = require('lodash.isequal');

var operations = {

    /*
     * { command: 'setStyle', args: [stylesheet] }
     */
    setStyle: 'setStyle',

    /*
     * { command: 'addLayer', args: [layer, 'beforeLayerId'] }
     */
    addLayer: 'addLayer',

    /*
     * { command: 'removeLayer', args: ['layerId'] }
     */
    removeLayer: 'removeLayer',

    /*
     * { command: 'setPaintProperty', args: ['layerId', 'prop', value] }
     */
    setPaintProperty: 'setPaintProperty',

    /*
     * { command: 'setLayoutProperty', args: ['layerId', 'prop', value] }
     */
    setLayoutProperty: 'setLayoutProperty',

    /*
     * { command: 'setFilter', args: ['layerId', filter] }
     */
    setFilter: 'setFilter',

    /*
     * { command: 'addSource', args: ['sourceId', source] }
     */
    addSource: 'addSource',

    /*
     * { command: 'removeSource', args: ['sourceId'] }
     */
    removeSource: 'removeSource',

    /*
     * { command: 'setGeoJSONSourceData', args: ['sourceId', data] }
     */
    setGeoJSONSourceData: 'setGeoJSONSourceData',

    /*
     * { command: 'setLayerZoomRange', args: ['layerId', 0, 22] }
     */
    setLayerZoomRange: 'setLayerZoomRange',

    /*
     * { command: 'setLayerProperty', args: ['layerId', 'prop', value] }
     */
    setLayerProperty: 'setLayerProperty',

    /*
     * { command: 'setCenter', args: [[lon, lat]] }
     */
    setCenter: 'setCenter',

    /*
     * { command: 'setZoom', args: [zoom] }
     */
    setZoom: 'setZoom',

    /*
     * { command: 'setBearing', args: [bearing] }
     */
    setBearing: 'setBearing',

    /*
     * { command: 'setPitch', args: [pitch] }
     */
    setPitch: 'setPitch',

    /*
     * { command: 'setSprite', args: ['spriteUrl'] }
     */
    setSprite: 'setSprite',

    /*
     * { command: 'setGlyphs', args: ['glyphsUrl'] }
     */
    setGlyphs: 'setGlyphs',

    /*
     * { command: 'setTransition', args: [transition] }
     */
    setTransition: 'setTransition',

    /*
     * { command: 'setLighting', args: [lightProperties] }
     */
    setLight: 'setLight'

};


function diffSources(before, after, commands, sourcesRemoved) {
    before = before || {};
    after = after || {};

    var sourceId;

    // look for sources to remove
    for (sourceId in before) {
        if (!before.hasOwnProperty(sourceId)) { continue; }
        if (!after.hasOwnProperty(sourceId)) {
            commands.push({ command: operations.removeSource, args: [sourceId] });
            sourcesRemoved[sourceId] = true;
        }
    }

    // look for sources to add/update
    for (sourceId in after) {
        if (!after.hasOwnProperty(sourceId)) { continue; }
        if (!before.hasOwnProperty(sourceId)) {
            commands.push({ command: operations.addSource, args: [sourceId, after[sourceId]] });
        } else if (!isEqual(before[sourceId], after[sourceId])) {
            if (before[sourceId].type === 'geojson' && after[sourceId].type === 'geojson') {
                // geojson sources use setGeoJSONSourceData command to update
                commands.push({ command: operations.setGeoJSONSourceData, args: [sourceId, after[sourceId].data] });
            } else {
                // no update command, must remove then add
                commands.push({ command: operations.removeSource, args: [sourceId] });
                commands.push({ command: operations.addSource, args: [sourceId, after[sourceId]] });
                sourcesRemoved[sourceId] = true;
            }
        }
    }
}

function diffLayerPropertyChanges(before, after, commands, layerId, klass, command) {
    before = before || {};
    after = after || {};

    var prop;

    for (prop in before) {
        if (!before.hasOwnProperty(prop)) { continue; }
        if (!isEqual(before[prop], after[prop])) {
            commands.push({ command: command, args: [layerId, prop, after[prop], klass] });
        }
    }
    for (prop in after) {
        if (!after.hasOwnProperty(prop) || before.hasOwnProperty(prop)) { continue; }
        if (!isEqual(before[prop], after[prop])) {
            commands.push({ command: command, args: [layerId, prop, after[prop], klass] });
        }
    }
}

function pluckId(layer) {
    return layer.id;
}
function indexById(group, layer) {
    group[layer.id] = layer;
    return group;
}

function diffLayers(before, after, commands) {
    before = before || [];
    after = after || [];

    // order of layers by id
    var beforeOrder = before.map(pluckId);
    var afterOrder = after.map(pluckId);

    // index of layer by id
    var beforeIndex = before.reduce(indexById, {});
    var afterIndex = after.reduce(indexById, {});

    // track order of layers as if they have been mutated
    var tracker = beforeOrder.slice();

    // layers that have been added do not need to be diffed
    var clean = Object.create(null);

    var i, d, layerId, beforeLayer, afterLayer, insertBeforeLayerId, prop;

    // remove layers
    for (i = 0, d = 0; i < beforeOrder.length; i++) {
        layerId = beforeOrder[i];
        if (!afterIndex.hasOwnProperty(layerId)) {
            commands.push({ command: operations.removeLayer, args: [layerId] });
            tracker.splice(tracker.indexOf(layerId, d), 1);
        } else {
            // limit where in tracker we need to look for a match
            d++;
        }
    }

    // add/reorder layers
    for (i = 0, d = 0; i < afterOrder.length; i++) {
        // work backwards as insert is before an existing layer
        layerId = afterOrder[afterOrder.length - 1 - i];

        if (tracker[tracker.length - 1 - i] === layerId) { continue; }

        if (beforeIndex.hasOwnProperty(layerId)) {
            // remove the layer before we insert at the correct position
            commands.push({ command: operations.removeLayer, args: [layerId] });
            tracker.splice(tracker.lastIndexOf(layerId, tracker.length - d), 1);
        } else {
            // limit where in tracker we need to look for a match
            d++;
        }

        // add layer at correct position
        insertBeforeLayerId = tracker[tracker.length - i];
        commands.push({ command: operations.addLayer, args: [afterIndex[layerId], insertBeforeLayerId] });
        tracker.splice(tracker.length - i, 0, layerId);
        clean[layerId] = true;
    }

    // update layers
    for (i = 0; i < afterOrder.length; i++) {
        layerId = afterOrder[i];
        beforeLayer = beforeIndex[layerId];
        afterLayer = afterIndex[layerId];

        // no need to update if previously added (new or moved)
        if (clean[layerId] || isEqual(beforeLayer, afterLayer)) { continue; }

        // If source, source-layer, or type have changes, then remove the layer
        // and add it back 'from scratch'.
        if (!isEqual(beforeLayer.source, afterLayer.source) || !isEqual(beforeLayer['source-layer'], afterLayer['source-layer']) || !isEqual(beforeLayer.type, afterLayer.type)) {
            commands.push({ command: operations.removeLayer, args: [layerId] });
            // we add the layer back at the same position it was already in, so
            // there's no need to update the `tracker`
            insertBeforeLayerId = tracker[tracker.lastIndexOf(layerId) + 1];
            commands.push({ command: operations.addLayer, args: [afterLayer, insertBeforeLayerId] });
            continue;
        }

        // layout, paint, filter, minzoom, maxzoom
        diffLayerPropertyChanges(beforeLayer.layout, afterLayer.layout, commands, layerId, null, operations.setLayoutProperty);
        diffLayerPropertyChanges(beforeLayer.paint, afterLayer.paint, commands, layerId, null, operations.setPaintProperty);
        if (!isEqual(beforeLayer.filter, afterLayer.filter)) {
            commands.push({ command: operations.setFilter, args: [layerId, afterLayer.filter] });
        }
        if (!isEqual(beforeLayer.minzoom, afterLayer.minzoom) || !isEqual(beforeLayer.maxzoom, afterLayer.maxzoom)) {
            commands.push({ command: operations.setLayerZoomRange, args: [layerId, afterLayer.minzoom, afterLayer.maxzoom] });
        }

        // handle all other layer props, including paint.*
        for (prop in beforeLayer) {
            if (!beforeLayer.hasOwnProperty(prop)) { continue; }
            if (prop === 'layout' || prop === 'paint' || prop === 'filter' ||
                prop === 'metadata' || prop === 'minzoom' || prop === 'maxzoom') { continue; }
            if (prop.indexOf('paint.') === 0) {
                diffLayerPropertyChanges(beforeLayer[prop], afterLayer[prop], commands, layerId, prop.slice(6), operations.setPaintProperty);
            } else if (!isEqual(beforeLayer[prop], afterLayer[prop])) {
                commands.push({ command: operations.setLayerProperty, args: [layerId, prop, afterLayer[prop]] });
            }
        }
        for (prop in afterLayer) {
            if (!afterLayer.hasOwnProperty(prop) || beforeLayer.hasOwnProperty(prop)) { continue; }
            if (prop === 'layout' || prop === 'paint' || prop === 'filter' ||
                prop === 'metadata' || prop === 'minzoom' || prop === 'maxzoom') { continue; }
            if (prop.indexOf('paint.') === 0) {
                diffLayerPropertyChanges(beforeLayer[prop], afterLayer[prop], commands, layerId, prop.slice(6), operations.setPaintProperty);
            } else if (!isEqual(beforeLayer[prop], afterLayer[prop])) {
                commands.push({ command: operations.setLayerProperty, args: [layerId, prop, afterLayer[prop]] });
            }
        }
    }
}

/**
 * Diff two stylesheet
 *
 * Creates semanticly aware diffs that can easily be applied at runtime.
 * Operations produced by the diff closely resemble the mapbox-gl-js API. Any
 * error creating the diff will fall back to the 'setStyle' operation.
 *
 * Example diff:
 * [
 *     { command: 'setConstant', args: ['@water', '#0000FF'] },
 *     { command: 'setPaintProperty', args: ['background', 'background-color', 'black'] }
 * ]
 *
 * @private
 * @param {*} [before] stylesheet to compare from
 * @param {*} after stylesheet to compare to
 * @returns Array list of changes
 */
function diffStyles(before, after) {
    if (!before) { return [{ command: operations.setStyle, args: [after] }]; }

    var commands = [];

    try {
        // Handle changes to top-level properties
        if (!isEqual(before.version, after.version)) {
            return [{ command: operations.setStyle, args: [after] }];
        }
        if (!isEqual(before.center, after.center)) {
            commands.push({ command: operations.setCenter, args: [after.center] });
        }
        if (!isEqual(before.zoom, after.zoom)) {
            commands.push({ command: operations.setZoom, args: [after.zoom] });
        }
        if (!isEqual(before.bearing, after.bearing)) {
            commands.push({ command: operations.setBearing, args: [after.bearing] });
        }
        if (!isEqual(before.pitch, after.pitch)) {
            commands.push({ command: operations.setPitch, args: [after.pitch] });
        }
        if (!isEqual(before.sprite, after.sprite)) {
            commands.push({ command: operations.setSprite, args: [after.sprite] });
        }
        if (!isEqual(before.glyphs, after.glyphs)) {
            commands.push({ command: operations.setGlyphs, args: [after.glyphs] });
        }
        if (!isEqual(before.transition, after.transition)) {
            commands.push({ command: operations.setTransition, args: [after.transition] });
        }
        if (!isEqual(before.light, after.light)) {
            commands.push({ command: operations.setLight, args: [after.light] });
        }

        // Handle changes to `sources`
        // If a source is to be removed, we also--before the removeSource
        // command--need to remove all the style layers that depend on it.
        var sourcesRemoved = {};

        // First collect the {add,remove}Source commands
        var removeOrAddSourceCommands = [];
        diffSources(before.sources, after.sources, removeOrAddSourceCommands, sourcesRemoved);

        // Push a removeLayer command for each style layer that depends on a
        // source that's being removed.
        // Also, exclude any such layers them from the input to `diffLayers`
        // below, so that diffLayers produces the appropriate `addLayers`
        // command
        var beforeLayers = [];
        if (before.layers) {
            before.layers.forEach(function (layer) {
                if (sourcesRemoved[layer.source]) {
                    commands.push({ command: operations.removeLayer, args: [layer.id] });
                } else {
                    beforeLayers.push(layer);
                }
            });
        }
        commands = commands.concat(removeOrAddSourceCommands);

        // Handle changes to `layers`
        diffLayers(beforeLayers, after.layers, commands);

    } catch (e) {
        // fall back to setStyle
        console.warn('Unable to compute style diff:', e);
        commands = [{ command: operations.setStyle, args: [after] }];
    }

    return commands;
}

module.exports = diffStyles;
module.exports.operations = operations;

},{"lodash.isequal":17}],22:[function(require,module,exports){

function ParsingError(error) {
    this.error = error;
    this.message = error.message;
    var match = error.message.match(/line (\d+)/);
    this.line = match ? parseInt(match[1], 10) : 0;
}

module.exports = ParsingError;

},{}],23:[function(require,module,exports){

var format = require('util').format;

function ValidationError(key, value) {
    var args = [], len = arguments.length - 2;
    while ( len-- > 0 ) args[ len ] = arguments[ len + 2 ];

    this.message = (key ? (key + ": ") : '') + format.apply(format, args);

    if (value !== null && value !== undefined && value.__line__) {
        this.line = value.__line__;
    }
}

module.exports = ValidationError;

},{"util":98}],24:[function(require,module,exports){
//      

var ref = require('./types');
var toString = ref.toString;
var ParsingContext = require('./parsing_context');
var EvaluationContext = require('./evaluation_context');
var assert = require('assert');

                                               
                                    
                                      

                                
                                       
                                                                
                                               
                                                            

var CompoundExpression = function CompoundExpression(key    , name    , type  , evaluate      , args               ) {
    this.key = key;
    this.name = name;
    this.type = type;
    this._evaluate = evaluate;
    this.args = args;
};

CompoundExpression.prototype.evaluate = function evaluate (ctx               ) {
    return this._evaluate(ctx, this.args);
};

CompoundExpression.prototype.eachChild = function eachChild (fn                  ) {
    this.args.forEach(fn);
};

CompoundExpression.parse = function parse (args          , context            )          {
    var op     = (args[0] );
    var definition = CompoundExpression.definitions[op];
    if (!definition) {
        return context.error(("Unknown expression \"" + op + "\". If you wanted a literal array, use [\"literal\", [...]]."), 0);
    }

    // Now check argument types against each signature
    var type = Array.isArray(definition) ?
        definition[0] : definition.type;

    var overloads = Array.isArray(definition) ?
        [[definition[1], definition[2]]] :
        definition.overloads.filter(function (overload) { return (
            !Array.isArray(overload[0][0]) || // varags
            overload[0][0].length === args.length - 1 // correct param count
        ); });

    // First parse all the args
    var parsedArgs                = [];
    for (var i = 1; i < args.length; i++) {
        var arg = args[i];
        var expected = (void 0);
        if (overloads.length === 1) {
            var params = overloads[0][0];
            expected = Array.isArray(params) ?
                params[i - 1] :
                params.type;
        }
        var parsed = context.parse(arg, 1 + parsedArgs.length, expected);
        if (!parsed) { return null; }
        parsedArgs.push(parsed);
    }

    var signatureContext             = (null );

    for (var i$2 = 0, list = overloads; i$2 < list.length; i$2 += 1) {
        // Use a fresh context for each attempted signature so that, if
        // we eventually succeed, we haven't polluted `context.errors`.
        var ref = list[i$2];
            var params$1 = ref[0];
            var evaluate = ref[1];

            signatureContext = new ParsingContext(context.definitions, context.path, null, context.scope);

        if (Array.isArray(params$1)) {
            if (params$1.length !== parsedArgs.length) {
                signatureContext.error(("Expected " + (params$1.length) + " arguments, but found " + (parsedArgs.length) + " instead."));
                continue;
            }
        }

        for (var i$1 = 0; i$1 < parsedArgs.length; i$1++) {
            var expected$1 = Array.isArray(params$1) ? params$1[i$1] : params$1.type;
            var arg$1 = parsedArgs[i$1];
            signatureContext.concat(i$1 + 1).checkSubtype(expected$1, arg$1.type);
        }

        if (signatureContext.errors.length === 0) {
            return new CompoundExpression(context.key, op, type, evaluate, parsedArgs);
        }
    }

    assert(signatureContext.errors.length > 0);

    if (overloads.length === 1) {
        context.errors.push.apply(context.errors, signatureContext.errors);
    } else {
        var signatures = overloads
            .map(function (ref) {
                    var params = ref[0];

                    return stringifySignature(params);
            })
            .join(' | ');
        var actualTypes = parsedArgs
            .map(function (arg) { return toString(arg.type); })
            .join(', ');
        context.error(("Expected arguments of type " + signatures + ", but found (" + actualTypes + ") instead."));
    }

    return null;
};

CompoundExpression.register = function register (
    expressions                             ,
    definitions                          
) {
    assert(!CompoundExpression.definitions);
    CompoundExpression.definitions = definitions;
    for (var name in definitions) {
        expressions[name] = CompoundExpression;
    }
};

function varargs(type      )          {
    return { type: type };
}

function stringifySignature(signature           )         {
    if (Array.isArray(signature)) {
        return ("(" + (signature.map(toString).join(', ')) + ")");
    } else {
        return ("(" + (toString(signature.type)) + "...)");
    }
}

module.exports = {
    CompoundExpression: CompoundExpression,
    varargs: varargs
};

},{"./evaluation_context":37,"./parsing_context":40,"./types":44,"assert":3}],25:[function(require,module,exports){
//      

var ref = require('../types');
var toString = ref.toString;
var array = ref.array;
var ValueType = ref.ValueType;
var StringType = ref.StringType;
var NumberType = ref.NumberType;
var BooleanType = ref.BooleanType;
var checkSubtype = ref.checkSubtype;

var ref$1 = require('../values');
var typeOf = ref$1.typeOf;
var RuntimeError = require('../runtime_error');

                                                
                                                     
                                                           
                                          

var types = {
    string: StringType,
    number: NumberType,
    boolean: BooleanType
};

var ArrayAssertion = function ArrayAssertion(key    , type       , input        ) {
    this.key = key;
    this.type = type;
    this.input = input;
};

ArrayAssertion.parse = function parse (args          , context            )          {
    if (args.length < 2 || args.length > 4)
        { return context.error(("Expected 1, 2, or 3 arguments, but found " + (args.length - 1) + " instead.")); }

    var itemType;
    var N;
    if (args.length > 2) {
        var type$1 = args[1];
        if (typeof type$1 !== 'string' || !(type$1 in types))
            { return context.error('The item type argument of "array" must be one of string, number, boolean', 1); }
        itemType = types[type$1];
    } else {
        itemType = ValueType;
    }

    if (args.length > 3) {
        if (
            typeof args[2] !== 'number' ||
            args[2] < 0 ||
            args[2] !== Math.floor(args[2])
        ) {
            return context.error('The length argument to "array" must be a positive integer literal', 2);
        }
        N = args[2];
    }

    var type = array(itemType, N);

    var input = context.parse(args[args.length - 1], args.length - 1, ValueType);
    if (!input) { return null; }

    return new ArrayAssertion(context.key, type, input);
};

ArrayAssertion.prototype.evaluate = function evaluate (ctx               ) {
    var value = this.input.evaluate(ctx);
    var error = checkSubtype(this.type, typeOf(value));
    if (error) {
        throw new RuntimeError(("Expected value to be of type " + (toString(this.type)) + ", but found " + (toString(typeOf(value))) + " instead."));
    }
    return value;
};

ArrayAssertion.prototype.eachChild = function eachChild (fn                  ) {
    fn(this.input);
};

module.exports = ArrayAssertion;

},{"../runtime_error":42,"../types":44,"../values":45}],26:[function(require,module,exports){
//      

var assert = require('assert');
var ref = require('../types');
var ObjectType = ref.ObjectType;
var ValueType = ref.ValueType;
var StringType = ref.StringType;
var NumberType = ref.NumberType;
var BooleanType = ref.BooleanType;

var RuntimeError = require('../runtime_error');
var ref$1 = require('../types');
var checkSubtype = ref$1.checkSubtype;
var toString = ref$1.toString;
var ref$2 = require('../values');
var typeOf = ref$2.typeOf;

                                                
                                                     
                                                           
                                     

var types = {
    string: StringType,
    number: NumberType,
    boolean: BooleanType,
    object: ObjectType
};

var Assertion = function Assertion(key    , type  , args               ) {
    this.key = key;
    this.type = type;
    this.args = args;
};

Assertion.parse = function parse (args          , context            )          {
    if (args.length < 2)
        { return context.error("Expected at least one argument."); }

    var name     = (args[0] );
    assert(types[name], name);

    var type = types[name];

    var parsed = [];
    for (var i = 1; i < args.length; i++) {
        var input = context.parse(args[i], i, ValueType);
        if (!input) { return null; }
        parsed.push(input);
    }

    return new Assertion(context.key, type, parsed);
};

Assertion.prototype.evaluate = function evaluate (ctx               ) {
        var this$1 = this;

    for (var i = 0; i < this.args.length; i++) {
        var value = this$1.args[i].evaluate(ctx);
        var error = checkSubtype(this$1.type, typeOf(value));
        if (!error) {
            return value;
        } else if (i === this$1.args.length - 1) {
            throw new RuntimeError(("Expected value to be of type " + (toString(this$1.type)) + ", but found " + (toString(typeOf(value))) + " instead."));
        }
    }

    assert(false);
    return null;
};

Assertion.prototype.eachChild = function eachChild (fn                  ) {
    this.args.forEach(fn);
};

module.exports = Assertion;

},{"../runtime_error":42,"../types":44,"../values":45,"assert":3}],27:[function(require,module,exports){
//      

var ref = require('../types');
var array = ref.array;
var ValueType = ref.ValueType;
var NumberType = ref.NumberType;

var RuntimeError = require('../runtime_error');

                                                
                                                     
                                                           
                                                
                                       

var At = function At(key    , type  , index        , input        ) {
    this.key = key;
    this.type = type;
    this.index = index;
    this.input = input;
};

At.parse = function parse (args          , context            ) {
    if (args.length !== 3)
        { return context.error(("Expected 2 arguments, but found " + (args.length - 1) + " instead.")); }

    var index = context.parse(args[1], 1, NumberType);
    var input = context.parse(args[2], 2, array(context.expectedType || ValueType));

    if (!index || !input) { return null; }

    var t        = (input.type );
    return new At(context.key, t.itemType, index, input);
};

At.prototype.evaluate = function evaluate (ctx               ) {
    var index = ((this.index.evaluate(ctx) )    );
    var array = ((this.input.evaluate(ctx) )          );

    if (index < 0 || index >= array.length) {
        throw new RuntimeError(("Array index out of bounds: " + index + " > " + (array.length) + "."));
    }

    if (index !== Math.floor(index)) {
        throw new RuntimeError(("Array index must be an integer, but found " + index + " instead."));
    }

    return array[index];
};

At.prototype.eachChild = function eachChild (fn                  ) {
    fn(this.index);
    fn(this.input);
};

module.exports = At;

},{"../runtime_error":42,"../types":44}],28:[function(require,module,exports){
//      

var assert = require('assert');
var ref = require('../types');
var BooleanType = ref.BooleanType;

                                                
                                                     
                                                           
                                     

                                                

var Case = function Case(key    , type  , branches      , otherwise        ) {
    this.key = key;
    this.type = type;
    this.branches = branches;
    this.otherwise = otherwise;
};

Case.parse = function parse (args          , context            ) {
    if (args.length < 4)
        { return context.error(("Expected at least 3 arguments, but found only " + (args.length - 1) + ".")); }
    if (args.length % 2 !== 0)
        { return context.error("Expected an odd number of arguments."); }

    var outputType   ;
    if (context.expectedType && context.expectedType.kind !== 'value') {
        outputType = context.expectedType;
    }

    var branches = [];
    for (var i = 1; i < args.length - 1; i += 2) {
        var test = context.parse(args[i], i, BooleanType);
        if (!test) { return null; }

        var result = context.parse(args[i + 1], i + 1, outputType);
        if (!result) { return null; }

        branches.push([test, result]);

        outputType = outputType || result.type;
    }

    var otherwise = context.parse(args[args.length - 1], args.length - 1, outputType);
    if (!otherwise) { return null; }

    assert(outputType);
    return new Case(context.key, (outputType ), branches, otherwise);
};

Case.prototype.evaluate = function evaluate (ctx               ) {
        var this$1 = this;

    for (var i = 0, list = this$1.branches; i < list.length; i += 1) {
        var ref = list[i];
            var test = ref[0];
            var expression = ref[1];

            if (test.evaluate(ctx)) {
            return expression.evaluate(ctx);
        }
    }
    return this.otherwise.evaluate(ctx);
};

Case.prototype.eachChild = function eachChild (fn                  ) {
        var this$1 = this;

    for (var i = 0, list = this$1.branches; i < list.length; i += 1) {
        var ref = list[i];
            var test = ref[0];
            var expression = ref[1];

            fn(test);
        fn(expression);
    }
    fn(this.otherwise);
};

module.exports = Case;

},{"../types":44,"assert":3}],29:[function(require,module,exports){
//      

var assert = require('assert');

                                                
                                                     
                                                           
                                     

var Coalesce = function Coalesce(key    , type  , args               ) {
    this.key = key;
    this.type = type;
    this.args = args;
};

Coalesce.parse = function parse (args          , context            ) {
    if (args.length < 2) {
        return context.error("Expectected at least one argument.");
    }
    var outputType   = (null );
    if (context.expectedType && context.expectedType.kind !== 'value') {
        outputType = context.expectedType;
    }
    var parsedArgs = [];
    for (var i = 0, list = args.slice(1); i < list.length; i += 1) {
        var arg = list[i];

            var parsed = context.parse(arg, 1 + parsedArgs.length, outputType);
        if (!parsed) { return null; }
        outputType = outputType || parsed.type;
        parsedArgs.push(parsed);
    }
    assert(outputType);
    return new Coalesce(context.key, (outputType ), parsedArgs);
};

Coalesce.prototype.evaluate = function evaluate (ctx               ) {
        var this$1 = this;

    var result = null;
    for (var i = 0, list = this$1.args; i < list.length; i += 1) {
        var arg = list[i];

            result = arg.evaluate(ctx);
        if (result !== null) { break; }
    }
    return result;
};

Coalesce.prototype.eachChild = function eachChild (fn                  ) {
    this.args.forEach(fn);
};

module.exports = Coalesce;

},{"assert":3}],30:[function(require,module,exports){
//      

var assert = require('assert');
var ref = require('../types');
var ColorType = ref.ColorType;
var ValueType = ref.ValueType;
var NumberType = ref.NumberType;

var ref$1 = require('../values');
var Color = ref$1.Color;
var validateRGBA = ref$1.validateRGBA;
var unwrap = ref$1.unwrap;
var RuntimeError = require('../runtime_error');

                                                
                                                     
                                                           
                                     

var types = {
    'to-number': NumberType,
    'to-color': ColorType
};

/**
 * Special form for error-coalescing coercion expressions "to-number",
 * "to-color".  Since these coercions can fail at runtime, they accept multiple
 * arguments, only evaluating one at a time until one succeeds.
 *
 * @private
 */
var Coercion = function Coercion(key    , type  , args               ) {
    this.key = key;
    this.type = type;
    this.args = args;
};

Coercion.parse = function parse (args          , context            )          {
    if (args.length < 2)
        { return context.error("Expected at least one argument."); }

    var name     = (args[0] );
    assert(types[name], name);

    var type = types[name];

    var parsed = [];
    for (var i = 1; i < args.length; i++) {
        var input = context.parse(args[i], i, ValueType);
        if (!input) { return null; }
        parsed.push(input);
    }

    return new Coercion(context.key, type, parsed);
};

Coercion.prototype.evaluate = function evaluate (ctx               ) {
        var this$1 = this;

    if (this.type.kind === 'color') {
        var input;
        var error;
        for (var i = 0, list = this$1.args; i < list.length; i += 1) {
            var arg = list[i];

                input = arg.evaluate(ctx);
            error = null;
            if (typeof input === 'string') {
                var c = ctx.parseColor(input);
                if (c) { return c; }
            } else if (Array.isArray(input)) {
                if (input.length < 3 || input.length > 4) {
                    error = "Invalid rbga value " + (JSON.stringify(input)) + ": expected an array containing either three or four numeric values.";
                } else {
                    error = validateRGBA(input[0], input[1], input[2], input[3]);
                }
                if (!error) {
                    return new Color((input[0] ) / 255, (input[1] ) / 255, (input[2] ) / 255, (input[3] ));
                }
            }
        }
        throw new RuntimeError(error || ("Could not parse color from value '" + (typeof input === 'string' ? input : JSON.stringify(input)) + "'"));
    } else {
        var value = null;
        for (var i$1 = 0, list$1 = this$1.args; i$1 < list$1.length; i$1 += 1) {
            var arg$1 = list$1[i$1];

                value = arg$1.evaluate(ctx);
            if (value === null) { continue; }
            var num = Number(value);
            if (isNaN(num)) { continue; }
            return num;
        }
        throw new RuntimeError(("Could not convert " + (JSON.stringify(unwrap(value))) + " to number."));
    }
};

Coercion.prototype.eachChild = function eachChild (fn                  ) {
    this.args.forEach(fn);
};

module.exports = Coercion;

},{"../runtime_error":42,"../types":44,"../values":45,"assert":3}],31:[function(require,module,exports){
//      

var UnitBezier = require('@mapbox/unitbezier');
var interpolate = require('../../util/interpolate');
var ref = require('../types');
var toString = ref.toString;
var NumberType = ref.NumberType;
var ref$1 = require('../values');
var Color = ref$1.Color;

                                                
                                                     
                                                           
                                     

                               
                      
                        
                                           
                                                                              

                                         

var Curve = function Curve(key    , type  , interpolation               , input        , stops   ) {
    var this$1 = this;

    this.key = key;
    this.type = type;
    this.interpolation = interpolation;
    this.input = input;

    this.labels = [];
    this.outputs = [];
    for (var i = 0, list = stops; i < list.length; i += 1) {
        var ref = list[i];
        var label = ref[0];
        var expression = ref[1];

        this$1.labels.push(label);
        this$1.outputs.push(expression);
    }
};

Curve.interpolationFactor = function interpolationFactor (interpolation               , input    , lower    , upper    ) {
    var t = 0;
    if (interpolation.name === 'exponential') {
        t = exponentialInterpolation(input, interpolation.base, lower, upper);
    } else if (interpolation.name === 'linear') {
        t = exponentialInterpolation(input, 1, lower, upper);
    } else if (interpolation.name === 'cubic-bezier') {
        var c = interpolation.controlPoints;
        var ub = new UnitBezier(c[0], c[1], c[2], c[3]);
        t = ub.solve(exponentialInterpolation(input, 1, lower, upper));
    }
    return t;
};

Curve.parse = function parse (args          , context            ) {
    var interpolation = args[1];
        var input = args[2];
        var rest = args.slice(3);

    if (!Array.isArray(interpolation) || interpolation.length === 0) {
        return context.error("Expected an interpolation type expression.", 1);
    }

    if (interpolation[0] === 'step') {
        interpolation = { name: 'step' };
    } else if (interpolation[0] === 'linear') {
        interpolation = { name: 'linear' };
    } else if (interpolation[0] === 'exponential') {
        var base = interpolation[1];
        if (typeof base !== 'number')
            { return context.error("Exponential interpolation requires a numeric base.", 1, 1); }
        interpolation = {
            name: 'exponential',
            base: base
        };
    } else if (interpolation[0] === 'cubic-bezier') {
        var controlPoints = interpolation.slice(1);
        if (
            controlPoints.length !== 4 ||
            controlPoints.some(function (t) { return typeof t !== 'number' || t < 0 || t > 1; })
        ) {
            return context.error('Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.', 1);
        }

        interpolation = {
            name: 'cubic-bezier',
            controlPoints: (controlPoints )
        };
    } else {
        return context.error(("Unknown interpolation type " + (String(interpolation[0]))), 1, 0);
    }

    var isStep = interpolation.name === 'step';

    var minArgs = isStep ? 5 : 4;
    if (args.length - 1 < minArgs)
        { return context.error(("Expected at least " + minArgs + " arguments, but found only " + (args.length - 1) + ".")); }

    var parity = minArgs % 2;
    if ((args.length - 1) % 2 !== parity) {
        return context.error(("Expected an " + (parity === 0 ? 'even' : 'odd') + " number of arguments."));
    }

    input = context.parse(input, 2, NumberType);
    if (!input) { return null; }

    var stops    = [];

    var outputType   = (null );
    if (context.expectedType && context.expectedType.kind !== 'value') {
        outputType = context.expectedType;
    }

    if (isStep) {
        rest.unshift(-Infinity);
    }

    for (var i = 0; i < rest.length; i += 2) {
        var label = rest[i];
        var value = rest[i + 1];

        var labelKey = isStep ? i + 2 : i + 3;
        var valueKey = isStep ? i + 3 : i + 4;

        if (typeof label !== 'number') {
            return context.error('Input/output pairs for "curve" expressions must be defined using literal numeric values (not computed expressions) for the input values.', labelKey);
        }

        if (stops.length && stops[stops.length - 1][0] > label) {
            return context.error('Input/output pairs for "curve" expressions must be arranged with input values in strictly ascending order.', labelKey);
        }

        var parsed = context.parse(value, valueKey, outputType);
        if (!parsed) { return null; }
        outputType = outputType || parsed.type;
        stops.push([label, parsed]);
    }

    if (interpolation.name !== 'step' &&
        outputType.kind !== 'number' &&
        outputType.kind !== 'color' &&
        !(outputType.kind === 'array' && outputType.itemType.kind === 'number')) {
        return context.error(("Type " + (toString(outputType)) + " is not interpolatable, and thus cannot be used as a " + (interpolation.name) + " curve's output type."));
    }

    return new Curve(context.key, outputType, interpolation, input, stops);
};

Curve.prototype.evaluate = function evaluate (ctx               ) {
    var labels = this.labels;
    var outputs = this.outputs;

    if (labels.length === 1) {
        return outputs[0].evaluate(ctx);
    }

    var value = ((this.input.evaluate(ctx) )    );
    if (value <= labels[0]) {
        return outputs[0].evaluate(ctx);
    }

    var stopCount = labels.length;
    if (value >= labels[stopCount - 1]) {
        return outputs[stopCount - 1].evaluate(ctx);
    }

    var index = findStopLessThanOrEqualTo(labels, value);
    if (this.interpolation.name === 'step') {
        return outputs[index].evaluate(ctx);
    }

    var lower = labels[index];
    var upper = labels[index + 1];
    var t = Curve.interpolationFactor(this.interpolation, value, lower, upper);

    var outputLower = outputs[index].evaluate(ctx);
    var outputUpper = outputs[index + 1].evaluate(ctx);

    var type = this.type.kind.toLowerCase();
    if (type === 'color') {
        return new (Function.prototype.bind.apply( Color, [ null ].concat( interpolate.color((outputLower ).value, (outputUpper ).value, t)) ));
    }

    return interpolate[type](outputLower, outputUpper, t);
};

Curve.prototype.eachChild = function eachChild (fn                  ) {
        var this$1 = this;

    fn(this.input);
    for (var i = 0, list = this$1.outputs; i < list.length; i += 1) {
        var expression = list[i];

            fn(expression);
    }
};

/**
 * Returns a ratio that can be used to interpolate between exponential function
 * stops.
 * How it works: Two consecutive stop values define a (scaled and shifted) exponential function `f(x) = a * base^x + b`, where `base` is the user-specified base,
 * and `a` and `b` are constants affording sufficient degrees of freedom to fit
 * the function to the given stops.
 *
 * Here's a bit of algebra that lets us compute `f(x)` directly from the stop
 * values without explicitly solving for `a` and `b`:
 *
 * First stop value: `f(x0) = y0 = a * base^x0 + b`
 * Second stop value: `f(x1) = y1 = a * base^x1 + b`
 * => `y1 - y0 = a(base^x1 - base^x0)`
 * => `a = (y1 - y0)/(base^x1 - base^x0)`
 *
 * Desired value: `f(x) = y = a * base^x + b`
 * => `f(x) = y0 + a * (base^x - base^x0)`
 *
 * From the above, we can replace the `a` in `a * (base^x - base^x0)` and do a
 * little algebra:
 * ```
 * a * (base^x - base^x0) = (y1 - y0)/(base^x1 - base^x0) * (base^x - base^x0)
 *                     = (y1 - y0) * (base^x - base^x0) / (base^x1 - base^x0)
 * ```
 *
 * If we let `(base^x - base^x0) / (base^x1 base^x0)`, then we have
 * `f(x) = y0 + (y1 - y0) * ratio`.  In other words, `ratio` may be treated as
 * an interpolation factor between the two stops' output values.
 *
 * (Note: a slightly different form for `ratio`,
 * `(base^(x-x0) - 1) / (base^(x1-x0) - 1) `, is equivalent, but requires fewer
 * expensive `Math.pow()` operations.)
 *
 * @private
*/
function exponentialInterpolation(input, base, lowerValue, upperValue) {
    var difference = upperValue - lowerValue;
    var progress = input - lowerValue;

    if (difference === 0) {
        return 0;
    } else if (base === 1) {
        return progress / difference;
    } else {
        return (Math.pow(base, progress) - 1) / (Math.pow(base, difference) - 1);
    }
}

module.exports = Curve;

/**
 * Returns the index of the last stop <= input, or 0 if it doesn't exist.
 * @private
 */
function findStopLessThanOrEqualTo(stops, input) {
    var n = stops.length;
    var lowerIndex = 0;
    var upperIndex = n - 1;
    var currentIndex = 0;
    var currentValue, upperValue;

    while (lowerIndex <= upperIndex) {
        currentIndex = Math.floor((lowerIndex + upperIndex) / 2);
        currentValue = stops[currentIndex];
        upperValue = stops[currentIndex + 1];
        if (input === currentValue || input > currentValue && input < upperValue) { // Search complete
            return currentIndex;
        } else if (currentValue < input) {
            lowerIndex = currentIndex + 1;
        } else if (currentValue > input) {
            upperIndex = currentIndex - 1;
        }
    }

    return Math.max(currentIndex - 1, 0);
}

},{"../../util/interpolate":61,"../types":44,"../values":45,"@mapbox/unitbezier":2}],32:[function(require,module,exports){
//      

var ref = require('../types');
var NullType = ref.NullType;
var NumberType = ref.NumberType;
var StringType = ref.StringType;
var BooleanType = ref.BooleanType;
var ColorType = ref.ColorType;
var ObjectType = ref.ObjectType;
var ValueType = ref.ValueType;
var ErrorType = ref.ErrorType;
var array = ref.array;
var toString = ref.toString;

var ref$1 = require('../values');
var typeOf = ref$1.typeOf;
var Color = ref$1.Color;
var validateRGBA = ref$1.validateRGBA;
var ref$2 = require('../compound_expression');
var CompoundExpression = ref$2.CompoundExpression;
var varargs = ref$2.varargs;
var RuntimeError = require('../runtime_error');
var Let = require('./let');
var Var = require('./var');
var Literal = require('./literal');
var Assertion = require('./assertion');
var ArrayAssertion = require('./array');
var Coercion = require('./coercion');
var At = require('./at');
var Match = require('./match');
var Case = require('./case');
var Curve = require('./curve');
var Coalesce = require('./coalesce');

                                                

var expressions                                  = {
    // special forms
    'let': Let,
    'var': Var,
    'literal': Literal,
    'string': Assertion,
    'number': Assertion,
    'boolean': Assertion,
    'object': Assertion,
    'array': ArrayAssertion,
    'to-number': Coercion,
    'to-color': Coercion,
    'at': At,
    'case': Case,
    'match': Match,
    'coalesce': Coalesce,
    'curve': Curve,
};

function rgba(ctx, ref) {
    var r = ref[0];
    var g = ref[1];
    var b = ref[2];
    var a = ref[3];

    r = r.evaluate(ctx);
    g = g.evaluate(ctx);
    b = b.evaluate(ctx);
    a = a && a.evaluate(ctx);
    var error = validateRGBA(r, g, b, a);
    if (error) { throw new RuntimeError(error); }
    return new Color(r / 255, g / 255, b / 255, a);
}

function has(key, obj) {
    return key in obj;
}

function get(key, obj) {
    var v = obj[key];
    return typeof v === 'undefined' ? null : v;
}

function length(ctx, ref) {
    var v = ref[0];

    return v.evaluate(ctx).length;
}

function eq(ctx, ref) {
var a = ref[0];
var b = ref[1];
 return a.evaluate(ctx) === b.evaluate(ctx); }
function ne(ctx, ref) {
var a = ref[0];
var b = ref[1];
 return a.evaluate(ctx) !== b.evaluate(ctx); }
function lt(ctx, ref) {
var a = ref[0];
var b = ref[1];
 return a.evaluate(ctx) < b.evaluate(ctx); }
function gt(ctx, ref) {
var a = ref[0];
var b = ref[1];
 return a.evaluate(ctx) > b.evaluate(ctx); }
function lteq(ctx, ref) {
var a = ref[0];
var b = ref[1];
 return a.evaluate(ctx) <= b.evaluate(ctx); }
function gteq(ctx, ref) {
var a = ref[0];
var b = ref[1];
 return a.evaluate(ctx) >= b.evaluate(ctx); }

CompoundExpression.register(expressions, {
    'error': [
        ErrorType,
        [StringType],
        function (ctx, ref) {
        var v = ref[0];
 throw new RuntimeError(v.evaluate(ctx)); }
    ],
    'typeof': [
        StringType,
        [ValueType],
        function (ctx, ref) {
            var v = ref[0];

            return toString(typeOf(v.evaluate(ctx)));
}
    ],
    'to-string': [
        StringType,
        [ValueType],
        function (ctx, ref) {
            var v = ref[0];

            v = v.evaluate(ctx);
            var type = typeof v;
            if (v === null || type === 'string' || type === 'number' || type === 'boolean') {
                return String(v);
            } else if (v instanceof Color) {
                var ref$1 = v.value;
                var r = ref$1[0];
                var g = ref$1[1];
                var b = ref$1[2];
                var a = ref$1[3];
                return ("rgba(" + (r * 255) + ", " + (g * 255) + ", " + (b * 255) + ", " + a + ")");
            } else {
                return JSON.stringify(v);
            }
        }
    ],
    'to-boolean': [
        BooleanType,
        [ValueType],
        function (ctx, ref) {
            var v = ref[0];

            return Boolean(v.evaluate(ctx));
}
    ],
    'to-rgba': [
        array(NumberType, 4),
        [ColorType],
        function (ctx, ref) {
            var v = ref[0];

            return v.evaluate(ctx).value;
}
    ],
    'rgb': [
        ColorType,
        [NumberType, NumberType, NumberType],
        rgba
    ],
    'rgba': [
        ColorType,
        [NumberType, NumberType, NumberType, NumberType],
        rgba
    ],
    'length': {
        type: NumberType,
        overloads: [
            [
                [StringType],
                length
            ], [
                [array(ValueType)],
                length
            ]
        ]
    },
    'has': {
        type: BooleanType,
        overloads: [
            [
                [StringType],
                function (ctx, ref) {
                    var key = ref[0];

                    return has(key.evaluate(ctx), ctx.properties());
}
            ], [
                [StringType, ObjectType],
                function (ctx, ref) {
                    var key = ref[0];
                    var obj = ref[1];

                    return has(key.evaluate(ctx), obj.evaluate(ctx));
}
            ]
        ]
    },
    'get': {
        type: ValueType,
        overloads: [
            [
                [StringType],
                function (ctx, ref) {
                    var key = ref[0];

                    return get(key.evaluate(ctx), ctx.properties());
}
            ], [
                [StringType, ObjectType],
                function (ctx, ref) {
                    var key = ref[0];
                    var obj = ref[1];

                    return get(key.evaluate(ctx), obj.evaluate(ctx));
}
            ]
        ]
    },
    'properties': [
        ObjectType,
        [],
        function (ctx) { return ctx.properties(); }
    ],
    'geometry-type': [
        StringType,
        [],
        function (ctx) { return ctx.geometryType(); }
    ],
    'id': [
        ValueType,
        [],
        function (ctx) { return ctx.id(); }
    ],
    'zoom': [
        NumberType,
        [],
        function (ctx) { return ctx.globals.zoom; }
    ],
    'heatmap-density': [
        NumberType,
        [],
        function (ctx) { return ctx.globals.heatmapDensity || 0; }
    ],
    '+': [
        NumberType,
        varargs(NumberType),
        function (ctx, args) {
            var result = 0;
            for (var i = 0, list = args; i < list.length; i += 1) {
                var arg = list[i];

                result += arg.evaluate(ctx);
            }
            return result;
        }
    ],
    '*': [
        NumberType,
        varargs(NumberType),
        function (ctx, args) {
            var result = 1;
            for (var i = 0, list = args; i < list.length; i += 1) {
                var arg = list[i];

                result *= arg.evaluate(ctx);
            }
            return result;
        }
    ],
    '-': {
        type: NumberType,
        overloads: [
            [
                [NumberType, NumberType],
                function (ctx, ref) {
                    var a = ref[0];
                    var b = ref[1];

                    return a.evaluate(ctx) - b.evaluate(ctx);
}
            ], [
                [NumberType],
                function (ctx, ref) {
                    var a = ref[0];

                    return -a.evaluate(ctx);
}
            ]
        ]
    },
    '/': [
        NumberType,
        [NumberType, NumberType],
        function (ctx, ref) {
            var a = ref[0];
            var b = ref[1];

            return a.evaluate(ctx) / b.evaluate(ctx);
}
    ],
    '%': [
        NumberType,
        [NumberType, NumberType],
        function (ctx, ref) {
            var a = ref[0];
            var b = ref[1];

            return a.evaluate(ctx) % b.evaluate(ctx);
}
    ],
    'ln2': [
        NumberType,
        [],
        function () { return Math.LN2; }
    ],
    'pi': [
        NumberType,
        [],
        function () { return Math.PI; }
    ],
    'e': [
        NumberType,
        [],
        function () { return Math.E; }
    ],
    '^': [
        NumberType,
        [NumberType, NumberType],
        function (ctx, ref) {
            var b = ref[0];
            var e = ref[1];

            return Math.pow(b.evaluate(ctx), e.evaluate(ctx));
}
    ],
    'log10': [
        NumberType,
        [NumberType],
        function (ctx, ref) {
            var n = ref[0];

            return Math.log10(n.evaluate(ctx));
}
    ],
    'ln': [
        NumberType,
        [NumberType],
        function (ctx, ref) {
            var n = ref[0];

            return Math.log(n.evaluate(ctx));
}
    ],
    'log2': [
        NumberType,
        [NumberType],
        function (ctx, ref) {
            var n = ref[0];

            return Math.log2(n.evaluate(ctx));
}
    ],
    'sin': [
        NumberType,
        [NumberType],
        function (ctx, ref) {
            var n = ref[0];

            return Math.sin(n.evaluate(ctx));
}
    ],
    'cos': [
        NumberType,
        [NumberType],
        function (ctx, ref) {
            var n = ref[0];

            return Math.cos(n.evaluate(ctx));
}
    ],
    'tan': [
        NumberType,
        [NumberType],
        function (ctx, ref) {
            var n = ref[0];

            return Math.tan(n.evaluate(ctx));
}
    ],
    'asin': [
        NumberType,
        [NumberType],
        function (ctx, ref) {
            var n = ref[0];

            return Math.asin(n.evaluate(ctx));
}
    ],
    'acos': [
        NumberType,
        [NumberType],
        function (ctx, ref) {
            var n = ref[0];

            return Math.acos(n.evaluate(ctx));
}
    ],
    'atan': [
        NumberType,
        [NumberType],
        function (ctx, ref) {
            var n = ref[0];

            return Math.atan(n.evaluate(ctx));
}
    ],
    'min': [
        NumberType,
        varargs(NumberType),
        function (ctx, args) { return Math.min.apply(Math, args.map(function (arg) { return arg.evaluate(ctx); })); }
    ],
    'max': [
        NumberType,
        varargs(NumberType),
        function (ctx, args) { return Math.max.apply(Math, args.map(function (arg) { return arg.evaluate(ctx); })); }
    ],
    '==': {
        type: BooleanType,
        overloads: [
            [[NumberType, NumberType], eq],
            [[StringType, StringType], eq],
            [[BooleanType, BooleanType], eq],
            [[NullType, NullType], eq]
        ]
    },
    '!=': {
        type: BooleanType,
        overloads: [
            [[NumberType, NumberType], ne],
            [[StringType, StringType], ne],
            [[BooleanType, BooleanType], ne],
            [[NullType, NullType], ne]
        ]
    },
    '>': {
        type: BooleanType,
        overloads: [
            [[NumberType, NumberType], gt],
            [[StringType, StringType], gt]
        ]
    },
    '<': {
        type: BooleanType,
        overloads: [
            [[NumberType, NumberType], lt],
            [[StringType, StringType], lt]
        ]
    },
    '>=': {
        type: BooleanType,
        overloads: [
            [[NumberType, NumberType], gteq],
            [[StringType, StringType], gteq]
        ]
    },
    '<=': {
        type: BooleanType,
        overloads: [
            [[NumberType, NumberType], lteq],
            [[StringType, StringType], lteq]
        ]
    },
    'all': {
        type: BooleanType,
        overloads: [
            [
                [BooleanType, BooleanType],
                function (ctx, ref) {
                    var a = ref[0];
                    var b = ref[1];

                    return a.evaluate(ctx) && b.evaluate(ctx);
}
            ],
            [
                varargs(BooleanType),
                function (ctx, args) {
                    for (var i = 0, list = args; i < list.length; i += 1) {
                        var arg = list[i];

                        if (!arg.evaluate(ctx))
                            { return false; }
                    }
                    return true;
                }
            ]
        ]
    },
    'any': {
        type: BooleanType,
        overloads: [
            [
                [BooleanType, BooleanType],
                function (ctx, ref) {
                    var a = ref[0];
                    var b = ref[1];

                    return a.evaluate(ctx) || b.evaluate(ctx);
}
            ],
            [
                varargs(BooleanType),
                function (ctx, args) {
                    for (var i = 0, list = args; i < list.length; i += 1) {
                        var arg = list[i];

                        if (arg.evaluate(ctx))
                            { return true; }
                    }
                    return false;
                }
            ]
        ]
    },
    '!': [
        BooleanType,
        [BooleanType],
        function (ctx, ref) {
            var b = ref[0];

            return !b.evaluate(ctx);
}
    ],
    'upcase': [
        StringType,
        [StringType],
        function (ctx, ref) {
            var s = ref[0];

            return s.evaluate(ctx).toUpperCase();
}
    ],
    'downcase': [
        StringType,
        [StringType],
        function (ctx, ref) {
            var s = ref[0];

            return s.evaluate(ctx).toLowerCase();
}
    ],
    'concat': [
        StringType,
        varargs(StringType),
        function (ctx, args) { return args.map(function (arg) { return arg.evaluate(ctx); }).join(''); }
    ]
});

module.exports = expressions;

},{"../compound_expression":24,"../runtime_error":42,"../types":44,"../values":45,"./array":25,"./assertion":26,"./at":27,"./case":28,"./coalesce":29,"./coercion":30,"./curve":31,"./let":33,"./literal":34,"./match":35,"./var":36}],33:[function(require,module,exports){
//      

                                     
                                                
                                                     
                                                            

var Let = function Let(key    , bindings                         , result        ) {
    this.key = key;
    this.type = result.type;
    this.bindings = [].concat(bindings);
    this.result = result;
};

Let.prototype.evaluate = function evaluate (ctx               ) {
    ctx.pushScope(this.bindings);
    var result = this.result.evaluate(ctx);
    ctx.popScope();
    return result;
};

Let.prototype.eachChild = function eachChild (fn                  ) {
        var this$1 = this;

    for (var i = 0, list = this$1.bindings; i < list.length; i += 1) {
        var binding = list[i];

            fn(binding[1]);
    }
    fn(this.result);
};

Let.parse = function parse (args          , context            ) {
    if (args.length < 4)
        { return context.error(("Expected at least 3 arguments, but found " + (args.length - 1) + " instead.")); }

    var bindings                          = [];
    for (var i = 1; i < args.length - 1; i += 2) {
        var name = args[i];

        if (typeof name !== 'string') {
            return context.error(("Expected string, but found " + (typeof name) + " instead."), i);
        }

        if (/[^a-zA-Z0-9_]/.test(name)) {
            return context.error("Variable names must contain only alphanumeric characters or '_'.", i);
        }

        var value = context.parse(args[i + 1], i + 1);
        if (!value) { return null; }

        bindings.push([name, value]);
    }

    var result = context.parse(args[args.length - 1], args.length - 1, undefined, bindings);
    if (!result) { return null; }

    return new Let(context.key, bindings, result);
};

module.exports = Let;

},{}],34:[function(require,module,exports){
//      

var ref = require('../values');
var isValue = ref.isValue;
var typeOf = ref.typeOf;

                                     
                                        
                                                
                                                     

var Literal = function Literal(key   , type  , value   ) {
    this.key = key;
    this.type = type;
    this.value = value;
};

Literal.parse = function parse (args          , context            ) {
    if (args.length !== 2)
        { return context.error(("'literal' expression requires exactly one argument, but found " + (args.length - 1) + " instead.")); }

    if (!isValue(args[1]))
        { return context.error("invalid value"); }

    var value = (args[1] );
    var type = typeOf(value);

    // special case: infer the item type if possible for zero-length arrays
    var expected = context.expectedType;
    if (
        type.kind === 'array' &&
        type.N === 0 &&
        expected &&
        expected.kind === 'array' &&
        (typeof expected.N !== 'number' || expected.N === 0)
    ) {
        type = expected;
    }

    return new Literal(context.key, type, value);
};

Literal.prototype.evaluate = function evaluate () {
    return this.value;
};

Literal.prototype.eachChild = function eachChild () {};

module.exports = Literal;

},{"../values":45}],35:[function(require,module,exports){
//      

var assert = require('assert');
var ref = require('../values');
var typeOf = ref.typeOf;

                                                
                                                     
                                                           
                                     

// Map input label values to output expression index
                                         

var Match = function Match(key    , inputType  , outputType  , input        , cases   , outputs               , otherwise        ) {
    this.key = key;
    this.inputType = inputType;
    this.type = outputType;
    this.input = input;
    this.cases = cases;
    this.outputs = outputs;
    this.otherwise = otherwise;
};

Match.parse = function parse (args          , context            ) {
    if (args.length < 5)
        { return context.error(("Expected at least 4 arguments, but found only " + (args.length - 1) + ".")); }
    if (args.length % 2 !== 1)
        { return context.error("Expected an even number of arguments."); }

    var inputType;
    var outputType;
    if (context.expectedType && context.expectedType.kind !== 'value') {
        outputType = context.expectedType;
    }
    var cases = {};
    var outputs = [];
    for (var i = 2; i < args.length - 1; i += 2) {
        var labels = args[i];
        var value = args[i + 1];

        if (!Array.isArray(labels)) {
            labels = [labels];
        }

        var labelContext = context.concat(i);
        if (labels.length === 0) {
            return labelContext.error('Expected at least one branch label.');
        }

        for (var i$1 = 0, list = labels; i$1 < list.length; i$1 += 1) {
            var label = list[i$1];

                if (typeof label !== 'number' && typeof label !== 'string') {
                return labelContext.error("Branch labels must be numbers or strings.");
            } else if (typeof label === 'number' && Math.abs(label) > Number.MAX_SAFE_INTEGER) {
                return labelContext.error(("Branch labels must be integers no larger than " + (Number.MAX_SAFE_INTEGER) + "."));

            } else if (typeof label === 'number' && Math.floor(label) !== label) {
                return labelContext.error("Numeric branch labels must be integer values.");

            } else if (!inputType) {
                inputType = typeOf(label);
            } else if (labelContext.checkSubtype(inputType, typeOf(label))) {
                return null;
            }

            if (typeof cases[String(label)] !== 'undefined') {
                return labelContext.error('Branch labels must be unique.');
            }

            cases[String(label)] = outputs.length;
        }

        var result = context.parse(value, i, outputType);
        if (!result) { return null; }
        outputType = outputType || result.type;
        outputs.push(result);
    }

    var input = context.parse(args[1], 1, inputType);
    if (!input) { return null; }

    var otherwise = context.parse(args[args.length - 1], args.length - 1, outputType);
    if (!otherwise) { return null; }

    assert(inputType && outputType);
    return new Match(context.key, (inputType ), (outputType ), input, cases, outputs, otherwise);
};

Match.prototype.evaluate = function evaluate (ctx               ) {
    var input = (this.input.evaluate(ctx) );
    return (this.outputs[this.cases[input]] || this.otherwise).evaluate(ctx);
};

Match.prototype.eachChild = function eachChild (fn                  ) {
    fn(this.input);
    this.outputs.forEach(fn);
    fn(this.otherwise);
};

module.exports = Match;

},{"../values":45,"assert":3}],36:[function(require,module,exports){
//      

                                     
                                                
                                                     
                                                            

var Var = function Var(key    , name    , type  ) {
    this.key = key;
    this.type = type;
    this.name = name;
};

Var.parse = function parse (args          , context            ) {
    if (args.length !== 2 || typeof args[1] !== 'string')
        { return context.error("'var' expression requires exactly one string literal argument."); }

    var name = args[1];
    if (!context.scope.has(name)) {
        return context.error(("Unknown variable \"" + name + "\". Make sure \"" + name + "\" has been bound in an enclosing \"let\" expression before using it."), 1);
    }

    return new Var(context.key, name, context.scope.get(name).type);
};

Var.prototype.evaluate = function evaluate (ctx               ) {
    return ctx.scope.get(this.name).evaluate(ctx);
};

Var.prototype.eachChild = function eachChild () {};

module.exports = Var;

},{}],37:[function(require,module,exports){
//      

var assert = require('assert');
var Scope = require('./scope');
var parseColor = require('../util/parse_color');
var ref = require('./values');
var Color = ref.Color;

                                                         
                                               

var geometryTypes = ['Unknown', 'Point', 'LineString', 'Polygon'];

var EvaluationContext = function EvaluationContext() {
    this.scope = new Scope();
    this._parseColorCache = {};
};

EvaluationContext.prototype.id = function id () {
    return this.feature && 'id' in this.feature ? this.feature.id : null;
};

EvaluationContext.prototype.geometryType = function geometryType () {
    return this.feature ? typeof this.feature.type === 'number' ? geometryTypes[this.feature.type] : this.feature.type : null;
};

EvaluationContext.prototype.properties = function properties () {
    return this.feature && this.feature.properties || {};
};

EvaluationContext.prototype.pushScope = function pushScope (bindings                         ) {
    this.scope = this.scope.concat(bindings);
};

EvaluationContext.prototype.popScope = function popScope () {
    assert(this.scope.parent);
    this.scope = (this.scope.parent );
};

EvaluationContext.prototype.parseColor = function parseColor$1 (input    )     {
    var cached = this._parseColorCache[input];
    if (!cached) {
        var c = parseColor(input);
        cached = this._parseColorCache[input] = c ? new Color(c[0], c[1], c[2], c[3]) : null;
    }
    return cached;
};

module.exports = EvaluationContext;

},{"../util/parse_color":62,"./scope":43,"./values":45,"assert":3}],38:[function(require,module,exports){
//      

var assert = require('assert');
var ParsingError = require('./parsing_error');
var ParsingContext = require('./parsing_context');
var EvaluationContext = require('./evaluation_context');
var ref = require('./compound_expression');
var CompoundExpression = ref.CompoundExpression;
var Curve = require('./definitions/curve');
var Coalesce = require('./definitions/coalesce');
var Let = require('./definitions/let');
var definitions = require('./definitions');
var isConstant = require('./is_constant');
var ref$1 = require('./values');
var unwrap = ref$1.unwrap;

                                  
                                    
                                             
                                                           

                       
                                                                                                                          
              
                                
  

                                
                 
                           
  

                                                           

                                     
                    
                               
  

                               
                      
                                    
                         
                               
                                                                    
                         
  

                                                                   
                      
                        
                          
                               
                                                                    
                          
                                     
                            
  

                                                              
                      
                      
                          
                               
                                                           
                          
  

                                                                                 

                                          
                   
                        
                                 
                    
     
                   
                        
                                 
                    
     
                    
                        
                                 
                     
     
                 
                        
                                 
                           
                    
     
                  
                        
                                 
                                           
                    
                          
     
                  
                        
                                 
                    
  

function isExpression(expression       ) {
    return Array.isArray(expression) && expression.length > 0 &&
        typeof expression[0] === 'string' && expression[0] in definitions;
}

/**
 * Parse and typecheck the given style spec JSON expression.  If
 * options.defaultValue is provided, then the resulting StyleExpression's
 * `evaluate()` method will handle errors by logging a warning (once per
 * message) and returning the default value.  Otherwise, it will throw
 * evaluation errors.
 *
 * @private
 */
function createExpression(expression       ,
                          propertySpec                            ,
                          context                        ,
                          options)                                          {
    if ( options === void 0 ) options                           = {};

    var parser = new ParsingContext(definitions, [], getExpectedType(propertySpec));
    var parsed = parser.parse(expression);
    if (!parsed) {
        assert(parser.errors.length > 0);
        return {
            result: 'error',
            errors: parser.errors
        };
    }

    var evaluator = new EvaluationContext();

    var evaluate;
    if (options.handleErrors === false) {
        evaluate = function (globals, feature) {
            evaluator.globals = globals;
            evaluator.feature = feature;
            return parsed.evaluate(evaluator);
        };
    } else {
        var warningHistory                           = {};
        var defaultValue = getDefaultValue(propertySpec);
        evaluate = function (globals, feature) {
            evaluator.globals = globals;
            evaluator.feature = feature;
            try {
                var val = parsed.evaluate(evaluator);
                if (val === null || val === undefined) {
                    return unwrap(defaultValue);
                }
                return unwrap(val);
            } catch (e) {
                if (!warningHistory[e.message]) {
                    warningHistory[e.message] = true;
                    if (typeof console !== 'undefined') {
                        console.warn(e.message);
                    }
                }
                return unwrap(defaultValue);
            }
        };
    }

    var isFeatureConstant = isConstant.isFeatureConstant(parsed);
    if (!isFeatureConstant && context === 'property' && !propertySpec['property-function']) {
        return {
            result: 'error',
            errors: [new ParsingError('', 'property expressions not supported')]
        };
    }

    var isZoomConstant = isConstant.isGlobalPropertyConstant(parsed, ['zoom']);
    if (isZoomConstant) {
        return {
            result: 'success',
            context: context,
            isZoomConstant: true,
            isFeatureConstant: isFeatureConstant,
            evaluate: evaluate,
            parsed: parsed
        };
    } else if (context === 'filter') {
        return {
            result: 'success',
            context: 'filter',
            isZoomConstant: false,
            isFeatureConstant: isFeatureConstant,
            evaluate: evaluate,
            parsed: parsed
        };
    }

    var zoomCurve = findZoomCurve(parsed);
    if (!zoomCurve) {
        return {
            result: 'error',
            errors: [new ParsingError('', '"zoom" expression may only be used as input to a top-level "curve" expression.')]
        };
    } else if (!(zoomCurve instanceof Curve)) {
        return {
            result: 'error',
            errors: [new ParsingError(zoomCurve.key, zoomCurve.error)]
        };
    } else if (zoomCurve.interpolation.name !== 'step' && propertySpec['function'] === 'piecewise-constant') {
        return {
            result: 'error',
            errors: [new ParsingError(zoomCurve.key, 'interpolation type must be "step" for this property')]
        };
    }

    return {
        result: 'success',
        context: 'property',
        isZoomConstant: false,
        isFeatureConstant: isFeatureConstant,
        evaluate: evaluate,
        parsed: parsed,

        // capture metadata from the curve definition that's needed for
        // our prepopulate-and-interpolate approach to paint properties
        // that are zoom-and-property dependent.
        interpolation: zoomCurve.interpolation,
        zoomStops: zoomCurve.labels
    };
}

module.exports.createExpression = createExpression;
module.exports.isExpression = isExpression;

// Zoom-dependent expressions may only use ["zoom"] as the input to a
// 'top-level' "curve" expression. (The curve may be wrapped in one or more
// "let" or "coalesce" expressions.)
function findZoomCurve(expression            )                                              {
    if (expression instanceof Curve) {
        var input = expression.input;
        if (input instanceof CompoundExpression && input.name === 'zoom') {
            return expression;
        } else {
            return null;
        }
    } else if (expression instanceof Let) {
        return findZoomCurve(expression.result);
    } else if (expression instanceof Coalesce) {
        var result = null;
        for (var i = 0, list = expression.args; i < list.length; i += 1) {
            var arg = list[i];

          var e = findZoomCurve(arg);
            if (!e) {
                continue;
            } else if (e.error) {
                return e;
            } else if (e instanceof Curve && !result) {
                result = e;
            } else {
                return {
                    key: e.key,
                    error: 'Only one zoom-based curve may be used in a style function.'
                };
            }
        }

        return result;
    } else {
        return null;
    }
}

var ref$2 = require('./types');
var ColorType = ref$2.ColorType;
var StringType = ref$2.StringType;
var NumberType = ref$2.NumberType;
var BooleanType = ref$2.BooleanType;
var ValueType = ref$2.ValueType;
var array = ref$2.array;

function getExpectedType(spec                            )              {
    var types = {
        color: ColorType,
        string: StringType,
        number: NumberType,
        enum: StringType,
        boolean: BooleanType
    };

    if (spec.type === 'array') {
        return array(types[spec.value] || ValueType, spec.length);
    }

    return types[spec.type] || null;
}

var ref$3 = require('../function');
var isFunction = ref$3.isFunction;
var parseColor = require('../util/parse_color');
var ref$4 = require('./values');
var Color = ref$4.Color;

function getDefaultValue(spec                            )               {
    var defaultValue = spec.default;
    if (spec.type === 'color' && isFunction(defaultValue)) {
        // Special case for heatmap-color: it uses the 'default:' to define a
        // default color ramp, but createExpression expects a simple value to fall
        // back to in case of runtime errors
        return [0, 0, 0, 0];
    } else if (spec.type === 'color') {
        var c                                   = (parseColor((defaultValue     ))     );
        assert(Array.isArray(c));
        return new Color(c[0], c[1], c[2], c[3]);
    }
    return defaultValue === undefined ? null : defaultValue;
}

},{"../function":49,"../util/parse_color":62,"./compound_expression":24,"./definitions":32,"./definitions/coalesce":29,"./definitions/curve":31,"./definitions/let":33,"./evaluation_context":37,"./is_constant":39,"./parsing_context":40,"./parsing_error":41,"./types":44,"./values":45,"assert":3}],39:[function(require,module,exports){
//      

var ref = require('./compound_expression');
var CompoundExpression = ref.CompoundExpression;

                                                  

function isFeatureConstant(e            ) {
    if (e instanceof CompoundExpression) {
        if (e.name === 'get' && e.args.length === 1) {
            return false;
        } else if (e.name === 'has' && e.args.length === 1) {
            return false;
        } else if (
            e.name === 'properties' ||
            e.name === 'geometry-type' ||
            e.name === 'id'
        ) {
            return false;
        }
    }

    var result = true;
    e.eachChild(function (arg) {
        if (result && !isFeatureConstant(arg)) { result = false; }
    });
    return result;
}

function isGlobalPropertyConstant(e            , properties               ) {
    if (e instanceof CompoundExpression && properties.indexOf(e.name) >= 0) { return false; }
    var result = true;
    e.eachChild(function (arg) {
        if (result && !isGlobalPropertyConstant(arg, properties)) { result = false; }
    });
    return result;
}

module.exports = {
    isFeatureConstant: isFeatureConstant,
    isGlobalPropertyConstant: isGlobalPropertyConstant,
};

},{"./compound_expression":24}],40:[function(require,module,exports){
//      

var Scope = require('./scope');
var ref = require('./types');
var checkSubtype = ref.checkSubtype;
var ParsingError = require('./parsing_error');
var Literal = require('./definitions/literal');

                                             
                                  

/**
 * State associated parsing at a given point in an expression tree.
 * @private
 */
var ParsingContext = function ParsingContext(
    definitions   ,
    path,
    expectedType   ,
    scope,
    errors
) {
    if ( path === void 0 ) path            = [];
    if ( scope === void 0 ) scope    = new Scope();
    if ( errors === void 0 ) errors                  = [];

    this.definitions = definitions;
    this.path = path;
    this.key = path.map(function (part) { return ("[" + part + "]"); }).join('');
    this.scope = scope;
    this.errors = errors;
    this.expectedType = expectedType;
};

ParsingContext.prototype.parse = function parse (expr   , index     , expectedType    , bindings                          )          {
    var context = this;
    if (index) {
        context = context.concat(index, expectedType, bindings);
    }

    if (expr === null || typeof expr === 'string' || typeof expr === 'boolean' || typeof expr === 'number') {
        expr = ['literal', expr];
    }

    if (Array.isArray(expr)) {
        if (expr.length === 0) {
            return context.error("Expected an array with at least one element. If you wanted a literal array, use [\"literal\", []].");
        }

        var op = expr[0];
        if (typeof op !== 'string') {
            context.error(("Expression name must be a string, but found " + (typeof op) + " instead. If you wanted a literal array, use [\"literal\", [...]]."), 0);
            return null;
        }

        var Expr = context.definitions[op];
        if (Expr) {
            var parsed = Expr.parse(expr, context);
            if (!parsed) { return null; }
            var expected = context.expectedType;
            var actual = parsed.type;
            if (expected) {
                // When we expect a number, string, or boolean but have a
                // Value, wrap it in a refining assertion, and when we expect
                // a Color but have a String or Value, wrap it in "to-color"
                // coercion.
                var canAssert = expected.kind === 'string' ||
                    expected.kind === 'number' ||
                    expected.kind === 'boolean';

                if (canAssert && actual.kind === 'value') {
                    var Assertion = require('./definitions/assertion');
                    parsed = new Assertion(parsed.key, expected, [parsed]);
                } else if (expected.kind === 'color' && (actual.kind === 'value' || actual.kind === 'string')) {
                    var Coercion = require('./definitions/coercion');
                    parsed = new Coercion(parsed.key, expected, [parsed]);
                }

                if (context.checkSubtype(expected, parsed.type)) {
                    return null;
                }
            }

            // If an expression's arguments are all literals, we can evaluate
            // it immediately and replace it with a literal value in the
            // parsed/compiled result.
            if (!(parsed instanceof Literal) && isConstant(parsed)) {
                var ec = new (require('./evaluation_context'))();
                try {
                    parsed = new Literal(parsed.key, parsed.type, parsed.evaluate(ec));
                } catch (e) {
                    context.error(e.message);
                    return null;
                }
            }

            return parsed;
        }

        return context.error(("Unknown expression \"" + op + "\". If you wanted a literal array, use [\"literal\", [...]]."), 0);
    } else if (typeof expr === 'undefined') {
        return context.error("'undefined' value invalid. Use null instead.");
    } else if (typeof expr === 'object') {
        return context.error("Bare objects invalid. Use [\"literal\", {...}] instead.");
    } else {
        return context.error(("Expected an array, but found " + (typeof expr) + " instead."));
    }
};

/**
 * Returns a copy of this context suitable for parsing the subexpression at
 * index `index`, optionally appending to 'let' binding map.
 *
 * Note that `errors` property, intended for collecting errors while
 * parsing, is copied by reference rather than cloned.
 * @private
 */
ParsingContext.prototype.concat = function concat (index    , expectedType    , bindings                          ) {
    var path = typeof index === 'number' ? this.path.concat(index) : this.path;
    var scope = bindings ? this.scope.concat(bindings) : this.scope;
    return new ParsingContext(
        this.definitions,
        path,
        expectedType || null,
        scope,
        this.errors
    );
};

/**
 * Push a parsing (or type checking) error into the `this.errors`
 * @param error The message
 * @param keys Optionally specify the source of the error at a child
 * of the current expression at `this.key`.
 * @private
 */
ParsingContext.prototype.error = function error (error$1           ) {
        var keys = [], len = arguments.length - 1;
        while ( len-- > 0 ) keys[ len ] = arguments[ len + 1 ];

    var key = "" + (this.key) + (keys.map(function (k) { return ("[" + k + "]"); }).join(''));
    this.errors.push(new ParsingError(key, error$1));
};

/**
 * Returns null if `t` is a subtype of `expected`; otherwise returns an
 * error message and also pushes it to `this.errors`.
 */
ParsingContext.prototype.checkSubtype = function checkSubtype$1 (expected  , t  )      {
    var error = checkSubtype(expected, t);
    if (error) { this.error(error); }
    return error;
};

module.exports = ParsingContext;

function isConstant(expression            ) {
    // requires within function body to workaround circular dependency
    var ref = require('./compound_expression');
    var CompoundExpression = ref.CompoundExpression;
    var ref$1 = require('./is_constant');
    var isGlobalPropertyConstant = ref$1.isGlobalPropertyConstant;
    var isFeatureConstant = ref$1.isFeatureConstant;
    var Var = require('./definitions/var');

    if (expression instanceof Var) {
        return false;
    } else if (expression instanceof CompoundExpression && expression.name === 'error') {
        return false;
    }

    var literalArgs = true;
    expression.eachChild(function (arg) {
        if (!(arg instanceof Literal)) { literalArgs = false; }
    });
    if (!literalArgs) {
        return false;
    }

    return isFeatureConstant(expression) &&
        isGlobalPropertyConstant(expression, ['zoom', 'heatmap-density']);
}

},{"./compound_expression":24,"./definitions/assertion":26,"./definitions/coercion":30,"./definitions/literal":34,"./definitions/var":36,"./evaluation_context":37,"./is_constant":39,"./parsing_error":41,"./scope":43,"./types":44}],41:[function(require,module,exports){
//      

var ParsingError = (function (Error) {
    function ParsingError(key        , message        ) {
        Error.call(this, message);
        this.message = message;
        this.key = key;
    }

    if ( Error ) ParsingError.__proto__ = Error;
    ParsingError.prototype = Object.create( Error && Error.prototype );
    ParsingError.prototype.constructor = ParsingError;

    return ParsingError;
}(Error));

module.exports = ParsingError;

},{}],42:[function(require,module,exports){
//      

var RuntimeError = function RuntimeError(message    ) {
    this.name = 'ExpressionEvaluationError';
    this.message = message;
};

RuntimeError.prototype.toJSON = function toJSON () {
    return this.message;
};

module.exports = RuntimeError;

},{}],43:[function(require,module,exports){
//      

                                             

/**
 * Tracks `let` bindings during expression parsing.
 * @private
 */
var Scope = function Scope(parent    , bindings) {
    var this$1 = this;
    if ( bindings === void 0 ) bindings                          = [];

    this.parent = parent;
    this.bindings = {};
    for (var i = 0, list = bindings; i < list.length; i += 1) {
        var ref = list[i];
        var name = ref[0];
        var expression = ref[1];

        this$1.bindings[name] = expression;
    }
};

Scope.prototype.concat = function concat (bindings                         ) {
    return new Scope(this, bindings);
};

Scope.prototype.get = function get (name    )         {
    if (this.bindings[name]) { return this.bindings[name]; }
    if (this.parent) { return this.parent.get(name); }
    throw new Error((name + " not found in scope."));
};

Scope.prototype.has = function has (name    )      {
    if (this.bindings[name]) { return true; }
    return this.parent ? this.parent.has(name) : false;
};

module.exports = Scope;

},{}],44:[function(require,module,exports){
//      

                                         
                                             
                                             
                                               
                                           
                                             
                                           
                                           

                  
               
                 
                 
                  
                
                 
                
                                                           
              

                         
                  
                   
              
 

var NullType = { kind: 'null' };
var NumberType = { kind: 'number' };
var StringType = { kind: 'string' };
var BooleanType = { kind: 'boolean' };
var ColorType = { kind: 'color' };
var ObjectType = { kind: 'object' };
var ValueType = { kind: 'value' };
var ErrorType = { kind: 'error' };

function array(itemType      , N         )            {
    return {
        kind: 'array',
        itemType: itemType,
        N: N
    };
}

function toString(type      )         {
    if (type.kind === 'array') {
        var itemType = toString(type.itemType);
        return typeof type.N === 'number' ?
            ("array<" + itemType + ", " + (type.N) + ">") :
            type.itemType.kind === 'value' ? 'array' : ("array<" + itemType + ">");
    } else {
        return type.kind;
    }
}

var valueMemberTypes = [
    NullType,
    NumberType,
    StringType,
    BooleanType,
    ColorType,
    ObjectType,
    array(ValueType)
];

/**
 * Returns null if `t` is a subtype of `expected`; otherwise returns an
 * error message.
 * * @private
 */
function checkSubtype(expected      , t      )          {
    if (t.kind === 'error') {
        // Error is a subtype of every type
        return null;
    } else if (expected.kind === 'array') {
        if (t.kind === 'array' &&
            !checkSubtype(expected.itemType, t.itemType) &&
            (typeof expected.N !== 'number' || expected.N === t.N)) {
            return null;
        }
    } else if (expected.kind === t.kind) {
        return null;
    } else if (expected.kind === 'value') {
        for (var i = 0, list = valueMemberTypes; i < list.length; i += 1) {
            var memberType = list[i];

            if (!checkSubtype(memberType, t)) {
                return null;
            }
        }
    }

    return ("Expected " + (toString(expected)) + " but found " + (toString(t)) + " instead.");
}

module.exports = {
    NullType: NullType,
    NumberType: NumberType,
    StringType: StringType,
    BooleanType: BooleanType,
    ColorType: ColorType,
    ObjectType: ObjectType,
    ValueType: ValueType,
    array: array,
    ErrorType: ErrorType,
    toString: toString,
    checkSubtype: checkSubtype
};

},{}],45:[function(require,module,exports){
//      

var assert = require('assert');

var ref = require('./types');
var NullType = ref.NullType;
var NumberType = ref.NumberType;
var StringType = ref.StringType;
var BooleanType = ref.BooleanType;
var ColorType = ref.ColorType;
var ObjectType = ref.ObjectType;
var ValueType = ref.ValueType;
var array = ref.array;

                                    

var Color = function Color(r    , g    , b    , a) {
    if ( a === void 0 ) a     = 1;

    this.value = [r, g, b, a];
};

function validateRGBA(r       , g       , b       , a        )          {
    if (!(
        typeof r === 'number' && r >= 0 && r <= 255 &&
        typeof g === 'number' && g >= 0 && g <= 255 &&
        typeof b === 'number' && b >= 0 && b <= 255
    )) {
        var value = typeof a === 'number' ? [r, g, b, a] : [r, g, b];
        return ("Invalid rgba value [" + (value.join(', ')) + "]: 'r', 'g', and 'b' must be between 0 and 255.");
    }

    if (!(
        typeof a === 'undefined' || (typeof a === 'number' && a >= 0 && a <= 1)
    )) {
        return ("Invalid rgba value [" + ([r, g, b, a].join(', ')) + "]: 'a' must be between 0 and 1.");
    }

    return null;
}

                                                                                                 

function isValue(mixed       )          {
    if (mixed === null) {
        return true;
    } else if (typeof mixed === 'string') {
        return true;
    } else if (typeof mixed === 'boolean') {
        return true;
    } else if (typeof mixed === 'number') {
        return true;
    } else if (mixed instanceof Color) {
        return true;
    } else if (Array.isArray(mixed)) {
        for (var i = 0, list = mixed; i < list.length; i += 1) {
            var item = list[i];

            if (!isValue(item)) {
                return false;
            }
        }
        return true;
    } else if (typeof mixed === 'object') {
        for (var key in mixed) {
            if (!isValue(mixed[key])) {
                return false;
            }
        }
        return true;
    } else {
        return false;
    }
}

function typeOf(value       )       {
    if (value === null) {
        return NullType;
    } else if (typeof value === 'string') {
        return StringType;
    } else if (typeof value === 'boolean') {
        return BooleanType;
    } else if (typeof value === 'number') {
        return NumberType;
    } else if (value instanceof Color) {
        return ColorType;
    } else if (Array.isArray(value)) {
        var length = value.length;
        var itemType       ;

        for (var i = 0, list = value; i < list.length; i += 1) {
            var item = list[i];

            var t = typeOf(item);
            if (!itemType) {
                itemType = t;
            } else if (itemType === t) {
                continue;
            } else {
                itemType = ValueType;
                break;
            }
        }

        return array(itemType || ValueType, length);
    } else {
        assert(typeof value === 'object');
        return ObjectType;
    }
}

function unwrap(value       )        {
    return value instanceof Color ? value.value : value;
}

module.exports = {
    Color: Color,
    validateRGBA: validateRGBA,
    isValue: isValue,
    typeOf: typeOf,
    unwrap: unwrap
};

},{"./types":44,"assert":3}],46:[function(require,module,exports){
//      

var ref = require('../expression');
var createExpression = ref.createExpression;

                                                    
                                                                                                        

module.exports = createFilter;
module.exports.isExpressionFilter = isExpressionFilter;

function isExpressionFilter(filter) {
    if (!Array.isArray(filter) || filter.length === 0) {
        return false;
    }
    switch (filter[0]) {
    case 'has':
        return filter.length >= 2 && filter[1] !== '$id' && filter[1] !== '$type';

    case 'in':
    case '!in':
    case '!has':
    case 'none':
        return false;

    case '==':
    case '!=':
    case '>':
    case '>=':
    case '<':
    case '<=':
        return filter.length === 3 && (Array.isArray(filter[1]) || Array.isArray(filter[2]));

    case 'any':
    case 'all':
        for (var i = 0, list = filter.slice(1); i < list.length; i += 1) {
            var f = list[i];

        if (!isExpressionFilter(f) && typeof f !== 'boolean') {
                return false;
            }
        }
        return true;

    default:
        return true;
    }
}

var types = ['Unknown', 'Point', 'LineString', 'Polygon'];

var filterSpec = {
    'type': 'boolean',
    'default': false,
    'function': true,
    'property-function': true
};

/**
 * Given a filter expressed as nested arrays, return a new function
 * that evaluates whether a given feature (with a .properties or .tags property)
 * passes its test.
 *
 * @private
 * @param {Array} filter mapbox gl filter
 * @returns {Function} filter-evaluating function
 */
function createFilter(filter     )                {
    if (!filter) {
        return function () { return true; };
    }

    if (!isExpressionFilter(filter)) {
        return (new Function('g', 'f', ("var p = (f && f.properties || {}); return " + (compile(filter))))     );
    }

    var compiled = createExpression(filter, filterSpec, 'filter');
    if (compiled.result === 'success') {
        return compiled.evaluate;
    } else {
        throw new Error(compiled.errors.map(function (err) { return ((err.key) + ": " + (err.message)); }).join(', '));
    }
}

function compile(filter) {
    if (!filter) { return 'true'; }
    var op = filter[0];
    if (filter.length <= 1) { return op === 'any' ? 'false' : 'true'; }
    var str =
        op === '==' ? compileComparisonOp(filter[1], filter[2], '===', false) :
        op === '!=' ? compileComparisonOp(filter[1], filter[2], '!==', false) :
        op === '<' ||
        op === '>' ||
        op === '<=' ||
        op === '>=' ? compileComparisonOp(filter[1], filter[2], op, true) :
        op === 'any' ? compileLogicalOp(filter.slice(1), '||') :
        op === 'all' ? compileLogicalOp(filter.slice(1), '&&') :
        op === 'none' ? compileNegation(compileLogicalOp(filter.slice(1), '||')) :
        op === 'in' ? compileInOp(filter[1], filter.slice(2)) :
        op === '!in' ? compileNegation(compileInOp(filter[1], filter.slice(2))) :
        op === 'has' ? compileHasOp(filter[1]) :
        op === '!has' ? compileNegation(compileHasOp(filter[1])) :
        'true';
    return ("(" + str + ")");
}

function compilePropertyReference(property) {
    var ref =
        property === '$type' ? 'f.type' :
        property === '$id' ? 'f.id' : ("p[" + (JSON.stringify(property)) + "]");
    return ref;
}

function compileComparisonOp(property, value, op, checkType) {
    var left = compilePropertyReference(property);
    var right = property === '$type' ? types.indexOf(value) : JSON.stringify(value);
    return (checkType ? ("typeof " + left + "=== typeof " + right + "&&") : '') + left + op + right;
}

function compileLogicalOp(expressions, op) {
    return expressions.map(compile).join(op);
}

function compileInOp(property, values) {
    if (property === '$type') { values = values.map(function (value) {
        return types.indexOf(value);
    }); }
    var left = JSON.stringify(values.sort(compare));
    var right = compilePropertyReference(property);

    if (values.length <= 200) { return (left + ".indexOf(" + right + ") !== -1"); }

    return ("" + ('function(v, a, i, j) {' +
        'while (i <= j) { var m = (i + j) >> 1;' +
        '    if (a[m] === v) return true; if (a[m] > v) j = m - 1; else i = m + 1;' +
        '}' +
    'return false; }(') + right + ", " + left + ",0," + (values.length - 1) + ")");
}

function compileHasOp(property) {
    return property === '$id' ? '"id" in f' : ((JSON.stringify(property)) + " in p");
}

function compileNegation(expression) {
    return ("!(" + expression + ")");
}

// Comparison function to sort numbers and strings
function compare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}

},{"../expression":38}],47:[function(require,module,exports){

var reference = require('./reference/latest.js');
var sortObject = require('sort-object');

function sameOrderAs(reference) {
    var keyOrder = {};

    Object.keys(reference).forEach(function (k, i) {
        keyOrder[k] = i + 1;
    });

    return {
        sort: function (a, b) {
            return (keyOrder[a] || Infinity) -
                   (keyOrder[b] || Infinity);
        }
    };
}

/**
 * Format a Mapbox GL Style.  Returns a stringified style with its keys
 * sorted in the same order as the reference style.
 *
 * The optional `space` argument is passed to
 * [`JSON.stringify`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify)
 * to generate formatted output.
 *
 * If `space` is unspecified, a default of `2` spaces will be used.
 *
 * @private
 * @param {Object} style a Mapbox GL Style
 * @param {number} [space] space argument to pass to `JSON.stringify`
 * @returns {string} stringified formatted JSON
 * @example
 * var fs = require('fs');
 * var format = require('mapbox-gl-style-spec').format;
 * var style = fs.readFileSync('./source.json', 'utf8');
 * fs.writeFileSync('./dest.json', format(style));
 * fs.writeFileSync('./dest.min.json', format(style, 0));
 */
function format(style, space) {
    if (space === undefined) { space = 2; }
    style = sortObject(style, sameOrderAs(reference.$root));

    if (style.layers) {
        style.layers = style.layers.map(function (layer) {
            return sortObject(layer, sameOrderAs(reference.layer));
        });
    }

    return JSON.stringify(style, null, space);
}

module.exports = format;

},{"./reference/latest.js":54,"sort-object":93}],48:[function(require,module,exports){
var assert = require('assert');
var extend = require('../util/extend');

module.exports = convertFunction;

function convertFunction(parameters, propertySpec, name) {
    var expression;

    parameters = extend({}, parameters);
    var defaultExpression;
    if (typeof parameters.default !== 'undefined') {
        defaultExpression = convertValue(parameters.default, propertySpec);
    } else {
        defaultExpression = convertValue(propertySpec.default, propertySpec);
        if (defaultExpression === null) {
            defaultExpression = ['error', 'No default property value available.'];
        }
    }

    if (parameters.stops) {
        var zoomAndFeatureDependent = parameters.stops && typeof parameters.stops[0][0] === 'object';
        var featureDependent = zoomAndFeatureDependent || parameters.property !== undefined;
        var zoomDependent = zoomAndFeatureDependent || !featureDependent;

        var stops = parameters.stops.map(function (stop) {
            return [stop[0], convertValue(stop[1], propertySpec)];
        });

        if (parameters.colorSpace && parameters.colorSpace !== 'rgb') {
            throw new Error('Unimplemented');
        }

        if (name === 'heatmap-color') {
            assert(zoomDependent);
            expression = convertZoomFunction(parameters, propertySpec, stops, ['heatmap-density']);
        } else if (zoomAndFeatureDependent) {
            expression = convertZoomAndPropertyFunction(parameters, propertySpec, stops, defaultExpression);
        } else if (zoomDependent) {
            expression = convertZoomFunction(parameters, propertySpec, stops);
        } else {
            expression = convertPropertyFunction(parameters, propertySpec, stops, defaultExpression);
        }
    } else {
        // identity function
        expression = convertIdentityFunction(parameters, propertySpec, defaultExpression);
    }

    return expression;
}

function convertIdentityFunction(parameters, propertySpec, defaultExpression) {
    var get = ['get', parameters.property];
    var type = propertySpec.type;
    if (type === 'color') {
        return ['to-color', get, parameters.default || null, propertySpec.default || null];
    } else if (type === 'array' && typeof propertySpec.length === 'number') {
        return ['array', propertySpec.value, propertySpec.length, get];
    } else if (type === 'array') {
        return ['array', propertySpec.value, get];
    } else if (type === 'enum') {
        return [
            'let',
            'property_value', ['string', get],
            [
                'match',
                ['var', 'property_value'],
                Object.keys(propertySpec.values), ['var', 'property_value'],
                defaultExpression
            ]
        ];
    } else {
        return [propertySpec.type, get, parameters.default || null, propertySpec.default || null];
    }
}

function convertValue(value, spec) {
    if (typeof value === 'undefined' || value === null) { return null; }
    if (spec.type === 'color') {
        return value;
    } else if (spec.type === 'array') {
        return ['literal', value];
    } else {
        return value;
    }
}

function convertZoomAndPropertyFunction(parameters, propertySpec, stops, defaultExpression) {
    var featureFunctionParameters = {};
    var featureFunctionStops = {};
    var zoomStops = [];
    for (var s = 0; s < stops.length; s++) {
        var stop = stops[s];
        var zoom = stop[0].zoom;
        if (featureFunctionParameters[zoom] === undefined) {
            featureFunctionParameters[zoom] = {
                zoom: zoom,
                type: parameters.type,
                property: parameters.property,
                default: parameters.default,
            };
            featureFunctionStops[zoom] = [];
            zoomStops.push(zoom);
        }
        featureFunctionStops[zoom].push([stop[0].value, stop[1]]);
    }

    // the interpolation type for the zoom dimension of a zoom-and-property
    // function is determined directly from the style property specification
    // for which it's being used: linear for interpolatable properties, step
    // otherwise.
    var functionType = getFunctionType({}, propertySpec);
    var interpolationType;
    var isStep = false;
    if (functionType === 'exponential') {
        interpolationType = ['linear'];
    } else {
        interpolationType = ['step'];
        isStep = true;
    }
    var expression = ['curve', interpolationType, ['zoom']];

    for (var i = 0, list = zoomStops; i < list.length; i += 1) {
        var z = list[i];

        var output = convertPropertyFunction(featureFunctionParameters[z], propertySpec, featureFunctionStops[z], defaultExpression);
        appendStopPair(expression, z, output, isStep);
    }

    fixupDegenerateStepCurve(expression);

    return expression;
}

function convertPropertyFunction(parameters, propertySpec, stops, defaultExpression) {
    var type = getFunctionType(parameters, propertySpec);

    var inputType = typeof stops[0][0];
    assert(
        inputType === 'string' ||
        inputType === 'number' ||
        inputType === 'boolean'
    );

    var input = [inputType, ['get', parameters.property]];

    var expression;
    var isStep = false;
    if (type === 'categorical' && inputType === 'boolean') {
        assert(parameters.stops.length > 0 && parameters.stops.length <= 2);
        if (parameters.stops[0][0] === false) {
            input = ['!', input];
        }
        expression = [ 'case', input, parameters.stops[0][1] ];
        if (parameters.stops.length > 1) {
            expression.push(parameters.stops[1][1]);
        } else {
            expression.push(defaultExpression);
        }
        return expression;
    } else if (type === 'categorical') {
        expression = ['match', input];
    } else if (type === 'interval') {
        expression = ['curve', ['step'], input];
        isStep = true;
    } else if (type === 'exponential') {
        var base = parameters.base !== undefined ? parameters.base : 1;
        expression = ['curve', ['exponential', base], input];
    } else {
        throw new Error(("Unknown property function type " + type));
    }

    for (var i = 0, list = stops; i < list.length; i += 1) {
        var stop = list[i];

        appendStopPair(expression, stop[0], stop[1], isStep);
    }

    if (expression[0] === 'match') {
        expression.push(defaultExpression);
    }

    fixupDegenerateStepCurve(expression);

    return expression;
}

function convertZoomFunction(parameters, propertySpec, stops, input) {
    if ( input === void 0 ) input = ['zoom'];

    var type = getFunctionType(parameters, propertySpec);
    var expression;
    var isStep = false;
    if (type === 'interval') {
        expression = ['curve', ['step'], input];
        isStep = true;
    } else if (type === 'exponential') {
        var base = parameters.base !== undefined ? parameters.base : 1;
        expression = ['curve', ['exponential', base], input];
    } else {
        throw new Error(("Unknown zoom function type \"" + type + "\""));
    }

    for (var i = 0, list = stops; i < list.length; i += 1) {
        var stop = list[i];

        appendStopPair(expression, stop[0], stop[1], isStep);
    }

    fixupDegenerateStepCurve(expression);

    return expression;
}

function fixupDegenerateStepCurve(expression) {
    // degenerate step curve (i.e. a constant function): add a noop stop
    if (expression[0] === 'curve' && expression[1][0] === 'step' && expression.length === 4) {
        expression.push(0);
        expression.push(expression[3]);
    }
}

function appendStopPair(curve, input, output, isStep) {
    // step curves don't get the first input value, as it is redundant.
    if (!(isStep && curve.length === 3)) {
        curve.push(input);
    }
    curve.push(output);
}

function getFunctionType (parameters, propertySpec) {
    if (parameters.type) {
        return parameters.type;
    } else if (propertySpec.function) {
        return propertySpec.function === 'interpolated' ? 'exponential' : 'interval';
    } else {
        return 'exponential';
    }
}

},{"../util/extend":59,"assert":3}],49:[function(require,module,exports){

var colorSpaces = require('../util/color_spaces');
var parseColor = require('../util/parse_color');
var extend = require('../util/extend');
var getType = require('../util/get_type');
var interpolate = require('../util/interpolate');

function isFunction(value) {
    return typeof value === 'object' && value !== null && !Array.isArray(value);
}

function identityFunction(x) {
    return x;
}

function createFunction(parameters, propertySpec, name) {
    var isColor = propertySpec.type === 'color';
    var zoomAndFeatureDependent = parameters.stops && typeof parameters.stops[0][0] === 'object';
    var featureDependent = zoomAndFeatureDependent || parameters.property !== undefined;
    var zoomDependent = zoomAndFeatureDependent || !featureDependent;
    var type = parameters.type || (propertySpec.function === 'interpolated' ? 'exponential' : 'interval');

    if (isColor) {
        parameters = extend({}, parameters);

        if (parameters.stops) {
            parameters.stops = parameters.stops.map(function (stop) {
                return [stop[0], parseColor(stop[1])];
            });
        }

        if (parameters.default) {
            parameters.default = parseColor(parameters.default);
        } else {
            parameters.default = parseColor(propertySpec.default);
        }
    }

    var innerFun;
    var hashedStops;
    var categoricalKeyType;
    if (type === 'exponential') {
        innerFun = evaluateExponentialFunction;
    } else if (type === 'interval') {
        innerFun = evaluateIntervalFunction;
    } else if (type === 'categorical') {
        innerFun = evaluateCategoricalFunction;

        // For categorical functions, generate an Object as a hashmap of the stops for fast searching
        hashedStops = Object.create(null);
        for (var i = 0, list = parameters.stops; i < list.length; i += 1) {
            var stop = list[i];

            hashedStops[stop[0]] = stop[1];
        }

        // Infer key type based on first stop key-- used to encforce strict type checking later
        categoricalKeyType = typeof parameters.stops[0][0];

    } else if (type === 'identity') {
        innerFun = evaluateIdentityFunction;
    } else {
        throw new Error(("Unknown function type \"" + type + "\""));
    }

    var outputFunction;

    // If we're interpolating colors in a color system other than RGBA,
    // first translate all stop values to that color system, then interpolate
    // arrays as usual. The `outputFunction` option lets us then translate
    // the result of that interpolation back into RGBA.
    if (parameters.colorSpace && parameters.colorSpace !== 'rgb') {
        if (colorSpaces[parameters.colorSpace]) {
            var colorspace = colorSpaces[parameters.colorSpace];
            // Avoid mutating the parameters value
            parameters = JSON.parse(JSON.stringify(parameters));
            for (var s = 0; s < parameters.stops.length; s++) {
                parameters.stops[s] = [
                    parameters.stops[s][0],
                    colorspace.forward(parameters.stops[s][1])
                ];
            }
            outputFunction = colorspace.reverse;
        } else {
            throw new Error(("Unknown color space: " + (parameters.colorSpace)));
        }
    } else {
        outputFunction = identityFunction;
    }

    if (zoomAndFeatureDependent) {
        var featureFunctions = {};
        var zoomStops = [];
        for (var s$1 = 0; s$1 < parameters.stops.length; s$1++) {
            var stop$1 = parameters.stops[s$1];
            var zoom = stop$1[0].zoom;
            if (featureFunctions[zoom] === undefined) {
                featureFunctions[zoom] = {
                    zoom: zoom,
                    type: parameters.type,
                    property: parameters.property,
                    default: parameters.default,
                    stops: []
                };
                zoomStops.push(zoom);
            }
            featureFunctions[zoom].stops.push([stop$1[0].value, stop$1[1]]);
        }

        var featureFunctionStops = [];
        for (var i$1 = 0, list$1 = zoomStops; i$1 < list$1.length; i$1 += 1) {
            var z = list$1[i$1];

            featureFunctionStops.push([featureFunctions[z].zoom, createFunction(featureFunctions[z], propertySpec)]);
        }

        return {
            isFeatureConstant: false,
            interpolation: {name: 'linear'},
            zoomStops: featureFunctionStops.map(function (s) { return s[0]; }),
            evaluate: function evaluate(ref, properties) {
                var zoom = ref.zoom;

                return outputFunction(evaluateExponentialFunction({
                    stops: featureFunctionStops,
                    base: parameters.base
                }, propertySpec, zoom).evaluate(zoom, properties));
            }
        };
    } else if (zoomDependent) {
        var evaluate;
        if (name === 'heatmap-color') {
            evaluate = function (ref) {
                var heatmapDensity = ref.heatmapDensity;

                return outputFunction(innerFun(parameters, propertySpec, heatmapDensity, hashedStops, categoricalKeyType));
            };
        } else {
            evaluate = function (ref) {
                var zoom = ref.zoom;

                return outputFunction(innerFun(parameters, propertySpec, zoom, hashedStops, categoricalKeyType));
            };
        }
        return {
            isFeatureConstant: true,
            isZoomConstant: false,
            interpolation: type === 'exponential' ?
                {name: 'exponential', base: parameters.base !== undefined ? parameters.base : 1} :
                {name: 'step'},
            zoomStops: parameters.stops.map(function (s) { return s[0]; }),
            evaluate: evaluate
        };
    } else {
        return {
            isFeatureConstant: false,
            isZoomConstant: true,
            evaluate: function evaluate(_, feature) {
                var value = feature && feature.properties ? feature.properties[parameters.property] : undefined;
                if (value === undefined) {
                    return coalesce(parameters.default, propertySpec.default);
                }
                return outputFunction(innerFun(parameters, propertySpec, value, hashedStops, categoricalKeyType));
            }
        };
    }
}

function coalesce(a, b, c) {
    if (a !== undefined) { return a; }
    if (b !== undefined) { return b; }
    if (c !== undefined) { return c; }
}

function evaluateCategoricalFunction(parameters, propertySpec, input, hashedStops, keyType) {
    var evaluated = typeof input === keyType ? hashedStops[input] : undefined; // Enforce strict typing on input
    return coalesce(evaluated, parameters.default, propertySpec.default);
}

function evaluateIntervalFunction(parameters, propertySpec, input) {
    // Edge cases
    if (getType(input) !== 'number') { return coalesce(parameters.default, propertySpec.default); }
    var n = parameters.stops.length;
    if (n === 1) { return parameters.stops[0][1]; }
    if (input <= parameters.stops[0][0]) { return parameters.stops[0][1]; }
    if (input >= parameters.stops[n - 1][0]) { return parameters.stops[n - 1][1]; }

    var index = findStopLessThanOrEqualTo(parameters.stops, input);

    return parameters.stops[index][1];
}

function evaluateExponentialFunction(parameters, propertySpec, input) {
    var base = parameters.base !== undefined ? parameters.base : 1;

    // Edge cases
    if (getType(input) !== 'number') { return coalesce(parameters.default, propertySpec.default); }
    var n = parameters.stops.length;
    if (n === 1) { return parameters.stops[0][1]; }
    if (input <= parameters.stops[0][0]) { return parameters.stops[0][1]; }
    if (input >= parameters.stops[n - 1][0]) { return parameters.stops[n - 1][1]; }

    var index = findStopLessThanOrEqualTo(parameters.stops, input);
    var t = interpolationFactor(
        input, base,
        parameters.stops[index][0],
        parameters.stops[index + 1][0]);

    var outputLower = parameters.stops[index][1];
    var outputUpper = parameters.stops[index + 1][1];
    var interp = interpolate[propertySpec.type] || identityFunction;

    if (typeof outputLower.evaluate === 'function') {
        return {
            evaluate: function evaluate() {
                var args = [], len = arguments.length;
                while ( len-- ) args[ len ] = arguments[ len ];

                var evaluatedLower = outputLower.evaluate.apply(undefined, args);
                var evaluatedUpper = outputUpper.evaluate.apply(undefined, args);
                // Special case for fill-outline-color, which has no spec default.
                if (evaluatedLower === undefined || evaluatedUpper === undefined) {
                    return undefined;
                }
                return interp(evaluatedLower, evaluatedUpper, t);
            }
        };
    }

    return interp(outputLower, outputUpper, t);
}

function evaluateIdentityFunction(parameters, propertySpec, input) {
    if (propertySpec.type === 'color') {
        input = parseColor(input);
    } else if (getType(input) !== propertySpec.type && (propertySpec.type !== 'enum' || !propertySpec.values[input])) {
        input = undefined;
    }
    return coalesce(input, parameters.default, propertySpec.default);
}

/**
 * Returns the index of the last stop <= input, or 0 if it doesn't exist.
 *
 * @private
 */
function findStopLessThanOrEqualTo(stops, input) {
    var n = stops.length;
    var lowerIndex = 0;
    var upperIndex = n - 1;
    var currentIndex = 0;
    var currentValue, upperValue;

    while (lowerIndex <= upperIndex) {
        currentIndex = Math.floor((lowerIndex + upperIndex) / 2);
        currentValue = stops[currentIndex][0];
        upperValue = stops[currentIndex + 1][0];
        if (input === currentValue || input > currentValue && input < upperValue) { // Search complete
            return currentIndex;
        } else if (currentValue < input) {
            lowerIndex = currentIndex + 1;
        } else if (currentValue > input) {
            upperIndex = currentIndex - 1;
        }
    }

    return Math.max(currentIndex - 1, 0);
}

/**
 * Returns a ratio that can be used to interpolate between exponential function
 * stops.
 *
 * How it works:
 * Two consecutive stop values define a (scaled and shifted) exponential
 * function `f(x) = a * base^x + b`, where `base` is the user-specified base,
 * and `a` and `b` are constants affording sufficient degrees of freedom to fit
 * the function to the given stops.
 *
 * Here's a bit of algebra that lets us compute `f(x)` directly from the stop
 * values without explicitly solving for `a` and `b`:
 *
 * First stop value: `f(x0) = y0 = a * base^x0 + b`
 * Second stop value: `f(x1) = y1 = a * base^x1 + b`
 * => `y1 - y0 = a(base^x1 - base^x0)`
 * => `a = (y1 - y0)/(base^x1 - base^x0)`
 *
 * Desired value: `f(x) = y = a * base^x + b`
 * => `f(x) = y0 + a * (base^x - base^x0)`
 *
 * From the above, we can replace the `a` in `a * (base^x - base^x0)` and do a
 * little algebra:
 * ```
 * a * (base^x - base^x0) = (y1 - y0)/(base^x1 - base^x0) * (base^x - base^x0)
 *                     = (y1 - y0) * (base^x - base^x0) / (base^x1 - base^x0)
 * ```
 *
 * If we let `(base^x - base^x0) / (base^x1 base^x0)`, then we have
 * `f(x) = y0 + (y1 - y0) * ratio`.  In other words, `ratio` may be treated as
 * an interpolation factor between the two stops' output values.
 *
 * (Note: a slightly different form for `ratio`,
 * `(base^(x-x0) - 1) / (base^(x1-x0) - 1) `, is equivalent, but requires fewer
 * expensive `Math.pow()` operations.)
 *
 * @private
 */
function interpolationFactor(input, base, lowerValue, upperValue) {
    var difference = upperValue - lowerValue;
    var progress = input - lowerValue;

    if (difference === 0) {
        return 0;
    } else if (base === 1) {
        return progress / difference;
    } else {
        return (Math.pow(base, progress) - 1) / (Math.pow(base, difference) - 1);
    }
}

module.exports = {
    createFunction: createFunction,
    isFunction: isFunction
};

},{"../util/color_spaces":58,"../util/extend":59,"../util/get_type":60,"../util/interpolate":61,"../util/parse_color":62}],50:[function(require,module,exports){

exports.v6 = require('./reference/v6.json');
exports.v7 = require('./reference/v7.json');
exports.v8 = require('./reference/v8.json');
exports.latest = require('./reference/latest');

exports.format = require('./format');
exports.migrate = require('./migrate');
exports.composite = require('./composite');
exports.diff = require('./diff');
exports.ValidationError = require('./error/validation_error');
exports.ParsingError = require('./error/parsing_error');
exports.expression = require('./expression');
exports.featureFilter = require('./feature_filter');

exports.validate = require('./validate_style');
exports.validate.parsed = require('./validate_style');
exports.validate.latest = require('./validate_style');

},{"./composite":20,"./diff":21,"./error/parsing_error":22,"./error/validation_error":23,"./expression":38,"./feature_filter":46,"./format":47,"./migrate":51,"./reference/latest":54,"./reference/v6.json":55,"./reference/v7.json":56,"./reference/v8.json":57,"./validate_style":83}],51:[function(require,module,exports){

/**
 * Migrate a Mapbox GL Style to the latest version.
 *
 * @private
 * @alias migrate
 * @param {object} style a Mapbox GL Style
 * @returns {Object} a migrated style
 * @example
 * var fs = require('fs');
 * var migrate = require('mapbox-gl-style-spec').migrate;
 * var style = fs.readFileSync('./style.json', 'utf8');
 * fs.writeFileSync('./style.json', JSON.stringify(migrate(style)));
 */
module.exports = function(style) {
    var migrated = false;

    if (style.version === 6) {
        style = require('./migrate/v7')(style);
        migrated = true;
    }

    if (style.version === 7 || style.version === 8) {
        style = require('./migrate/v8')(style);
        migrated = true;
    }

    if (!migrated) {
        throw new Error('cannot migrate from', style.version);
    }

    return style;
};

},{"./migrate/v7":52,"./migrate/v8":53}],52:[function(require,module,exports){

var ref = require('../reference/v7.json');

function eachLayer(layer, callback) {
    for (var k in layer.layers) {
        callback(layer.layers[k]);
        eachLayer(layer.layers[k], callback);
    }
}

function eachPaint(layer, callback) {
    for (var k in layer) {
        if (k.indexOf('paint') === 0) {
            callback(layer[k], k);
        }
    }
}


// dash migrations are only safe to run once per style
var MIGRATE_DASHES = false;

var vec2props = {
    "fill-translate": true,
    "line-translate": true,
    "icon-offset": true,
    "text-offset": true,
    "icon-translate": true,
    "text-translate": true
};


module.exports = function(style) {
    style.version = 7;

    var processedConstants = {};

    eachLayer(style, function (layer) {

        var round = layer.layout && layer.layout['line-cap'] === 'round';

        eachPaint(layer, function (paint) {


            // split raster brightness
            if (paint['raster-brightness']) {
                var bval = paint['raster-brightness'];
                if (typeof bval === 'string') { bval = style.constants[bval]; }
                paint['raster-brightness-min'] = typeof bval[0] === 'string' ? style.constants[bval[0]] : bval[0];
                paint['raster-brightness-max'] = typeof bval[1] === 'string' ? style.constants[bval[1]] : bval[1];
                delete paint['raster-brightness'];
            }



            // Migrate vec2 prop functions
            for (var vec2prop in vec2props) {
                var val = paint[vec2prop];
                if (val && Array.isArray(val)) {
                    var s = val[0];
                    var t = val[1];

                    if (typeof s === 'string') {
                        s = style.constants[s];
                    }
                    if (typeof t === 'string') {
                        t = style.constants[t];
                    }

                    // not functions, nothing to migrate
                    if (s === undefined || t === undefined) { continue; }
                    if (!s.stops && !t.stops) { continue; }

                    var stopZooms = [];
                    var base = (void 0);
                    if (s.stops) {
                        for (var i = 0; i < s.stops.length; i++) {
                            stopZooms.push(s.stops[i][0]);
                        }
                        base = s.base;
                    }
                    if (t.stops) {
                        for (var k = 0; k < t.stops.length; k++) {
                            stopZooms.push(t.stops[k][0]);
                        }
                        base = base || t.base;
                    }
                    stopZooms.sort();

                    var fn = parseNumberArray([s, t]);

                    var newStops = [];
                    for (var h = 0; h < stopZooms.length; h++) {
                        var z = stopZooms[h];
                        if (z === stopZooms[h - 1]) { continue; }
                        newStops.push([z, fn(z)]);
                    }

                    paint[vec2prop] = { stops: newStops };
                    if (base) {
                        paint[vec2prop].base = base;
                    }
                }
            }



            if (paint['line-dasharray'] && MIGRATE_DASHES) {
                var w = paint['line-width'] ? paint['line-width'] : ref.class_line['line-width'].default;
                if (typeof w === 'string') { w = style.constants[w]; }

                var dasharray = paint['line-dasharray'];
                if (typeof dasharray === 'string') {
                    // don't process a constant more than once
                    if (processedConstants[dasharray]) { return; }
                    processedConstants[dasharray] = true;

                    dasharray = style.constants[dasharray];
                }

                if (typeof dasharray[0] === 'string') {
                    dasharray[0] = style.constants[dasharray[0]];
                }
                if (typeof dasharray[1] === 'string') {
                    dasharray[1] = style.constants[dasharray[1]];
                }

                var widthFn = parseNumber(w);
                var dashFn = parseNumberArray(dasharray);

                // since there is no perfect way to convert old functions,
                // just use the values at z17 to make the new value.
                var zoom = 17;

                var width = typeof widthFn === 'function' ? widthFn(zoom) : widthFn;
                var dash = dashFn(zoom);

                dash[0] /= width;
                dash[1] /= width;

                if (round) {
                    dash[0] -= 1;
                    dash[1] += 1;
                }

                if (typeof paint['line-dasharray'] === 'string') {
                    style.constants[paint['line-dasharray']] = dash;
                } else {
                    paint['line-dasharray'] = dash;
                }
            }
        });
    });

    style.layers = style.layers.filter(function (layer) {
        return !layer.layers;
    });

    return style;
};

// from mapbox-gl-js/src/style/style_declaration.js

function parseNumberArray(array) {
    var widths = array.map(parseNumber);

    return function(z) {
        var result = [];
        for (var i = 0; i < widths.length; i++) {
            result.push(typeof widths[i] === 'function' ? widths[i](z) : widths[i]);
        }
        return result;
    };
}


function parseNumber(num) {
    if (num.stops) { num = stopsFn(num); }
    var value = +num;
    return !isNaN(value) ? value : num;
}


function stopsFn(params) {
    var stops = params.stops;
    var base = params.base || ref.function.base.default;

    return function(z) {

        // find the two stops which the current z is between
        var low, high;

        for (var i = 0; i < stops.length; i++) {
            var stop = stops[i];
            if (stop[0] <= z) { low = stop; }
            if (stop[0] > z) {
                high = stop;
                break;
            }
        }

        if (low && high) {
            var zoomDiff = high[0] - low[0];
            var zoomProgress = z - low[0];
            var t = base === 1 ?
                zoomProgress / zoomDiff :
                (Math.pow(base, zoomProgress) - 1) / (Math.pow(base, zoomDiff) - 1);

            return interp(low[1], high[1], t);

        } else if (low) {
            return low[1];

        } else if (high) {
            return high[1];

        } else {
            return 1;
        }
    };
}

function interp(a, b, t) {
    return (a * (1 - t)) + (b * t);
}

},{"../reference/v7.json":56}],53:[function(require,module,exports){

var Reference = require('../reference/v8.json');
var URL = require('url');

function getPropertyReference(propertyName) {
    for (var i = 0; i < Reference.layout.length; i++) {
        for (var key in Reference[Reference.layout[i]]) {
            if (key === propertyName) { return Reference[Reference.layout[i]][key]; }
        }
    }
    for (var i$1 = 0; i$1 < Reference.paint.length; i$1++) {
        for (var key$1 in Reference[Reference.paint[i$1]]) {
            if (key$1 === propertyName) { return Reference[Reference.paint[i$1]][key$1]; }
        }
    }
}

function eachSource(style, callback) {
    for (var k in style.sources) {
        callback(style.sources[k]);
    }
}

function eachLayer(style, callback) {
    for (var k in style.layers) {
        callback(style.layers[k]);
        eachLayer(style.layers[k], callback);
    }
}

function eachLayout(layer, callback) {
    for (var k in layer) {
        if (k.indexOf('layout') === 0) {
            callback(layer[k], k);
        }
    }
}

function eachPaint(layer, callback) {
    for (var k in layer) {
        if (k.indexOf('paint') === 0) {
            callback(layer[k], k);
        }
    }
}

function resolveConstant(style, value) {
    if (typeof value === 'string' && value[0] === '@') {
        return resolveConstant(style, style.constants[value]);
    } else {
        return value;
    }
}

function eachProperty(style, options, callback) {
    if (arguments.length === 2) {
        callback = options;
        options = {};
    }

    options.layout = options.layout === undefined ? true : options.layout;
    options.paint = options.paint === undefined ? true : options.paint;

    function inner(layer, properties) {
        Object.keys(properties).forEach(function (key) {
            callback({
                key: key,
                value: properties[key],
                reference: getPropertyReference(key),
                set: function(x) {
                    properties[key] = x;
                }
            });
        });
    }

    eachLayer(style, function (layer) {
        if (options.paint) {
            eachPaint(layer, function (paint) {
                inner(layer, paint);
            });
        }
        if (options.layout) {
            eachLayout(layer, function (layout) {
                inner(layer, layout);
            });
        }
    });
}

function isFunction(value) {
    return Array.isArray(value.stops);
}

function renameProperty(obj, from, to) {
    obj[to] = obj[from]; delete obj[from];
}

module.exports = function(style) {
    style.version = 8;

    // Rename properties, reverse coordinates in source and layers
    eachSource(style, function (source) {
        if (source.type === 'video' && source.url !== undefined) {
            renameProperty(source, 'url', 'urls');
        }
        if (source.type === 'video') {
            source.coordinates.forEach(function (coord) {
                return coord.reverse();
            });
        }
    });

    eachLayer(style, function (layer) {
        eachLayout(layer, function (layout) {
            if (layout['symbol-min-distance'] !== undefined) {
                renameProperty(layout, 'symbol-min-distance', 'symbol-spacing');
            }
        });

        eachPaint(layer, function (paint) {
            if (paint['background-image'] !== undefined) {
                renameProperty(paint, 'background-image', 'background-pattern');
            }
            if (paint['line-image'] !== undefined) {
                renameProperty(paint, 'line-image', 'line-pattern');
            }
            if (paint['fill-image'] !== undefined) {
                renameProperty(paint, 'fill-image', 'fill-pattern');
            }
        });
    });

    // Inline Constants
    eachProperty(style, function (property) {
        var value = resolveConstant(style, property.value);

        if (isFunction(value)) {
            value.stops.forEach(function (stop) {
                stop[1] = resolveConstant(style, stop[1]);
            });
        }

        property.set(value);
    });
    delete style.constants;

    eachLayer(style, function (layer) {
        // get rid of text-max-size, icon-max-size
        // turn text-size, icon-size into layout properties
        // https://github.com/mapbox/mapbox-gl-style-spec/issues/255

        eachLayout(layer, function (layout) {
            delete layout['text-max-size'];
            delete layout['icon-max-size'];
        });

        eachPaint(layer, function (paint) {
            if (paint['text-size']) {
                if (!layer.layout) { layer.layout = {}; }
                layer.layout['text-size'] = paint['text-size'];
                delete paint['text-size'];
            }

            if (paint['icon-size']) {
                if (!layer.layout) { layer.layout = {}; }
                layer.layout['icon-size'] = paint['icon-size'];
                delete paint['icon-size'];
            }
        });
    });

    function migrateFontstackURL(input) {
        var inputParsed = URL.parse(input);
        var inputPathnameParts = inputParsed.pathname.split('/');

        if (inputParsed.protocol !== 'mapbox:') {
            return input;

        } else if (inputParsed.hostname === 'fontstack') {
            assert(decodeURI(inputParsed.pathname) === '/{fontstack}/{range}.pbf');
            return 'mapbox://fonts/mapbox/{fontstack}/{range}.pbf';

        } else if (inputParsed.hostname === 'fonts') {
            assert(inputPathnameParts[1] === 'v1');
            assert(decodeURI(inputPathnameParts[3]) === '{fontstack}');
            assert(decodeURI(inputPathnameParts[4]) === '{range}.pbf');
            return ("mapbox://fonts/" + (inputPathnameParts[2]) + "/{fontstack}/{range}.pbf");

        } else {
            assert(false);
        }

        function assert(predicate) {
            if (!predicate) {
                throw new Error(("Invalid font url: \"" + input + "\""));
            }
        }
    }

    if (style.glyphs) {
        style.glyphs = migrateFontstackURL(style.glyphs);
    }

    function migrateFontStack(font) {
        function splitAndTrim(string) {
            return string.split(',').map(function (s) {
                return s.trim();
            });
        }

        if (Array.isArray(font)) {
            // Assume it's a previously migrated font-array.
            return font;

        } else if (typeof font === 'string') {
            return splitAndTrim(font);

        } else if (typeof font === 'object') {
            font.stops.forEach(function (stop) {
                stop[1] = splitAndTrim(stop[1]);
            });
            return font;

        } else {
            throw new Error("unexpected font value");
        }
    }

    eachLayer(style, function (layer) {
        eachLayout(layer, function (layout) {
            if (layout['text-font']) {
                layout['text-font'] = migrateFontStack(layout['text-font']);
            }
        });
    });

    // Reverse order of symbol layers. This is an imperfect migration.
    //
    // The order of a symbol layer in the layers list affects two things:
    // - how it is drawn relative to other layers (like oneway arrows below bridges)
    // - the placement priority compared to other layers
    //
    // It's impossible to reverse the placement priority without breaking the draw order
    // in some cases. This migration only reverses the order of symbol layers that
    // are above all other types of layers.
    //
    // Symbol layers that are at the top of the map preserve their priority.
    // Symbol layers that are below another type (line, fill) of layer preserve their draw order.

    var firstSymbolLayer = 0;
    for (var i = style.layers.length - 1; i >= 0; i--) {
        var layer = style.layers[i];
        if (layer.type !== 'symbol') {
            firstSymbolLayer = i + 1;
            break;
        }
    }

    var symbolLayers = style.layers.splice(firstSymbolLayer);
    symbolLayers.reverse();
    style.layers = style.layers.concat(symbolLayers);

    return style;
};

},{"../reference/v8.json":57,"url":94}],54:[function(require,module,exports){

module.exports = require('./v8.json');

},{"./v8.json":57}],55:[function(require,module,exports){
module.exports={
  "$version": 6,
  "$root": {
    "version": {
      "required": true,
      "type": "enum",
      "values": [
        6
      ],
      "doc": "Stylesheet version number. Must be 6."
    },
    "constants": {
      "type": "constants",
      "doc": "An object of constants to be referenced in layers."
    },
    "sources": {
      "required": true,
      "type": "sources",
      "doc": "Data source specifications."
    },
    "sprite": {
      "type": "string",
      "doc": "A base URL for retrieving the sprite image and metadata. The extensions `.png`, `.json` and scale factor `@2x.png` will be automatically appended."
    },
    "glyphs": {
      "type": "string",
      "doc": "A URL template for loading signed-distance-field glyph sets in PBF format. Valid tokens are {fontstack} and {range}."
    },
    "transition": {
      "type": "transition",
      "doc": "A global transition definition to use as a default across properties."
    },
    "layers": {
      "required": true,
      "type": "array",
      "value": "layer",
      "doc": "Layers will be drawn in the order of this array."
    }
  },
  "constants": {
    "*": {
      "type": "*",
      "doc": "A constant that will be replaced verbatim in the referencing place. This can be anything, including objects and arrays. All variable names must be prefixed with an `@` symbol."
    }
  },
  "sources": {
    "*": {
      "type": "source",
      "doc": "Specification of a data source. For vector and raster sources, either TileJSON or a URL to a TileJSON must be provided. For GeoJSON and video sources, a URL must be provided."
    }
  },
  "source": [
    "source_tile",
    "source_geojson",
    "source_video"
  ],
  "source_tile": {
    "type": {
      "required": true,
      "type": "enum",
      "values": [
        "vector",
        "raster"
      ],
      "doc": "The data type of the source."
    },
    "url": {
      "type": "string",
      "doc": "A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<mapid>`."
    },
    "tiles": {
      "type": "array",
      "value": "string",
      "doc": "An array of one or more tile source URLs, as in the TileJSON spec."
    },
    "minzoom": {
      "type": "number",
      "default": 0,
      "doc": "Minimum zoom level for which tiles are available, as in the TileJSON spec."
    },
    "maxzoom": {
      "type": "number",
      "default": 22,
      "doc": "Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels."
    },
    "tileSize": {
      "type": "number",
      "default": 512,
      "units": "pixels",
      "doc": "The minimum visual size to display tiles for this layer. Only configurable for raster layers."
    },
    "*": {
      "type": "*",
      "doc": "Other keys to configure the data source."
    }
  },
  "source_geojson": {
    "type": {
      "required": true,
      "type": "enum",
      "values": [
        "geojson"
      ]
    },
    "data": {
      "type": "*"
    }
  },
  "source_video": {
    "type": {
      "required": true,
      "type": "enum",
      "values": [
        "video"
      ]
    },
    "url": {
      "required": true,
      "type": "array",
      "value": "string",
      "doc": "URLs to video content in order of preferred format."
    },
    "coordinates": {
      "required": true,
      "type": "array",
      "length": 4,
      "value": {
        "type": "array",
        "length": 2,
        "value": "number"
      }
    }
  },
  "layer": {
    "id": {
      "type": "string",
      "doc": "Unique layer name."
    },
    "type": {
      "type": "enum",
      "values": [
        "fill",
        "line",
        "symbol",
        "raster",
        "background"
      ],
      "doc": "Rendering type of this layer."
    },
    "ref": {
      "type": "string",
      "doc": "References another layer to copy `type`, `source`, `source-layer`, `minzoom`, `maxzoom`, `filter`, and `layout` properties from. This allows the layers to share processing and be more efficient."
    },
    "source": {
      "type": "string",
      "doc": "Name of a source description to be used for this layer."
    },
    "source-layer": {
      "type": "string",
      "doc": "Layer to use from a vector tile source. Required if the source supports multiple layers."
    },
    "minzoom": {
      "type": "number",
      "minimum": 0,
      "maximum": 22,
      "doc": "The minimum zoom level on which the layer gets parsed and appears on."
    },
    "maxzoom": {
      "type": "number",
      "minimum": 0,
      "maximum": 22,
      "doc": "The maximum zoom level on which the layer gets parsed and appears on."
    },
    "interactive": {
      "type": "boolean",
      "doc": "Enable querying of feature data from this layer for interactivity.",
      "default": false
    },
    "filter": {
      "type": "filter",
      "doc": "A expression specifying conditions on source features. Only features that match the filter are displayed."
    },
    "layers": {
      "type": "array",
      "value": "layer",
      "doc": "If `type` is `raster`, the child layers are composited together onto the previous level layer level."
    },
    "layout": {
      "type": "layout",
      "doc": "Layout properties for the layer."
    },
    "paint": {
      "type": "paint",
      "doc": "Default paint properties for this layer."
    },
    "paint.*": {
      "type": "paint",
      "doc": "Class-specific paint properties for this layer. The class name is the part after the first dot."
    }
  },
  "layout": [
    "layout_fill",
    "layout_line",
    "layout_symbol",
    "layout_raster",
    "layout_background"
  ],
  "layout_background": {
  },
  "layout_fill": {
  },
  "layout_line": {
    "line-cap": {
      "type": "enum",
      "values": [
        "butt",
        "round",
        "square"
      ],
      "default": "butt",
      "doc": "The display of line endings."
    },
    "line-join": {
      "type": "enum",
      "values": [
        "bevel",
        "round",
        "miter"
      ],
      "default": "miter",
      "doc": "The display of lines when joining."
    },
    "line-miter-limit": {
      "type": "number",
      "default": 2,
      "doc": "Used to automatically convert miter joins to bevel joins for sharp angles.",
      "requires": [
        {
          "line-join": "miter"
        }
      ]
    },
    "line-round-limit": {
      "type": "number",
      "default": 1,
      "doc": "Used to automatically convert round joins to miter joins for shallow angles.",
      "requires": [
        {
          "line-join": "round"
        }
      ]
    }
  },
  "layout_symbol": {
    "symbol-placement": {
      "type": "enum",
      "values": [
          "point",
          "line"
      ],
      "default": "point",
      "doc": "Label placement relative to its geometry. `line` can only be used on LineStrings and Polygons."
    },
    "symbol-min-distance": {
      "type": "number",
      "default": 250,
      "minimum": 1,
      "units": "pixels",
      "doc": "Minimum distance between two symbol anchors.",
      "requires": [
        {
          "symbol-placement": "line"
        }
      ]
    },
    "symbol-avoid-edges": {
      "type": "boolean",
      "default": false,
      "doc": "If true, the symbols will not cross tile edges to avoid mutual collisions. Recommended in layers that don't have enough padding in the vector tile to prevent collisions, or if it is a point symbol layer placed after a line symbol layer."
    },
    "icon-allow-overlap": {
      "type": "boolean",
      "default": false,
      "doc": "If true, the icon will be visible even if it collides with other icons and text.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-ignore-placement": {
      "type": "boolean",
      "default": false,
      "doc": "If true, the icon won't affect placement of other icons and text.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-optional": {
      "type": "boolean",
      "default": false,
      "doc": "If true, text can be shown without its corresponding icon.",
      "requires": [
        "icon-image",
        "text-field"
      ]
    },
    "icon-rotation-alignment": {
      "type": "enum",
      "values": [
        "map",
        "viewport"
      ],
      "default": "viewport",
      "doc": "Orientation of icon when map is rotated.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-max-size": {
      "type": "number",
      "default": 1,
      "minimum": 0,
      "doc": "The maximum factor to scale the icon.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-image": {
      "type": "string",
      "doc": "A string with {tokens} replaced, referencing the data property to pull from.",
      "tokens": true
    },
    "icon-rotate": {
      "type": "number",
      "default": 0,
      "period": 360,
      "units": "degrees",
      "doc": "Rotates the icon clockwise.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-padding": {
      "type": "number",
      "default": 2,
      "minimum": 0,
      "units": "pixels",
      "doc": "Padding value around icon bounding box to avoid icon collisions.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-keep-upright": {
      "type": "boolean",
      "default": false,
      "doc": "If true, the icon may be flipped to prevent it from being rendered upside-down",
      "requires": [
        "icon-image",
        {
          "icon-rotation-alignment": "map"
        }
      ]
    },
    "icon-offset": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        0,
        0
      ],
      "doc": "Icon's offset distance. Values are [x, y] where negatives indicate left and up, respectively.",
      "requires": [
        "icon-image"
      ]
    },
    "text-rotation-alignment": {
      "type": "enum",
      "values": [
        "map",
        "viewport"
      ],
      "default": "viewport",
      "doc": "Orientation of icon or text when map is rotated.",
      "requires": [
        "text-field"
      ]
    },
    "text-field": {
      "type": "string",
      "default": "",
      "tokens": true,
      "doc": "Value to use for a text label. Feature properties are specified using tokens like {field_name}."
    },
    "text-font": {
      "type": "string",
      "default": "Open Sans Regular, Arial Unicode MS Regular",
      "doc": "Font stack to use for displaying text.",
      "requires": [
        "text-field"
      ]
    },
    "text-max-size": {
      "type": "number",
      "default": 16,
      "minimum": 0,
      "units": "pixels",
      "doc": "The maximum size text will be laid out, to calculate collisions with.",
      "requires": [
        "text-field"
      ]
    },
    "text-max-width": {
      "type": "number",
      "default": 15,
      "minimum": 0,
      "units": "em",
      "doc": "The maximum line width for text wrapping.",
      "requires": [
        "text-field"
      ]
    },
    "text-line-height": {
      "type": "number",
      "default": 1.2,
      "units": "em",
      "doc": "Text leading value for multi-line text.",
      "requires": [
        "text-field"
      ]
    },
    "text-letter-spacing": {
      "type": "number",
      "default": 0,
      "units": "em",
      "doc": "Text kerning value.",
      "requires": [
        "text-field"
      ]
    },
    "text-justify": {
      "type": "enum",
      "values": [
        "left",
        "center",
        "right"
      ],
      "default": "center",
      "doc": "Text justification options.",
      "requires": [
        "text-field"
      ]
    },
    "text-anchor": {
      "type": "enum",
      "values": [
        "center",
        "left",
        "right",
        "top",
        "bottom",
        "top-left",
        "top-right",
        "bottom-left",
        "bottom-right"
      ],
      "default": "center",
      "doc": "Which part of the text to place closest to the anchor.",
      "requires": [
        "text-field"
      ]
    },
    "text-max-angle": {
      "type": "number",
      "default": 45,
      "units": "degrees",
      "doc": "Maximum angle change between adjacent characters.",
      "requires": [
        "text-field",
        {
          "symbol-placement": "line"
        }
      ]
    },
    "text-rotate": {
      "type": "number",
      "default": 0,
      "period": 360,
      "units": "degrees",
      "doc": "Rotates the text clockwise.",
      "requires": [
        "text-field"
      ]
    },
    "text-padding": {
      "type": "number",
      "default": 2,
      "minimum": 0,
      "units": "pixels",
      "doc": "Padding value around text bounding box to avoid label collisions.",
      "requires": [
        "text-field"
      ]
    },
    "text-keep-upright": {
      "type": "boolean",
      "default": true,
      "doc": "If true, the text may be flipped vertically to prevent it from being rendered upside-down.",
      "requires": [
        "text-field",
        {
          "text-rotation-alignment": "map"
        }
      ]
    },
    "text-transform": {
      "type": "enum",
      "values": [
        "none",
        "uppercase",
        "lowercase"
      ],
      "default": "none",
      "doc": "Specifies how to capitalize text, similar to the CSS `text-transform` property.",
      "requires": [
        "text-field"
      ]
    },
    "text-offset": {
      "type": "array",
      "doc": "Specifies the distance that text is offset from its anchor horizontally and vertically.",
      "value": "number",
      "units": "ems",
      "length": 2,
      "default": [
        0,
        0
      ],
      "requires": [
        "text-field"
      ]
    },
    "text-allow-overlap": {
      "type": "boolean",
      "default": false,
      "doc": "If true, the text will be visible even if it collides with other icons and labels.",
      "requires": [
        "text-field"
      ]
    },
    "text-ignore-placement": {
      "type": "boolean",
      "default": false,
      "doc": "If true, the text won't affect placement of other icons and labels.",
      "requires": [
        "text-field"
      ]
    },
    "text-optional": {
      "type": "boolean",
      "default": false,
      "doc": "If true, icons can be shown without their corresponding text.",
      "requires": [
        "text-field",
        "icon-image"
      ]
    }
  },
  "layout_raster": {
    "raster-size": {
      "type": "number",
      "default": 256,
      "minimum": 0,
      "maximum": 3855,
      "units": "pixels",
      "doc": "The texture image size at which vector layers will be rasterized. Will scale to match the visual tile size."
    },
    "raster-blur": {
      "type": "number",
      "default": 0,
      "minimum": 0,
      "units": "pixels",
      "doc": "Blur radius applied to the raster texture before display."
    }
  },
  "filter": {
    "type": "array",
    "value": "*"
  },
  "filter_operator": {
    "type": "enum",
    "values": [
      "==",
      "!=",
      ">",
      ">=",
      "<",
      "<=",
      "in",
      "!in",
      "all",
      "any",
      "none"
    ]
  },
  "geometry_type": {
    "type": "enum",
    "values": [
      "Point",
      "LineString",
      "Polygon"
    ]
  },
  "function": {
    "stops": {
      "type": "array",
      "required": true,
      "doc": "An array of stops.",
      "value": "function_stop"
    },
    "base": {
      "type": "number",
      "default": 1,
      "minimum": 0,
      "doc": "The exponential base of the interpolation curve. It controls the rate at which the result increases. Higher values make the result increase more towards the high end of the range. With `1` the stops are interpolated linearly."
    }
  },
  "function_stop": {
    "type": "array",
    "minimum": 0,
    "maximum": 22,
    "value": [
      "number",
      "color"
    ],
    "length": 2,
    "doc": "Zoom level and value pair."
  },
  "paint": [
    "paint_fill",
    "paint_line",
    "paint_symbol",
    "paint_raster",
    "paint_background"
  ],
  "paint_fill": {
    "fill-antialias": {
      "type": "boolean",
      "default": true,
      "function": true,
      "doc": "Whether or not the fill should be antialiased."
    },
    "fill-opacity": {
      "type": "number",
      "function": true,
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "doc": "The opacity given to the fill color.",
      "transition": true
    },
    "fill-color": {
      "type": "color",
      "default": "#000000",
      "doc": "The color of the fill.",
      "function": true,
      "transition": true,
      "requires": [
        {
          "!": "fill-image"
        }
      ]
    },
    "fill-outline-color": {
      "type": "color",
      "doc": "The outline color of the fill. Matches the value of `fill-color` if unspecified.",
      "function": true,
      "transition": true,
      "requires": [
        {
          "!": "fill-image"
        },
        {
          "fill-antialias": true
        }
      ]
    },
    "fill-translate": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        0,
        0
      ],
      "function": true,
      "transition": true,
      "units": "pixels",
      "doc": "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively."
    },
    "fill-translate-anchor": {
      "type": "enum",
      "values": [
        "map",
        "viewport"
      ],
      "doc": "Control whether the translation is relative to the map (north) or viewport (screen)",
      "default": "map",
      "requires": [
        "fill-translate"
      ]
    },
    "fill-image": {
      "type": "string",
      "doc": "Name of image in sprite to use for drawing image fills."
    }
  },
  "paint_line": {
    "line-opacity": {
      "type": "number",
      "doc": "The opacity at which the line will be drawn.",
      "function": true,
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "transition": true
    },
    "line-color": {
      "type": "color",
      "doc": "The color with which the line will be drawn.",
      "default": "#000000",
      "function": true,
      "transition": true,
      "requires": [
        {
          "!": "line-image"
        }
      ]
    },
    "line-translate": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        0,
        0
      ],
      "function": true,
      "transition": true,
      "units": "pixels",
      "doc": "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively."
    },
    "line-translate-anchor": {
      "type": "enum",
      "values": [
        "map",
        "viewport"
      ],
      "doc": "Control whether the translation is relative to the map (north) or viewport (screen)",
      "default": "map",
      "requires": [
        "line-translate"
      ]
    },
    "line-width": {
      "type": "number",
      "default": 1,
      "minimum": 0,
      "function": true,
      "transition": true,
      "units": "pixels",
      "doc": "Stroke thickness."
    },
    "line-gap-width": {
      "type": "number",
      "default": 0,
      "minimum": 0,
      "doc": "Draws a line casing outside of a line's actual path. Value indicates the width of the inner gap.",
      "function": true,
      "transition": true,
      "units": "pixels"
    },
    "line-blur": {
      "type": "number",
      "default": 0,
      "minimum": 0,
      "function": true,
      "transition": true,
      "units": "pixels",
      "doc": "Blur applied to the line, in pixels."
    },
    "line-dasharray": {
      "type": "array",
      "value": "number",
      "doc": "Specifies the size and gap between dashes in a line.",
      "length": 2,
      "default": [
        1,
        -1
      ],
      "minimum": 0,
      "function": true,
      "transition": true,
      "requires": [
        {
          "!": "line-image"
        }
      ]
    },
    "line-image": {
      "type": "string",
      "doc": "Name of image in sprite to use for drawing image lines."
    }
  },
  "paint_symbol": {
    "icon-opacity": {
      "doc": "The opacity at which the icon will be drawn.",
      "type": "number",
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "function": true,
      "transition": true,
      "requires": [
        "icon-image"
      ]
    },
    "icon-size": {
      "type": "number",
      "default": 1,
      "function": true,
      "transition": true,
      "doc": "Scale factor for icon. 1 is original size, 3 triples the size.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-color": {
      "type": "color",
      "default": "#000000",
      "function": true,
      "transition": true,
      "doc": "The color of the icon. This can only be used with sdf icons.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-halo-color": {
      "type": "color",
      "default": "rgba(0, 0, 0, 0)",
      "function": true,
      "transition": true,
      "doc": "The color of the icon's halo. Icon halos can only be used with sdf icons.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-halo-width": {
      "type": "number",
      "default": 0,
      "minimum": 0,
      "function": true,
      "transition": true,
      "units": "pixels",
      "doc": "Distance of halo to the icon outline.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-halo-blur": {
      "type": "number",
      "default": 0,
      "minimum": 0,
      "function": true,
      "transition": true,
      "units": "pixels",
      "doc": "Fade out the halo towards the outside.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-translate": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        0,
        0
      ],
      "function": true,
      "transition": true,
      "units": "pixels",
      "doc": "An icon's offset distance. Values are [x, y] where negatives indicate left and up, respectively.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-translate-anchor": {
      "type": "enum",
      "values": [
        "map",
        "viewport"
      ],
      "doc": "Control whether the translation is relative to the map (north) or viewport (screen)",
      "default": "map",
      "requires": [
        "icon-image",
        "icon-translate"
      ]
    },
    "text-opacity": {
      "type": "number",
      "doc": "The opacity at which the text will be drawn.",
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "function": true,
      "transition": true,
      "requires": [
        "text-field"
      ]
    },
    "text-size": {
      "type": "number",
      "default": 16,
      "minimum": 0,
      "function": true,
      "transition": true,
      "units": "pixels",
      "doc": "Font size. If unspecified, the text will be as big as allowed by the layer definition.",
      "requires": [
        "text-field"
      ]
    },
    "text-color": {
      "type": "color",
      "doc": "The color with which the text will be drawn.",
      "default": "#000000",
      "function": true,
      "transition": true,
      "requires": [
        "text-field"
      ]
    },
    "text-halo-color": {
      "type": "color",
      "default": "rgba(0, 0, 0, 0)",
      "function": true,
      "transition": true,
      "doc": "The color of the text's halo, which helps it stand out from backgrounds.",
      "requires": [
        "text-field"
      ]
    },
    "text-halo-width": {
      "type": "number",
      "default": 0,
      "minimum": 0,
      "function": true,
      "transition": true,
      "units": "pixels",
      "doc": "Distance of halo to the font outline. Max text halo width is 1/4 of the font-size.",
      "requires": [
        "text-field"
      ]
    },
    "text-halo-blur": {
      "type": "number",
      "default": 0,
      "minimum": 0,
      "function": true,
      "transition": true,
      "units": "pixels",
      "doc": "The halo's fadeout distance towards the outside.",
      "requires": [
        "text-field"
      ]
    },
    "text-translate": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        0,
        0
      ],
      "function": true,
      "transition": true,
      "units": "pixels",
      "doc": "Label offset. Values are [x, y] where negatives indicate left and up, respectively.",
      "requires": [
        "text-field"
      ]
    },
    "text-translate-anchor": {
      "type": "enum",
      "values": [
        "map",
        "viewport"
      ],
      "doc": "Control whether the translation is relative to the map (north) or viewport (screen)",
      "default": "map",
      "requires": [
        "text-field",
        "text-translate"
      ]
    }
  },
  "paint_raster": {
    "raster-opacity": {
      "type": "number",
      "doc": "The opacity at which the image will be drawn.",
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "transition": true
    },
    "raster-hue-rotate": {
      "type": "number",
      "default": 0,
      "period": 360,
      "function": true,
      "transition": true,
      "units": "degrees",
      "doc": "Rotates hues around the color wheel."
    },
    "raster-brightness": {
      "type": "array",
      "value": "number",
      "doc": "Increase or reduce the brightness of the image. First value is the minimum, second is the maximum brightness.",
      "length": 2,
      "default": [
        0,
        1
      ],
      "function": true,
      "transition": true
    },
    "raster-saturation": {
      "type": "number",
      "doc": "Increase or reduce the saturation of the image.",
      "default": 0,
      "minimum": -1,
      "maximum": 1,
      "function": true,
      "transition": true
    },
    "raster-contrast": {
      "type": "number",
      "doc": "Increase or reduce the contrast of the image.",
      "default": 0,
      "minimum": -1,
      "maximum": 1,
      "function": true,
      "transition": true
    },
    "raster-fade-duration": {
      "type": "number",
      "default": 300,
      "minimum": 0,
      "function": true,
      "transition": true,
      "units": "milliseconds",
      "doc": "Fade duration when a new tile is added."
    }
  },
  "paint_background": {
    "background-color": {
      "type": "color",
      "default": "#000000",
      "doc": "The color with which the background will be drawn.",
      "function": true,
      "transition": true,
      "requires": [
        {
          "!": "background-image"
        }
      ]
    },
    "background-image": {
      "type": "string",
      "doc": "Optionally an image which is drawn as the background."
    },
    "background-opacity": {
      "type": "number",
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "doc": "The opacity at which the background will be drawn.",
      "function": true,
      "transition": true
    }
  },
  "transition": {
    "duration": {
      "type": "number",
      "default": 300,
      "minimum": 0,
      "units": "milliseconds",
      "doc": "Time allotted for transitions to complete."
    },
    "delay": {
      "type": "number",
      "default": 0,
      "minimum": 0,
      "units": "milliseconds",
      "doc": "Length of time before a transition begins."
    }
  }
}

},{}],56:[function(require,module,exports){
module.exports={
  "$version": 7,
  "$root": {
    "version": {
      "required": true,
      "type": "enum",
      "values": [
        7
      ],
      "doc": "Stylesheet version number. Must be 7."
    },
    "name": {
      "type": "string",
      "doc": "A human-readable name for the style."
    },
    "constants": {
      "type": "constants",
      "doc": "An object of constants to be referenced in layers."
    },
    "sources": {
      "required": true,
      "type": "sources",
      "doc": "Data source specifications."
    },
    "sprite": {
      "type": "string",
      "doc": "A base URL for retrieving the sprite image and metadata. The extensions `.png`, `.json` and scale factor `@2x.png` will be automatically appended."
    },
    "glyphs": {
      "type": "string",
      "doc": "A URL template for loading signed-distance-field glyph sets in PBF format. Valid tokens are {fontstack} and {range}."
    },
    "transition": {
      "type": "transition",
      "doc": "A global transition definition to use as a default across properties."
    },
    "layers": {
      "required": true,
      "type": "array",
      "value": "layer",
      "doc": "Layers will be drawn in the order of this array."
    }
  },
  "constants": {
    "*": {
      "type": "*",
      "doc": "A constant that will be replaced verbatim in the referencing place. This can be anything, including objects and arrays. All variable names must be prefixed with an `@` symbol."
    }
  },
  "sources": {
    "*": {
      "type": "source",
      "doc": "Specification of a data source. For vector and raster sources, either TileJSON or a URL to a TileJSON must be provided. For GeoJSON and video sources, a URL must be provided."
    }
  },
  "source": [
    "source_tile",
    "source_geojson",
    "source_video"
  ],
  "source_tile": {
    "type": {
      "required": true,
      "type": "enum",
      "values": [
        "vector",
        "raster"
      ],
      "doc": "The data type of the source."
    },
    "url": {
      "type": "string",
      "doc": "A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<mapid>`."
    },
    "tiles": {
      "type": "array",
      "value": "string",
      "doc": "An array of one or more tile source URLs, as in the TileJSON spec."
    },
    "minzoom": {
      "type": "number",
      "default": 0,
      "doc": "Minimum zoom level for which tiles are available, as in the TileJSON spec."
    },
    "maxzoom": {
      "type": "number",
      "default": 22,
      "doc": "Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels."
    },
    "tileSize": {
      "type": "number",
      "default": 512,
      "units": "pixels",
      "doc": "The minimum visual size to display tiles for this layer. Only configurable for raster layers."
    },
    "*": {
      "type": "*",
      "doc": "Other keys to configure the data source."
    }
  },
  "source_geojson": {
    "type": {
      "required": true,
      "type": "enum",
      "values": [
        "geojson"
      ]
    },
    "data": {
      "type": "*"
    }
  },
  "source_video": {
    "type": {
      "required": true,
      "type": "enum",
      "values": [
        "video"
      ]
    },
    "url": {
      "required": true,
      "type": "array",
      "value": "string",
      "doc": "URLs to video content in order of preferred format."
    },
    "coordinates": {
      "required": true,
      "type": "array",
      "length": 4,
      "value": {
        "type": "array",
        "length": 2,
        "value": "number"
      }
    }
  },
  "layer": {
    "id": {
      "type": "string",
      "doc": "Unique layer name."
    },
    "type": {
      "type": "enum",
      "values": [
        "fill",
        "line",
        "symbol",
        "raster",
        "background"
      ],
      "doc": "Rendering type of this layer."
    },
    "ref": {
      "type": "string",
      "doc": "References another layer to copy `type`, `source`, `source-layer`, `minzoom`, `maxzoom`, `filter`, and `layout` properties from. This allows the layers to share processing and be more efficient."
    },
    "source": {
      "type": "string",
      "doc": "Name of a source description to be used for this layer."
    },
    "source-layer": {
      "type": "string",
      "doc": "Layer to use from a vector tile source. Required if the source supports multiple layers."
    },
    "minzoom": {
      "type": "number",
      "minimum": 0,
      "maximum": 22,
      "doc": "The minimum zoom level on which the layer gets parsed and appears on."
    },
    "maxzoom": {
      "type": "number",
      "minimum": 0,
      "maximum": 22,
      "doc": "The maximum zoom level on which the layer gets parsed and appears on."
    },
    "interactive": {
      "type": "boolean",
      "doc": "Enable querying of feature data from this layer for interactivity.",
      "default": false
    },
    "filter": {
      "type": "filter",
      "doc": "A expression specifying conditions on source features. Only features that match the filter are displayed."
    },
    "layout": {
      "type": "layout",
      "doc": "Layout properties for the layer."
    },
    "paint": {
      "type": "paint",
      "doc": "Default paint properties for this layer."
    },
    "paint.*": {
      "type": "paint",
      "doc": "Class-specific paint properties for this layer. The class name is the part after the first dot."
    }
  },
  "layout": [
    "layout_fill",
    "layout_line",
    "layout_symbol",
    "layout_raster",
    "layout_background"
  ],
  "layout_background": {
    "visibility": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "visible",
        "none"
      ],
      "default": "visible",
      "doc": "The display of this layer. `none` hides this layer."
    }
  },
  "layout_fill": {
    "visibility": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "visible",
        "none"
      ],
      "default": "visible",
      "doc": "The display of this layer. `none` hides this layer."
    }
  },
  "layout_line": {
    "line-cap": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "butt",
        "round",
        "square"
      ],
      "default": "butt",
      "doc": "The display of line endings."
    },
    "line-join": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "bevel",
        "round",
        "miter"
      ],
      "default": "miter",
      "doc": "The display of lines when joining."
    },
    "line-miter-limit": {
      "type": "number",
      "default": 2,
      "function": "interpolated",
      "doc": "Used to automatically convert miter joins to bevel joins for sharp angles.",
      "requires": [
        {
          "line-join": "miter"
        }
      ]
    },
    "line-round-limit": {
      "type": "number",
      "default": 1,
      "function": "interpolated",
      "doc": "Used to automatically convert round joins to miter joins for shallow angles.",
      "requires": [
        {
          "line-join": "round"
        }
      ]
    },
    "visibility": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "visible",
        "none"
      ],
      "default": "visible",
      "doc": "The display of this layer. `none` hides this layer."
    }
  },
  "layout_symbol": {
    "symbol-placement": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
          "point",
          "line"
      ],
      "default": "point",
      "doc": "Label placement relative to its geometry. `line` can only be used on LineStrings and Polygons."
    },
    "symbol-min-distance": {
      "type": "number",
      "default": 250,
      "minimum": 1,
      "function": "interpolated",
      "units": "pixels",
      "doc": "Minimum distance between two symbol anchors.",
      "requires": [
        {
          "symbol-placement": "line"
        }
      ]
    },
    "symbol-avoid-edges": {
      "type": "boolean",
      "function": "piecewise-constant",
      "default": false,
      "doc": "If true, the symbols will not cross tile edges to avoid mutual collisions. Recommended in layers that don't have enough padding in the vector tile to prevent collisions, or if it is a point symbol layer placed after a line symbol layer."
    },
    "icon-allow-overlap": {
      "type": "boolean",
      "function": "piecewise-constant",
      "default": false,
      "doc": "If true, the icon will be visible even if it collides with other icons and text.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-ignore-placement": {
      "type": "boolean",
      "function": "piecewise-constant",
      "default": false,
      "doc": "If true, the icon won't affect placement of other icons and text.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-optional": {
      "type": "boolean",
      "function": "piecewise-constant",
      "default": false,
      "doc": "If true, the symbol will appear without its icon, in spaces where the icon would make it too large to fit.",
      "requires": [
        "icon-image",
        "text-field"
      ]
    },
    "icon-rotation-alignment": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "map",
        "viewport"
      ],
      "default": "viewport",
      "doc": "Orientation of icon when map is rotated.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-max-size": {
      "type": "number",
      "default": 1,
      "minimum": 0,
      "function": "interpolated",
      "doc": "The maximum factor to scale the icon.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-image": {
      "type": "string",
      "function": "piecewise-constant",
      "doc": "A string with {tokens} replaced, referencing the data property to pull from.",
      "tokens": true
    },
    "icon-rotate": {
      "type": "number",
      "default": 0,
      "period": 360,
      "function": "interpolated",
      "units": "degrees",
      "doc": "Rotates the icon clockwise.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-padding": {
      "type": "number",
      "default": 2,
      "minimum": 0,
      "function": "interpolated",
      "units": "pixels",
      "doc": "Padding value around icon bounding box to avoid icon collisions.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-keep-upright": {
      "type": "boolean",
      "function": "piecewise-constant",
      "default": false,
      "doc": "If true, the icon may be flipped to prevent it from being rendered upside-down",
      "requires": [
        "icon-image",
        {
          "icon-rotation-alignment": "map"
        }
      ]
    },
    "icon-offset": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        0,
        0
      ],
      "function": "interpolated",
      "doc": "Icon's offset distance. Values are [x, y] where negatives indicate left and up, respectively.",
      "requires": [
        "icon-image"
      ]
    },
    "text-rotation-alignment": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "map",
        "viewport"
      ],
      "default": "viewport",
      "doc": "Orientation of icon or text when map is rotated.",
      "requires": [
        "text-field"
      ]
    },
    "text-field": {
      "type": "string",
      "function": "piecewise-constant",
      "default": "",
      "tokens": true,
      "doc": "Value to use for a text label. Feature properties are specified using tokens like {field_name}."
    },
    "text-font": {
      "type": "string",
      "function": "piecewise-constant",
      "default": "Open Sans Regular, Arial Unicode MS Regular",
      "doc": "Font stack to use for displaying text.",
      "requires": [
        "text-field"
      ]
    },
    "text-max-size": {
      "type": "number",
      "default": 16,
      "minimum": 0,
      "units": "pixels",
      "function": "interpolated",
      "doc": "The maximum size text will be laid out, to calculate collisions with.",
      "requires": [
        "text-field"
      ]
    },
    "text-max-width": {
      "type": "number",
      "default": 15,
      "minimum": 0,
      "units": "em",
      "function": "interpolated",
      "doc": "The maximum line width for text wrapping.",
      "requires": [
        "text-field"
      ]
    },
    "text-line-height": {
      "type": "number",
      "default": 1.2,
      "units": "em",
      "function": "interpolated",
      "doc": "Text leading value for multi-line text.",
      "requires": [
        "text-field"
      ]
    },
    "text-letter-spacing": {
      "type": "number",
      "default": 0,
      "units": "em",
      "function": "interpolated",
      "doc": "Text kerning value.",
      "requires": [
        "text-field"
      ]
    },
    "text-justify": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "left",
        "center",
        "right"
      ],
      "default": "center",
      "doc": "Text justification options.",
      "requires": [
        "text-field"
      ]
    },
    "text-anchor": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "center",
        "left",
        "right",
        "top",
        "bottom",
        "top-left",
        "top-right",
        "bottom-left",
        "bottom-right"
      ],
      "default": "center",
      "doc": "Which part of the text to place closest to the anchor.",
      "requires": [
        "text-field"
      ]
    },
    "text-max-angle": {
      "type": "number",
      "default": 45,
      "units": "degrees",
      "function": "interpolated",
      "doc": "Maximum angle change between adjacent characters.",
      "requires": [
        "text-field",
        {
          "symbol-placement": "line"
        }
      ]
    },
    "text-rotate": {
      "type": "number",
      "default": 0,
      "period": 360,
      "units": "degrees",
      "function": "interpolated",
      "doc": "Rotates the text clockwise.",
      "requires": [
        "text-field"
      ]
    },
    "text-padding": {
      "type": "number",
      "default": 2,
      "minimum": 0,
      "units": "pixels",
      "function": "interpolated",
      "doc": "Padding value around text bounding box to avoid label collisions.",
      "requires": [
        "text-field"
      ]
    },
    "text-keep-upright": {
      "type": "boolean",
      "function": "piecewise-constant",
      "default": true,
      "doc": "If true, the text may be flipped vertically to prevent it from being rendered upside-down.",
      "requires": [
        "text-field",
        {
          "text-rotation-alignment": "map"
        }
      ]
    },
    "text-transform": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "none",
        "uppercase",
        "lowercase"
      ],
      "default": "none",
      "doc": "Specifies how to capitalize text, similar to the CSS `text-transform` property.",
      "requires": [
        "text-field"
      ]
    },
    "text-offset": {
      "type": "array",
      "doc": "Specifies the distance that text is offset from its anchor horizontally and vertically.",
      "value": "number",
      "units": "ems",
      "function": "interpolated",
      "length": 2,
      "default": [
        0,
        0
      ],
      "requires": [
        "text-field"
      ]
    },
    "text-allow-overlap": {
      "type": "boolean",
      "function": "piecewise-constant",
      "default": false,
      "doc": "If true, the text will be visible even if it collides with other icons and labels.",
      "requires": [
        "text-field"
      ]
    },
    "text-ignore-placement": {
      "type": "boolean",
      "function": "piecewise-constant",
      "default": false,
      "doc": "If true, the text won't affect placement of other icons and labels.",
      "requires": [
        "text-field"
      ]
    },
    "text-optional": {
      "type": "boolean",
      "function": "piecewise-constant",
      "default": false,
      "doc": "If true, the symbol will appear without its text, in spaces where the text would make it too large to fit.",
      "requires": [
        "text-field",
        "icon-image"
      ]
    },
    "visibility": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "visible",
        "none"
      ],
      "default": "visible",
      "doc": "The display of this layer. `none` hides this layer."
    }
  },
  "layout_raster": {
    "visibility": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "visible",
        "none"
      ],
      "default": "visible",
      "doc": "The display of this layer. `none` hides this layer."
    }
  },
  "filter": {
    "type": "array",
    "value": "*"
  },
  "filter_operator": {
    "type": "enum",
    "values": [
      "==",
      "!=",
      ">",
      ">=",
      "<",
      "<=",
      "in",
      "!in",
      "all",
      "any",
      "none"
    ]
  },
  "geometry_type": {
    "type": "enum",
    "values": [
      "Point",
      "LineString",
      "Polygon"
    ]
  },
  "function": {
    "stops": {
      "type": "array",
      "required": true,
      "doc": "An array of stops.",
      "value": "function_stop"
    },
    "base": {
      "type": "number",
      "default": 1,
      "minimum": 0,
      "doc": "The exponential base of the interpolation curve. It controls the rate at which the result increases. Higher values make the result increase more towards the high end of the range. With `1` the stops are interpolated linearly."
    }
  },
  "function_stop": {
    "type": "array",
    "minimum": 0,
    "maximum": 22,
    "value": [
      "number",
      "color"
    ],
    "length": 2,
    "doc": "Zoom level and value pair."
  },
  "paint": [
    "paint_fill",
    "paint_line",
    "paint_symbol",
    "paint_raster",
    "paint_background"
  ],
  "paint_fill": {
    "fill-antialias": {
      "type": "boolean",
      "function": "piecewise-constant",
      "default": true,
      "doc": "Whether or not the fill should be antialiased."
    },
    "fill-opacity": {
      "type": "number",
      "function": "interpolated",
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "doc": "The opacity given to the fill color.",
      "transition": true
    },
    "fill-color": {
      "type": "color",
      "default": "#000000",
      "doc": "The color of the fill.",
      "function": "interpolated",
      "transition": true,
      "requires": [
        {
          "!": "fill-image"
        }
      ]
    },
    "fill-outline-color": {
      "type": "color",
      "doc": "The outline color of the fill. Matches the value of `fill-color` if unspecified.",
      "function": "interpolated",
      "transition": true,
      "requires": [
        {
          "!": "fill-image"
        },
        {
          "fill-antialias": true
        }
      ]
    },
    "fill-translate": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        0,
        0
      ],
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively."
    },
    "fill-translate-anchor": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "map",
        "viewport"
      ],
      "doc": "Control whether the translation is relative to the map (north) or viewport (screen)",
      "default": "map",
      "requires": [
        "fill-translate"
      ]
    },
    "fill-image": {
      "type": "string",
      "function": "piecewise-constant",
      "transition": true,
      "doc": "Name of image in sprite to use for drawing image fills."
    }
  },
  "paint_line": {
    "line-opacity": {
      "type": "number",
      "doc": "The opacity at which the line will be drawn.",
      "function": "interpolated",
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "transition": true
    },
    "line-color": {
      "type": "color",
      "doc": "The color with which the line will be drawn.",
      "default": "#000000",
      "function": "interpolated",
      "transition": true,
      "requires": [
        {
          "!": "line-image"
        }
      ]
    },
    "line-translate": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        0,
        0
      ],
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively."
    },
    "line-translate-anchor": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "map",
        "viewport"
      ],
      "doc": "Control whether the translation is relative to the map (north) or viewport (screen)",
      "default": "map",
      "requires": [
        "line-translate"
      ]
    },
    "line-width": {
      "type": "number",
      "default": 1,
      "minimum": 0,
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "Stroke thickness."
    },
    "line-gap-width": {
      "type": "number",
      "default": 0,
      "minimum": 0,
      "doc": "Draws a line casing outside of a line's actual path. Value indicates the width of the inner gap.",
      "function": "interpolated",
      "transition": true,
      "units": "pixels"
    },
    "line-blur": {
      "type": "number",
      "default": 0,
      "minimum": 0,
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "Blur applied to the line, in pixels."
    },
    "line-dasharray": {
      "type": "array",
      "function": "piecewise-constant",
      "value": "number",
      "doc": "Specifies the lengths of the alternating dashes and gaps that form the dash pattern. The lengths are later scaled by the line width. To convert a dash length to pixels, multiply the length by the current line width.",
      "minimum": 0,
      "transition": true,
      "units": "line widths",
      "requires": [
        {
          "!": "line-image"
        }
      ]
    },
    "line-image": {
      "type": "string",
      "function": "piecewise-constant",
      "transition": true,
      "doc": "Name of image in sprite to use for drawing image lines."
    }
  },
  "paint_symbol": {
    "icon-opacity": {
      "doc": "The opacity at which the icon will be drawn.",
      "type": "number",
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "function": "interpolated",
      "transition": true,
      "requires": [
        "icon-image"
      ]
    },
    "icon-size": {
      "type": "number",
      "default": 1,
      "function": "interpolated",
      "transition": true,
      "doc": "Scale factor for icon. 1 is original size, 3 triples the size.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-color": {
      "type": "color",
      "default": "#000000",
      "function": "interpolated",
      "transition": true,
      "doc": "The color of the icon. This can only be used with sdf icons.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-halo-color": {
      "type": "color",
      "default": "rgba(0, 0, 0, 0)",
      "function": "interpolated",
      "transition": true,
      "doc": "The color of the icon's halo. Icon halos can only be used with sdf icons.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-halo-width": {
      "type": "number",
      "default": 0,
      "minimum": 0,
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "Distance of halo to the icon outline.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-halo-blur": {
      "type": "number",
      "default": 0,
      "minimum": 0,
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "Fade out the halo towards the outside.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-translate": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        0,
        0
      ],
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "An icon's offset distance. Values are [x, y] where negatives indicate left and up, respectively.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-translate-anchor": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "map",
        "viewport"
      ],
      "doc": "Control whether the translation is relative to the map (north) or viewport (screen)",
      "default": "map",
      "requires": [
        "icon-image",
        "icon-translate"
      ]
    },
    "text-opacity": {
      "type": "number",
      "doc": "The opacity at which the text will be drawn.",
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "function": "interpolated",
      "transition": true,
      "requires": [
        "text-field"
      ]
    },
    "text-size": {
      "type": "number",
      "default": 16,
      "minimum": 0,
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "Font size. If unspecified, the text will be as big as allowed by the layer definition.",
      "requires": [
        "text-field"
      ]
    },
    "text-color": {
      "type": "color",
      "doc": "The color with which the text will be drawn.",
      "default": "#000000",
      "function": "interpolated",
      "transition": true,
      "requires": [
        "text-field"
      ]
    },
    "text-halo-color": {
      "type": "color",
      "default": "rgba(0, 0, 0, 0)",
      "function": "interpolated",
      "transition": true,
      "doc": "The color of the text's halo, which helps it stand out from backgrounds.",
      "requires": [
        "text-field"
      ]
    },
    "text-halo-width": {
      "type": "number",
      "default": 0,
      "minimum": 0,
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "Distance of halo to the font outline. Max text halo width is 1/4 of the font-size.",
      "requires": [
        "text-field"
      ]
    },
    "text-halo-blur": {
      "type": "number",
      "default": 0,
      "minimum": 0,
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "The halo's fadeout distance towards the outside.",
      "requires": [
        "text-field"
      ]
    },
    "text-translate": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        0,
        0
      ],
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "Label offset. Values are [x, y] where negatives indicate left and up, respectively.",
      "requires": [
        "text-field"
      ]
    },
    "text-translate-anchor": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "map",
        "viewport"
      ],
      "doc": "Control whether the translation is relative to the map (north) or viewport (screen)",
      "default": "map",
      "requires": [
        "text-field",
        "text-translate"
      ]
    }
  },
  "paint_raster": {
    "raster-opacity": {
      "type": "number",
      "doc": "The opacity at which the image will be drawn.",
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "function": "interpolated",
      "transition": true
    },
    "raster-hue-rotate": {
      "type": "number",
      "default": 0,
      "period": 360,
      "function": "interpolated",
      "transition": true,
      "units": "degrees",
      "doc": "Rotates hues around the color wheel."
    },
    "raster-brightness-min": {
      "type": "number",
      "function": "interpolated",
      "doc": "Increase or reduce the brightness of the image. The value is the minimum brightness.",
      "default": 0,
      "minimum": 0,
      "maximum": 1,
      "transition": true
    },
    "raster-brightness-max": {
      "type": "number",
      "function": "interpolated",
      "doc": "Increase or reduce the brightness of the image. The value is the maximum brightness.",
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "transition": true
    },
    "raster-saturation": {
      "type": "number",
      "doc": "Increase or reduce the saturation of the image.",
      "default": 0,
      "minimum": -1,
      "maximum": 1,
      "function": "interpolated",
      "transition": true
    },
    "raster-contrast": {
      "type": "number",
      "doc": "Increase or reduce the contrast of the image.",
      "default": 0,
      "minimum": -1,
      "maximum": 1,
      "function": "interpolated",
      "transition": true
    },
    "raster-fade-duration": {
      "type": "number",
      "default": 300,
      "minimum": 0,
      "function": "interpolated",
      "transition": true,
      "units": "milliseconds",
      "doc": "Fade duration when a new tile is added."
    }
  },
  "paint_background": {
    "background-color": {
      "type": "color",
      "default": "#000000",
      "doc": "The color with which the background will be drawn.",
      "function": "interpolated",
      "transition": true,
      "requires": [
        {
          "!": "background-image"
        }
      ]
    },
    "background-image": {
      "type": "string",
      "function": "piecewise-constant",
      "transition": true,
      "doc": "Optionally an image which is drawn as the background."
    },
    "background-opacity": {
      "type": "number",
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "doc": "The opacity at which the background will be drawn.",
      "function": "interpolated",
      "transition": true
    }
  },
  "transition": {
    "duration": {
      "type": "number",
      "default": 300,
      "minimum": 0,
      "units": "milliseconds",
      "doc": "Time allotted for transitions to complete."
    },
    "delay": {
      "type": "number",
      "default": 0,
      "minimum": 0,
      "units": "milliseconds",
      "doc": "Length of time before a transition begins."
    }
  }
}

},{}],57:[function(require,module,exports){
module.exports={
  "$version": 8,
  "$root": {
    "version": {
      "required": true,
      "type": "enum",
      "values": [8],
      "doc": "Style specification version number. Must be 8.",
      "example": 8
    },
    "name": {
      "type": "string",
      "doc": "A human-readable name for the style.",
      "example": "Bright"
    },
    "metadata": {
      "type": "*",
      "doc": "Arbitrary properties useful to track with the stylesheet, but do not influence rendering. Properties should be prefixed to avoid collisions, like 'mapbox:'."
    },
    "center": {
      "type": "array",
      "value": "number",
      "doc": "Default map center in longitude and latitude.  The style center will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
      "example": [-73.9749, 40.7736]
    },
    "zoom": {
      "type": "number",
      "doc": "Default zoom level.  The style zoom will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
      "example": 12.5
    },
    "bearing": {
      "type": "number",
      "default": 0,
      "period": 360,
      "units": "degrees",
      "doc": "Default bearing, in degrees clockwise from true north.  The style bearing will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
      "example": 29
    },
    "pitch": {
      "type": "number",
      "default": 0,
      "units": "degrees",
      "doc": "Default pitch, in degrees. Zero is perpendicular to the surface, for a look straight down at the map, while a greater value like 60 looks ahead towards the horizon. The style pitch will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
      "example": 50
    },
    "light": {
      "type": "light",
      "doc": "The global light source.",
      "example": {
        "anchor": "viewport",
        "color": "white",
        "intensity": 0.4
      }
    },
    "sources": {
      "required": true,
      "type": "sources",
      "doc": "Data source specifications.",
      "example": {
        "mapbox-streets": {
          "type": "vector",
          "url": "mapbox://mapbox.mapbox-streets-v6"
        }
      }
    },
    "sprite": {
      "type": "string",
      "doc": "A base URL for retrieving the sprite image and metadata. The extensions `.png`, `.json` and scale factor `@2x.png` will be automatically appended. This property is required if any layer uses the `background-pattern`, `fill-pattern`, `line-pattern`, `fill-extrusion-pattern`, or `icon-image` properties.",
      "example": "mapbox://sprites/mapbox/bright-v8"
    },
    "glyphs": {
      "type": "string",
      "doc": "A URL template for loading signed-distance-field glyph sets in PBF format. The URL must include `{fontstack}` and `{range}` tokens. This property is required if any layer uses the `text-field` layout property.",
      "example": "mapbox://fonts/mapbox/{fontstack}/{range}.pbf"
    },
    "transition": {
      "type": "transition",
      "doc": "A global transition definition to use as a default across properties.",
      "example": {
        "duration": 300,
        "delay": 0
      }
    },
    "layers": {
      "required": true,
      "type": "array",
      "value": "layer",
      "doc": "Layers will be drawn in the order of this array.",
      "example": [
        {
          "id": "water",
          "source": "mapbox-streets",
          "source-layer": "water",
          "type": "fill",
          "paint": {
            "fill-color": "#00ffff"
          }
        }
      ]
    }
  },
  "sources": {
    "*": {
      "type": "source",
      "doc": "Specification of a data source. For vector and raster sources, either TileJSON or a URL to a TileJSON must be provided. For image and video sources, a URL must be provided. For GeoJSON sources, a URL or inline GeoJSON must be provided."
    }
  },
  "source": [
    "source_tile",
    "source_geojson",
    "source_video",
    "source_image",
    "source_canvas"
  ],
  "source_tile": {
    "type": {
      "required": true,
      "type": "enum",
      "values": {
        "vector": {
            "doc": "A vector tile source."
        },
        "raster": {
            "doc": "A raster tile source."
        }
      },
      "doc": "The data type of the tile source."
    },
    "url": {
      "type": "string",
      "doc": "A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<mapid>`."
    },
    "tiles": {
      "type": "array",
      "value": "string",
      "doc": "An array of one or more tile source URLs, as in the TileJSON spec."
    },
    "bounds": {
      "type": "array",
      "value": "number",
      "length": 4,
      "default": [-180, -85.0511, 180, 85.0511],
      "doc": "An array containing the longitude and latitude of the southwest and northeast corners of the source's bounding box in the following order: `[sw.lng, sw.lat, ne.lng, ne.lat]`. When this property is included in a source, no tiles outside of the given bounds are requested by Mapbox GL."
    },
    "minzoom": {
      "type": "number",
      "default": 0,
      "doc": "Minimum zoom level for which tiles are available, as in the TileJSON spec."
    },
    "maxzoom": {
      "type": "number",
      "default": 22,
      "doc": "Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels."
    },
    "tileSize": {
      "type": "number",
      "default": 512,
      "units": "pixels",
      "doc": "The minimum visual size to display tiles for this layer. Only configurable for raster layers."
    },
    "*": {
      "type": "*",
      "doc": "Other keys to configure the data source."
    }
  },
  "source_geojson": {
    "type": {
      "required": true,
      "type": "enum",
      "values": {
        "geojson": {
            "doc": "A GeoJSON data source."
        }
      },
      "doc": "The data type of the GeoJSON source."
    },
    "data": {
      "type": "*",
      "doc": "A URL to a GeoJSON file, or inline GeoJSON."
    },
    "maxzoom": {
      "type": "number",
      "default": 18,
      "doc": "Maximum zoom level at which to create vector tiles (higher means greater detail at high zoom levels)."
    },
    "buffer": {
      "type": "number",
      "default": 128,
      "maximum": 512,
      "minimum": 0,
      "doc": "Size of the tile buffer on each side. A value of 0 produces no buffer. A value of 512 produces a buffer as wide as the tile itself. Larger values produce fewer rendering artifacts near tile edges and slower performance."
    },
    "tolerance": {
      "type": "number",
      "default": 0.375,
      "doc": "Douglas-Peucker simplification tolerance (higher means simpler geometries and faster performance)."
    },
    "cluster": {
      "type": "boolean",
      "default": false,
      "doc": "If the data is a collection of point features, setting this to true clusters the points by radius into groups."
    },
    "clusterRadius": {
      "type": "number",
      "default": 50,
      "minimum": 0,
      "doc": "Radius of each cluster if clustering is enabled. A value of 512 indicates a radius equal to the width of a tile."
    },
    "clusterMaxZoom": {
      "type": "number",
      "doc": "Max zoom on which to cluster points if clustering is enabled. Defaults to one zoom less than maxzoom (so that last zoom features are not clustered)."
    }
  },
  "source_video": {
    "type": {
      "required": true,
      "type": "enum",
      "values": {
        "video": {
            "doc": "A video data source."
        }
      },
      "doc": "The data type of the video source."
    },
    "urls": {
      "required": true,
      "type": "array",
      "value": "string",
      "doc": "URLs to video content in order of preferred format."
    },
    "coordinates": {
      "required": true,
      "doc": "Corners of video specified in longitude, latitude pairs.",
      "type": "array",
      "length": 4,
      "value": {
        "type": "array",
        "length": 2,
        "value": "number",
        "doc": "A single longitude, latitude pair."
      }
    }
  },
  "source_image": {
    "type": {
      "required": true,
      "type": "enum",
      "values": {
        "image": {
            "doc": "An image data source."
        }
      },
      "doc": "The data type of the image source."
    },
    "url": {
      "required": true,
      "type": "string",
      "doc": "URL that points to an image."
    },
    "coordinates": {
      "required": true,
      "doc": "Corners of image specified in longitude, latitude pairs.",
      "type": "array",
      "length": 4,
      "value": {
        "type": "array",
        "length": 2,
        "value": "number",
        "doc": "A single longitude, latitude pair."
      }
    }
  },
  "source_canvas": {
    "type": {
      "required": true,
      "type": "enum",
      "values": {
        "canvas": {
          "doc": "A canvas data source."
        }
      },
      "doc": "The data type of the canvas source."
    },
    "coordinates": {
      "required": true,
      "doc": "Corners of canvas specified in longitude, latitude pairs.",
      "type": "array",
      "length": 4,
      "value": {
        "type": "array",
        "length": 2,
        "value": "number",
        "doc": "A single longitude, latitude pair."
      }
    },
    "animate": {
      "type": "boolean",
      "default": "true",
      "doc": "Whether the canvas source is animated. If the canvas is static, `animate` should be set to `false` to improve performance."
    },
    "canvas": {
      "type": "string",
      "required": true,
      "doc": "HTML ID of the canvas from which to read pixels."
    }
  },
  "layer": {
    "id": {
      "type": "string",
      "doc": "Unique layer name.",
      "required": true
    },
    "type": {
      "type": "enum",
      "values": {
        "fill": {
          "doc": "A filled polygon with an optional stroked border.",
          "sdk-support": {
            "basic functionality": {
              "js": "0.10.0",
              "android": "2.0.1",
              "ios": "2.0.0",
              "macos": "0.1.0"
            }
          }
        },
        "line": {
          "doc": "A stroked line.",
          "sdk-support": {
            "basic functionality": {
              "js": "0.10.0",
              "android": "2.0.1",
              "ios": "2.0.0",
              "macos": "0.1.0"
            }
          }
        },
        "symbol": {
          "doc": "An icon or a text label.",
          "sdk-support": {
            "basic functionality": {
              "js": "0.10.0",
              "android": "2.0.1",
              "ios": "2.0.0",
              "macos": "0.1.0"
            }
          }
        },
        "circle": {
          "doc": "A filled circle.",
          "sdk-support": {
            "basic functionality": {
              "js": "0.10.0",
              "android": "2.0.1",
              "ios": "2.0.0",
              "macos": "0.1.0"
            }
          }
        },
        "heatmap": {
          "doc": "A heatmap.",
          "sdk-support": {
            "basic functionality": {
              "js": "0.41.0"
            }
          }
        },
        "fill-extrusion": {
          "doc": "An extruded (3D) polygon.",
          "sdk-support": {
            "basic functionality": {
              "js": "0.27.0",
              "android": "5.1.0",
              "ios": "3.6.0",
              "macos": "0.5.0"
            }
          }
        },
        "raster": {
          "doc": "Raster map textures such as satellite imagery.",
          "sdk-support": {
            "basic functionality": {
              "js": "0.10.0",
              "android": "2.0.1",
              "ios": "2.0.0",
              "macos": "0.1.0"
            }
          }
        },
        "background": {
          "doc": "The background color or pattern of the map.",
          "sdk-support": {
            "basic functionality": {
              "js": "0.10.0",
              "android": "2.0.1",
              "ios": "2.0.0",
              "macos": "0.1.0"
            }
          }
        }
      },
      "doc": "Rendering type of this layer."
    },
    "metadata": {
      "type": "*",
      "doc": "Arbitrary properties useful to track with the layer, but do not influence rendering. Properties should be prefixed to avoid collisions, like 'mapbox:'."
    },
    "source": {
      "type": "string",
      "doc": "Name of a source description to be used for this layer."
    },
    "source-layer": {
      "type": "string",
      "doc": "Layer to use from a vector tile source. Required if the source supports multiple layers."
    },
    "minzoom": {
      "type": "number",
      "minimum": 0,
      "maximum": 24,
      "doc": "The minimum zoom level on which the layer gets parsed and appears on."
    },
    "maxzoom": {
      "type": "number",
      "minimum": 0,
      "maximum": 24,
      "doc": "The maximum zoom level on which the layer gets parsed and appears on."
    },
    "filter": {
      "type": "filter",
      "doc": "A expression specifying conditions on source features. Only features that match the filter are displayed."
    },
    "layout": {
      "type": "layout",
      "doc": "Layout properties for the layer."
    },
    "paint": {
      "type": "paint",
      "doc": "Default paint properties for this layer."
    },
    "paint.*": {
      "type": "paint",
      "doc": "[Deprecated] Class-specific paint properties for this layer. The class name is the part after the first dot. Note: style classes are deprecated and will be removed in the next version of this spec."
    }
  },
  "layout": [
    "layout_fill",
    "layout_line",
    "layout_circle",
    "layout_heatmap",
    "layout_fill-extrusion",
    "layout_symbol",
    "layout_raster",
    "layout_background"
  ],
  "layout_background": {
    "visibility": {
      "type": "enum",
      "values": {
        "visible": {
            "doc": "The layer is shown."
        },
        "none": {
            "doc": "The layer is not shown."
        }
      },
      "default": "visible",
      "doc": "Whether this layer is displayed.",
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        }
      }
    }
  },
  "layout_fill": {
    "visibility": {
      "type": "enum",
      "values": {
        "visible": {
            "doc": "The layer is shown."
        },
        "none": {
            "doc": "The layer is not shown."
        }
      },
      "default": "visible",
      "doc": "Whether this layer is displayed.",
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        }
      }
    }
  },
  "layout_circle": {
    "visibility": {
      "type": "enum",
      "values": {
        "visible": {
            "doc": "The layer is shown."
        },
        "none": {
            "doc": "The layer is not shown."
        }
      },
      "default": "visible",
      "doc": "Whether this layer is displayed.",
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        }
      }
    }
  },
  "layout_heatmap": {
    "visibility": {
      "type": "enum",
      "values": {
        "visible": {
            "doc": "The layer is shown."
        },
        "none": {
            "doc": "The layer is not shown."
        }
      },
      "default": "visible",
      "doc": "Whether this layer is displayed.",
      "sdk-support": {
        "basic functionality": {
          "js": "0.41.0"
        }
      }
    }
  },
  "layout_fill-extrusion": {
    "visibility": {
      "type": "enum",
      "values": {
        "visible": {
            "doc": "The layer is shown."
        },
        "none": {
            "doc": "The layer is not shown."
        }
      },
      "default": "visible",
      "doc": "Whether this layer is displayed.",
      "sdk-support": {
        "basic functionality": {
          "js": "0.27.0",
          "android": "5.1.0",
          "ios": "3.6.0",
          "macos": "0.5.0"
        }
      }
    }
  },
  "layout_line": {
    "line-cap": {
      "type": "enum",
      "function": "piecewise-constant",
      "zoom-function": true,
      "values": {
        "butt": {
            "doc": "A cap with a squared-off end which is drawn to the exact endpoint of the line."
        },
        "round": {
            "doc": "A cap with a rounded end which is drawn beyond the endpoint of the line at a radius of one-half of the line's width and centered on the endpoint of the line."
        },
        "square": {
            "doc": "A cap with a squared-off end which is drawn beyond the endpoint of the line at a distance of one-half of the line's width."
        }
      },
      "default": "butt",
      "doc": "The display of line endings.",
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {}
      }
    },
    "line-join": {
      "type": "enum",
      "function": "piecewise-constant",
      "zoom-function": true,
      "property-function": true,
      "values": {
        "bevel": {
            "doc": "A join with a squared-off end which is drawn beyond the endpoint of the line at a distance of one-half of the line's width."
        },
        "round": {
            "doc": "A join with a rounded end which is drawn beyond the endpoint of the line at a radius of one-half of the line's width and centered on the endpoint of the line."
        },
        "miter": {
            "doc": "A join with a sharp, angled corner which is drawn with the outer sides beyond the endpoint of the path until they meet."
        }
      },
      "default": "miter",
      "doc": "The display of lines when joining.",
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {
          "js": "0.40.0"
        }
      }
    },
    "line-miter-limit": {
      "type": "number",
      "default": 2,
      "function": "interpolated",
      "zoom-function": true,
      "doc": "Used to automatically convert miter joins to bevel joins for sharp angles.",
      "requires": [
        {
          "line-join": "miter"
        }
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {}
      }
    },
    "line-round-limit": {
      "type": "number",
      "default": 1.05,
      "function": "interpolated",
      "zoom-function": true,
      "doc": "Used to automatically convert round joins to miter joins for shallow angles.",
      "requires": [
        {
          "line-join": "round"
        }
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {}
      }
    },
    "visibility": {
      "type": "enum",
      "values": {
        "visible": {
            "doc": "The layer is shown."
        },
        "none": {
            "doc": "The layer is not shown."
        }
      },
      "default": "visible",
      "doc": "Whether this layer is displayed.",
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {}
      }
    }
  },
  "layout_symbol": {
    "symbol-placement": {
      "type": "enum",
      "function": "piecewise-constant",
      "zoom-function": true,
      "values": {
          "point": {
              "doc": "The label is placed at the point where the geometry is located."
          },
          "line": {
              "doc": "The label is placed along the line of the geometry. Can only be used on `LineString` and `Polygon` geometries."
          }
      },
      "default": "point",
      "doc": "Label placement relative to its geometry.",
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {}
      }
    },
    "symbol-spacing": {
      "type": "number",
      "default": 250,
      "minimum": 1,
      "function": "interpolated",
      "zoom-function": true,
      "units": "pixels",
      "doc": "Distance between two symbol anchors.",
      "requires": [
        {
          "symbol-placement": "line"
        }
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {}
      }
    },
    "symbol-avoid-edges": {
      "type": "boolean",
      "function": "piecewise-constant",
      "zoom-function": true,
      "default": false,
      "doc": "If true, the symbols will not cross tile edges to avoid mutual collisions. Recommended in layers that don't have enough padding in the vector tile to prevent collisions, or if it is a point symbol layer placed after a line symbol layer.",
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {}
      }
    },
    "icon-allow-overlap": {
      "type": "boolean",
      "function": "piecewise-constant",
      "zoom-function": true,
      "default": false,
      "doc": "If true, the icon will be visible even if it collides with other previously drawn symbols.",
      "requires": [
        "icon-image"
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {}
      }
    },
    "icon-ignore-placement": {
      "type": "boolean",
      "function": "piecewise-constant",
      "zoom-function": true,
      "default": false,
      "doc": "If true, other symbols can be visible even if they collide with the icon.",
      "requires": [
        "icon-image"
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {}
      }
    },
    "icon-optional": {
      "type": "boolean",
      "function": "piecewise-constant",
      "zoom-function": true,
      "default": false,
      "doc": "If true, text will display without their corresponding icons when the icon collides with other symbols and the text does not.",
      "requires": [
        "icon-image",
        "text-field"
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {}
      }
    },
    "icon-rotation-alignment": {
      "type": "enum",
      "function": "piecewise-constant",
      "zoom-function": true,
      "values": {
        "map": {
            "doc": "When `symbol-placement` is set to `point`, aligns icons east-west. When `symbol-placement` is set to `line`, aligns icon x-axes with the line."
        },
        "viewport": {
            "doc": "Produces icons whose x-axes are aligned with the x-axis of the viewport, regardless of the value of `symbol-placement`."
        },
        "auto": {
            "doc": "When `symbol-placement` is set to `point`, this is equivalent to `viewport`. When `symbol-placement` is set to `line`, this is equivalent to `map`."
        }
      },
      "default": "auto",
      "doc": "In combination with `symbol-placement`, determines the rotation behavior of icons.",
      "requires": [
        "icon-image"
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "`auto` value": {
          "js": "0.25.0",
          "android": "4.2.0",
          "ios": "3.4.0",
          "macos": "0.3.0"
        },
        "data-driven styling": {}
      }
    },
    "icon-size": {
      "type": "number",
      "default": 1,
      "minimum": 0,
      "function": "interpolated",
      "zoom-function": true,
      "property-function": true,
      "units": "factor of the original icon size",
      "doc": "Scales the original size of the icon by the provided factor. The new pixel size of the image will be the original pixel size multiplied by `icon-size`. 1 is the original size; 3 triples the size of the image.",
      "requires": [
        "icon-image"
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {
          "js": "0.35.0",
          "android": "5.1.0",
          "ios": "3.6.0",
          "macos": "0.5.0"
        }
      }
    },
    "icon-text-fit": {
      "type": "enum",
      "function": "piecewise-constant",
      "zoom-function": true,
      "values": {
        "none": {
            "doc": "The icon is displayed at its intrinsic aspect ratio."
        },
        "width": {
            "doc": "The icon is scaled in the x-dimension to fit the width of the text."
        },
        "height": {
            "doc": "The icon is scaled in the y-dimension to fit the height of the text."
        },
        "both": {
            "doc": "The icon is scaled in both x- and y-dimensions."
        }
      },
      "default": "none",
      "doc": "Scales the icon to fit around the associated text.",
      "requires": [
        "icon-image",
        "text-field"
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.21.0",
          "android": "4.2.0",
          "ios": "3.4.0",
          "macos": "0.2.1"
        },
        "data-driven styling": {}
      }
    },
    "icon-text-fit-padding": {
      "type": "array",
      "value": "number",
      "length": 4,
      "default": [
        0,
        0,
        0,
        0
      ],
      "units": "pixels",
      "function": "interpolated",
      "zoom-function": true,
      "doc": "Size of the additional area added to dimensions determined by `icon-text-fit`, in clockwise order: top, right, bottom, left.",
      "requires": [
        "icon-image",
        "text-field",
        {
          "icon-text-fit": [
            "both",
            "width",
            "height"
          ]
        }
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.21.0",
          "android": "4.2.0",
          "ios": "3.4.0",
          "macos": "0.2.1"
        },
        "data-driven styling": {}
      }
    },
    "icon-image": {
      "type": "string",
      "function": "piecewise-constant",
      "zoom-function": true,
      "property-function": true,
      "doc": "Name of image in sprite to use for drawing an image background. A string with `{tokens}` replaced, referencing the data property to pull from. (`{token}` replacement is only supported for literal `icon-image` values; not for property functions.)",
      "tokens": true,
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {
          "js": "0.35.0",
          "android": "5.1.0",
          "ios": "3.6.0",
          "macos": "0.5.0"
        }
      }
    },
    "icon-rotate": {
      "type": "number",
      "default": 0,
      "period": 360,
      "function": "interpolated",
      "zoom-function": true,
      "property-function": true,
      "units": "degrees",
      "doc": "Rotates the icon clockwise.",
      "requires": [
        "icon-image"
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {
          "js": "0.21.0",
          "android": "5.0.0",
          "ios": "3.5.0",
          "macos": "0.4.0"
        }
      }
    },
    "icon-padding": {
      "type": "number",
      "default": 2,
      "minimum": 0,
      "function": "interpolated",
      "zoom-function": true,
      "units": "pixels",
      "doc": "Size of the additional area around the icon bounding box used for detecting symbol collisions.",
      "requires": [
        "icon-image"
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {}
      }
    },
    "icon-keep-upright": {
      "type": "boolean",
      "function": "piecewise-constant",
      "zoom-function": true,
      "default": false,
      "doc": "If true, the icon may be flipped to prevent it from being rendered upside-down.",
      "requires": [
        "icon-image",
        {
          "icon-rotation-alignment": "map"
        },
        {
          "symbol-placement": "line"
        }
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {}
      }
    },
    "icon-offset": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        0,
        0
      ],
      "function": "interpolated",
      "zoom-function": true,
      "property-function": true,
      "doc": "Offset distance of icon from its anchor. Positive values indicate right and down, while negative values indicate left and up. When combined with `icon-rotate` the offset will be as if the rotated direction was up.",
      "requires": [
        "icon-image"
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {
          "js": "0.29.0",
          "android": "5.0.0",
          "ios": "3.5.0",
          "macos": "0.4.0"
        }
      }
    },
    "icon-anchor": {
      "type": "enum",
      "function": "piecewise-constant",
      "zoom-function": true,
      "property-function": true,
      "values": {
        "center": {
            "doc": "The center of the icon is placed closest to the anchor."
        },
        "left": {
            "doc": "The left side of the icon is placed closest to the anchor."
        },
        "right": {
            "doc": "The right side of the icon is placed closest to the anchor."
        },
        "top": {
            "doc": "The top of the icon is placed closest to the anchor."
        },
        "bottom": {
            "doc": "The bottom of the icon is placed closest to the anchor."
        },
        "top-left": {
            "doc": "The top left corner of the icon is placed closest to the anchor."
        },
        "top-right": {
            "doc": "The top right corner of the icon is placed closest to the anchor."
        },
        "bottom-left": {
            "doc": "The bottom left corner of the icon is placed closest to the anchor."
        },
        "bottom-right": {
            "doc": "The bottom right corner of the icon is placed closest to the anchor."
        }
      },
      "default": "center",
      "doc": "Part of the icon placed closest to the anchor.",
      "requires": [
        "icon-image"
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.40.0"
        },
        "data-driven styling": {
          "js": "0.40.0"
        }
      }
    },
    "icon-pitch-alignment": {
      "type": "enum",
      "function": "piecewise-constant",
      "zoom-function": true,
      "values": {
        "map": {
            "doc": "The icon is aligned to the plane of the map."
        },
        "viewport": {
            "doc": "The icon is aligned to the plane of the viewport."
        },
        "auto": {
            "doc": "Automatically matches the value of `icon-rotation-alignment`."
        }
      },
      "default": "auto",
      "doc": "Orientation of icon when map is pitched.",
      "requires": [
        "icon-image"
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.39.0"
        },
        "data-driven styling": {}
      }
    },
    "text-pitch-alignment": {
      "type": "enum",
      "function": "piecewise-constant",
      "zoom-function": true,
      "values": {
        "map": {
            "doc": "The text is aligned to the plane of the map."
        },
        "viewport": {
            "doc": "The text is aligned to the plane of the viewport."
        },
        "auto": {
            "doc": "Automatically matches the value of `text-rotation-alignment`."
        }
      },
      "default": "auto",
      "doc": "Orientation of text when map is pitched.",
      "requires": [
        "text-field"
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.21.0",
          "android": "4.2.0",
          "ios": "3.4.0",
          "macos": "0.2.1"
        },
        "`auto` value": {
          "js": "0.25.0",
          "android": "4.2.0",
          "ios": "3.4.0",
          "macos": "0.3.0"
        },
        "data-driven styling": {}
      }
    },
    "text-rotation-alignment": {
      "type": "enum",
      "function": "piecewise-constant",
      "zoom-function": true,
      "values": {
        "map": {
            "doc": "When `symbol-placement` is set to `point`, aligns text east-west. When `symbol-placement` is set to `line`, aligns text x-axes with the line."
        },
        "viewport": {
            "doc": "Produces glyphs whose x-axes are aligned with the x-axis of the viewport, regardless of the value of `symbol-placement`."
        },
        "auto": {
            "doc": "When `symbol-placement` is set to `point`, this is equivalent to `viewport`. When `symbol-placement` is set to `line`, this is equivalent to `map`."
        }
      },
      "default": "auto",
      "doc": "In combination with `symbol-placement`, determines the rotation behavior of the individual glyphs forming the text.",
      "requires": [
        "text-field"
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "`auto` value": {
          "js": "0.25.0",
          "android": "4.2.0",
          "ios": "3.4.0",
          "macos": "0.3.0"
        },
        "data-driven styling": {}
      }
    },
    "text-field": {
      "type": "string",
      "function": "piecewise-constant",
      "zoom-function": true,
      "property-function": true,
      "default": "",
      "tokens": true,
      "doc": "Value to use for a text label. Feature properties are specified using tokens like `{field_name}`. (`{token}` replacement is only supported for literal `text-field` values; not for property functions.)",
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {
          "js": "0.33.0",
          "android": "5.0.0",
          "ios": "3.5.0",
          "macos": "0.4.0"
        }
      }
    },
    "text-font": {
      "type": "array",
      "value": "string",
      "function": "piecewise-constant",
      "zoom-function": true,
      "default": ["Open Sans Regular", "Arial Unicode MS Regular"],
      "doc": "Font stack to use for displaying text.",
      "requires": [
        "text-field"
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {}
      }
    },
    "text-size": {
      "type": "number",
      "default": 16,
      "minimum": 0,
      "units": "pixels",
      "function": "interpolated",
      "zoom-function": true,
      "property-function": true,
      "doc": "Font size.",
      "requires": [
        "text-field"
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {
          "js": "0.35.0",
          "android": "5.1.0",
          "ios": "3.6.0",
          "macos": "0.5.0"
        }
      }
    },
    "text-max-width": {
      "type": "number",
      "default": 10,
      "minimum": 0,
      "units": "ems",
      "function": "interpolated",
      "zoom-function": true,
      "property-function": true,
      "doc": "The maximum line width for text wrapping.",
      "requires": [
        "text-field"
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {
            "js": "0.40.0"
        }
      }
    },
    "text-line-height": {
      "type": "number",
      "default": 1.2,
      "units": "ems",
      "function": "interpolated",
      "zoom-function": true,
      "doc": "Text leading value for multi-line text.",
      "requires": [
        "text-field"
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {}
      }
    },
    "text-letter-spacing": {
      "type": "number",
      "default": 0,
      "units": "ems",
      "function": "interpolated",
      "zoom-function": true,
      "property-function": true,
      "doc": "Text tracking amount.",
      "requires": [
        "text-field"
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {
            "js": "0.40.0"
        }
      }
    },
    "text-justify": {
      "type": "enum",
      "function": "piecewise-constant",
      "zoom-function": true,
      "property-function": true,
      "values": {
        "left": {
            "doc": "The text is aligned to the left."
        },
        "center": {
            "doc": "The text is centered."
        },
        "right": {
            "doc": "The text is aligned to the right."
        }
      },
      "default": "center",
      "doc": "Text justification options.",
      "requires": [
        "text-field"
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {
            "js": "0.39.0"
        }
      }
    },
    "text-anchor": {
      "type": "enum",
      "function": "piecewise-constant",
      "zoom-function": true,
      "property-function": true,
      "values": {
        "center": {
            "doc": "The center of the text is placed closest to the anchor."
        },
        "left": {
            "doc": "The left side of the text is placed closest to the anchor."
        },
        "right": {
            "doc": "The right side of the text is placed closest to the anchor."
        },
        "top": {
            "doc": "The top of the text is placed closest to the anchor."
        },
        "bottom": {
            "doc": "The bottom of the text is placed closest to the anchor."
        },
        "top-left": {
            "doc": "The top left corner of the text is placed closest to the anchor."
        },
        "top-right": {
            "doc": "The top right corner of the text is placed closest to the anchor."
        },
        "bottom-left": {
            "doc": "The bottom left corner of the text is placed closest to the anchor."
        },
        "bottom-right": {
            "doc": "The bottom right corner of the text is placed closest to the anchor."
        }
      },
      "default": "center",
      "doc": "Part of the text placed closest to the anchor.",
      "requires": [
        "text-field"
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {
            "js": "0.39.0"
        }
      }
    },
    "text-max-angle": {
      "type": "number",
      "default": 45,
      "units": "degrees",
      "function": "interpolated",
      "zoom-function": true,
      "doc": "Maximum angle change between adjacent characters.",
      "requires": [
        "text-field",
        {
          "symbol-placement": "line"
        }
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {}
      }
    },
    "text-rotate": {
      "type": "number",
      "default": 0,
      "period": 360,
      "units": "degrees",
      "function": "interpolated",
      "zoom-function": true,
      "property-function": true,
      "doc": "Rotates the text clockwise.",
      "requires": [
        "text-field"
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {
          "js": "0.35.0",
          "android": "5.1.0",
          "ios": "3.6.0",
          "macos": "0.5.0"
        }
      }
    },
    "text-padding": {
      "type": "number",
      "default": 2,
      "minimum": 0,
      "units": "pixels",
      "function": "interpolated",
      "zoom-function": true,
      "doc": "Size of the additional area around the text bounding box used for detecting symbol collisions.",
      "requires": [
        "text-field"
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {}
      }
    },
    "text-keep-upright": {
      "type": "boolean",
      "function": "piecewise-constant",
      "zoom-function": true,
      "default": true,
      "doc": "If true, the text may be flipped vertically to prevent it from being rendered upside-down.",
      "requires": [
        "text-field",
        {
          "text-rotation-alignment": "map"
        },
        {
          "symbol-placement": "line"
        }
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {}
      }
    },
    "text-transform": {
      "type": "enum",
      "function": "piecewise-constant",
      "zoom-function": true,
      "property-function": true,
      "values": {
        "none": {
            "doc": "The text is not altered."
        },
        "uppercase": {
            "doc": "Forces all letters to be displayed in uppercase."
        },
        "lowercase": {
            "doc": "Forces all letters to be displayed in lowercase."
        }
      },
      "default": "none",
      "doc": "Specifies how to capitalize text, similar to the CSS `text-transform` property.",
      "requires": [
        "text-field"
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {
          "js": "0.33.0",
          "android": "5.0.0",
          "ios": "3.5.0",
          "macos": "0.4.0"
        }
      }
    },
    "text-offset": {
      "type": "array",
      "doc": "Offset distance of text from its anchor. Positive values indicate right and down, while negative values indicate left and up.",
      "value": "number",
      "units": "ems",
      "function": "interpolated",
      "zoom-function": true,
      "property-function": true,
      "length": 2,
      "default": [
        0,
        0
      ],
      "requires": [
        "text-field"
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {
          "js": "0.35.0",
          "android": "5.1.0",
          "ios": "3.6.0",
          "macos": "0.5.0"
        }
      }
    },
    "text-allow-overlap": {
      "type": "boolean",
      "function": "piecewise-constant",
      "zoom-function": true,
      "default": false,
      "doc": "If true, the text will be visible even if it collides with other previously drawn symbols.",
      "requires": [
        "text-field"
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {}
      }
    },
    "text-ignore-placement": {
      "type": "boolean",
      "function": "piecewise-constant",
      "zoom-function": true,
      "default": false,
      "doc": "If true, other symbols can be visible even if they collide with the text.",
      "requires": [
        "text-field"
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {}
      }
    },
    "text-optional": {
      "type": "boolean",
      "function": "piecewise-constant",
      "zoom-function": true,
      "default": false,
      "doc": "If true, icons will display without their corresponding text when the text collides with other symbols and the icon does not.",
      "requires": [
        "text-field",
        "icon-image"
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {}
      }
    },
    "visibility": {
      "type": "enum",
      "values": {
        "visible": {
            "doc": "The layer is shown."
        },
        "none": {
            "doc": "The layer is not shown."
        }
      },
      "default": "visible",
      "doc": "Whether this layer is displayed.",
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {}
      }
    }
  },
  "layout_raster": {
    "visibility": {
      "type": "enum",
      "values": {
        "visible": {
            "doc": "The layer is shown."
        },
        "none": {
            "doc": "The layer is not shown."
        }
      },
      "default": "visible",
      "doc": "Whether this layer is displayed.",
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {}
      }
    }
  },
  "filter": {
    "type": "array",
    "value": "*",
    "doc": "A filter selects specific features from a layer."
  },
  "filter_operator": {
    "type": "enum",
    "values": {
      "==": {
          "doc": "`[\"==\", key, value]` equality: `feature[key] = value`"
      },
      "!=": {
          "doc": "`[\"!=\", key, value]` inequality: `feature[key]  value`"
      },
      ">": {
          "doc": "`[\">\", key, value]` greater than: `feature[key] > value`"
      },
      ">=": {
          "doc": "`[\">=\", key, value]` greater than or equal: `feature[key]  value`"
      },
      "<": {
          "doc": "`[\"<\", key, value]` less than: `feature[key] < value`"
      },
      "<=": {
          "doc": "`[\"<=\", key, value]` less than or equal: `feature[key]  value`"
      },
      "in": {
          "doc": "`[\"in\", key, v0, ..., vn]` set inclusion: `feature[key]  {v0, ..., vn}`"
      },
      "!in": {
          "doc": "`[\"!in\", key, v0, ..., vn]` set exclusion: `feature[key]  {v0, ..., vn}`"
      },
      "all": {
          "doc": "`[\"all\", f0, ..., fn]` logical `AND`: `f0  ...  fn`"
      },
      "any": {
          "doc": "`[\"any\", f0, ..., fn]` logical `OR`: `f0  ...  fn`"
      },
      "none": {
          "doc": "`[\"none\", f0, ..., fn]` logical `NOR`: `f0  ...  fn`"
      },
      "has": {
          "doc": "`[\"has\", key]` `feature[key]` exists"
      },
      "!has": {
          "doc": "`[\"!has\", key]` `feature[key]` does not exist"
      }
    },
    "doc": "The filter operator."
  },
  "geometry_type": {
    "type": "enum",
    "values": {
      "Point": {
          "doc": "Filter to point geometries."
      },
      "LineString": {
          "doc": "Filter to line geometries."
      },
      "Polygon": {
          "doc": "Filter to polygon geometries."
      }
    },
    "doc": "The geometry type for the filter to select."
  },
  "function": {
    "expression": {
      "type": "expression",
      "doc": "An expression."
    },
    "stops": {
      "type": "array",
      "doc": "An array of stops.",
      "value": "function_stop"
    },
    "base": {
      "type": "number",
      "default": 1,
      "minimum": 0,
      "doc": "The exponential base of the interpolation curve. It controls the rate at which the result increases. Higher values make the result increase more towards the high end of the range. With `1` the stops are interpolated linearly."
    },
    "property": {
      "type": "string",
      "doc": "The name of a feature property to use as the function input.",
      "default": "$zoom"
    },
    "type": {
      "type": "enum",
      "values": {
          "identity": {
              "doc": "Return the input value as the output value."
          },
          "exponential": {
              "doc": "Generate an output by interpolating between stops just less than and just greater than the function input."
          },
          "interval": {
              "doc": "Return the output value of the stop just less than the function input."
          },
          "categorical": {
              "doc": "Return the output value of the stop equal to the function input."
          }
      },
      "doc": "The interpolation strategy to use in function evaluation.",
      "default": "exponential"
    },
    "colorSpace": {
      "type": "enum",
      "values": {
          "rgb": {
              "doc": "Use the RGB color space to interpolate color values"
          },
          "lab": {
              "doc": "Use the LAB color space to interpolate color values."
          },
          "hcl": {
              "doc": "Use the HCL color space to interpolate color values, interpolating the Hue, Chroma, and Luminance channels individually."
          }
      },
      "doc": "The color space in which colors interpolated. Interpolating colors in perceptual color spaces like LAB and HCL tend to produce color ramps that look more consistent and produce colors that can be differentiated more easily than those interpolated in RGB space.",
      "default": "rgb"
    },
    "default": {
      "type": "*",
      "required": false,
      "doc": "A value to serve as a fallback function result when a value isn't otherwise available. It is used in the following circumstances:\n* In categorical functions, when the feature value does not match any of the stop domain values.\n* In property and zoom-and-property functions, when a feature does not contain a value for the specified property.\n* In identity functions, when the feature value is not valid for the style property (for example, if the function is being used for a `circle-color` property but the feature property value is not a string or not a valid color).\n* In interval or exponential property and zoom-and-property functions, when the feature value is not numeric.\nIf no default is provided, the style property's default is used in these circumstances."
    }
  },
  "function_stop": {
    "type": "array",
    "minimum": 0,
    "maximum": 22,
    "value": [
      "number",
      "color"
    ],
    "length": 2,
    "doc": "Zoom level and value pair."
  },
  "expression": {
    "type": "array",
    "value": "*",
    "minimum": 1,
    "doc": "An expression defines a function that can be used for data-driven style properties or feature filters."
  },
  "expression_name": {
    "doc": "",
    "type": "enum",
    "values": {
      "let": {
        "doc": "Binds expressions to named variables, which can then be referenced in the result expression using [\"var\", \"variable_name\"].",
        "group": "Variable binding"
      },
      "var": {
        "doc": "References variable bound using \"let\".",
        "group": "Variable binding"
      },
      "literal": {
        "doc": "Provides a literal array or object value.",
        "group": "Types"
      },
      "array": {
        "doc": "Asserts that the input is an array (optinally with a specific item type and length).",
        "group": "Types"
      },
      "at": {
        "doc": "Retrieves an item from an array.",
        "group": "Lookup"
      },
        "case": {
        "doc": "Yields the value of the first output expression whose corresponding test evaluates to true.",
        "group": "Decision"
      },
      "match": {
        "doc": "Yields the output value whose label value matches the input, or the fallback value if no match is found.",
        "group": "Decision"
      },
      "coalesce": {
        "doc": "Evaluates each expression in turn until the first non-null value is obtained, and returns that value.",
        "group": "Decision"
      },
      "curve": {
        "doc": "Interpolates an output value based on a set of input/output pairs using the specified interpolation strategy. A set of one input and one output value is known as a \"stop.\" Stop inputs must be numeric literals in strictly ascending order.\n\nInterpolation types:\n- `[\"step\"]`: returns the output value of the stop just less than the input , or the first input if the input is less than the first stop.\n- `[\"linear\"]`: interpolates linearly between the pair of stops just less than and just greater than the input .\n- `[\"exponential\", base]`: interpolates exponentially between the stops just less than and just greater than the input . `base` controls the rate at which the output increases: higher values make the output increase more towards the high end of the range. With values close to 1 the output increases linearly.\n- `[\"cubic-bezier\", x1, y2, x2, y2]`: interpolates using the cubic bezier curve defined by the given control points\n\nNote that interpolation types other that \"step\" are only supported when the output type is `number`, `array<number>`, or `Color`.",
        "group": "Ramps, scales, curves"
      },
      "ln2": {
        "doc": "Returns mathematical constant ln(2).",
        "group": "Math"
      },
      "pi": {
        "doc": "Returns the mathematical constant pi.",
        "group": "Math"
      },
      "e": {
        "doc": "Returns the mathematical constant e.",
        "group": "Math"
      },
      "typeof": {
        "doc": "Returns a string describing the type of the given value.",
        "group": "Types"
      },
      "string": {
        "doc": "Asserts that the input value is a String. If multiple values are provided, each one is evaluated in order until a String value is obtained.",
        "group": "Types"
      },
      "number": {
        "doc": "Asserts that the input value is a Number. If multiple values are provided, each one is evaluated in order until a Number value is obtained.",
        "group": "Types"
      },
      "boolean": {
        "doc": "Asserts that the input value is a Boolean. If multiple values are provided, each one is evaluated in order until a Boolean value is obtained.",
        "group": "Types"
      },
      "object": {
        "doc": "Asserts that the input value is an Objects.",
        "group": "Types"
      },
      "to-string": {
        "doc": "Coerces the input value to a String.",
        "group": "Types"
      },
      "to-number": {
        "doc": "Coerces the input value to a Number, if possible. If multiple values are provided, each one is evaluated in order until the first successful conversion is obtained.",
        "group": "Types"
      },
      "to-boolean": {
        "doc": "Coerces the input value to a Boolean.",
        "group": "Types"
      },
      "to-rgba": {
        "doc": "Returns the an array of the given color's r, g, b, a components.",
        "group": "Color"
      },
      "to-color": {
        "doc": "Coerces the input value to a Color. If multiple values are provided, each one is evaluated in order until the first successful conversion is obtained.",
        "group": "Types"
      },
      "rgb": {
        "doc": "Creates a color value from r, g, b components.",
        "group": "Color"
      },
      "rgba": {
        "doc": "Creates a color value from r, g, b, a components.",
        "group": "Color"
      },
      "get": {
        "doc": "Retrieves an the object property value.  If it's not provided, the object argument defaults to [\"properties\"].  Returns null if the requested property is missing from the object.",
        "group": "Lookup"
      },
      "has": {
        "doc": "Tests for the presence of an object property value.  If it's not provided, the object argument defaults to [\"properties\"].",
        "group": "Lookup"
      },
      "length": {
        "doc": "Gets the length of an array or string.",
        "group": "Lookup"
      },
      "properties": {
        "doc": "Gets the feature properties object.  Note that in some cases, it may be more efficient to use [\"get\", \"property_name\"] directly.",
        "group": "Feature data"
      },
      "geometry-type": {
        "doc": "Gets the feature's geometry type: Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon.",
        "group": "Feature data"
      },
      "id": {
        "doc": "Gets the feature's id, if it has one.",
        "group": "Feature data"
      },
      "zoom": {
        "doc": "Gets the current zoom level.  Note that in style layout and paint properties, [\"zoom\"] may only appear as the input to a top-level [\"curve\"] expression.",
        "group": "Zoom"
      },
      "heatmap-density": {
        "doc": "Gets the kernel density estimation of a pixel in a heatmap layer, which is a relative measure of how many data points are crowded around a particular pixel. Can only be used in the `heatmap-color` property.",
        "group": "Heatmap"
      },
      "+": {
        "doc": "",
        "group": "Math"
      },
      "*": {
        "doc": "",
        "group": "Math"
      },
      "-": {
        "doc": "",
        "group": "Math"
      },
      "/": {
        "doc": "",
        "group": "Math"
      },
      "%": {
        "doc": "",
        "group": "Math"
      },
      "^": {
        "doc": "",
        "group": "Math"
      },
      "log10": {
        "doc": "",
        "group": "Math"
      },
      "ln": {
        "doc": "",
        "group": "Math"
      },
      "log2": {
        "doc": "",
        "group": "Math"
      },
      "sin": {
        "doc": "",
        "group": "Math"
      },
      "cos": {
        "doc": "",
        "group": "Math"
      },
      "tan": {
        "doc": "",
        "group": "Math"
      },
      "asin": {
        "doc": "",
        "group": "Math"
      },
      "acos": {
        "doc": "",
        "group": "Math"
      },
      "atan": {
        "doc": "",
        "group": "Math"
      },
      "min": {
        "doc": "",
        "group": "Math"
      },
      "max": {
        "doc": "",
        "group": "Math"
      },
      "==": {
        "doc": "",
        "group": "Decision"
      },
      "!=": {
        "doc": "",
        "group": "Decision"
      },
      ">": {
        "doc": "",
        "group": "Decision"
      },
      "<": {
        "doc": "",
        "group": "Decision"
      },
      ">=": {
        "doc": "",
        "group": "Decision"
      },
      "<=": {
        "doc": "",
        "group": "Decision"
      },
      "all": {
        "doc": "",
        "group": "Decision"
      },
      "any": {
        "doc": "",
        "group": "Decision"
      },
      "!": {
        "doc": "",
        "group": "Decision"
      },
      "upcase": {
        "doc": "",
        "group": "String"
      },
      "downcase": {
        "doc": "",
        "group": "String"
      },
      "concat": {
        "doc": "Concetenate the given strings.",
        "group": "String"
      }
    }
  },
  "light": {
    "anchor": {
      "type": "enum",
      "default": "viewport",
      "values": {
        "map": {
          "doc": "The position of the light source is aligned to the rotation of the map."
        },
        "viewport": {
          "doc": "The position of the light source is aligned to the rotation of the viewport."
        }
      },
      "transition": false,
      "zoom-function": true,
      "property-function": false,
      "function": "piecewise-constant",
      "doc": "Whether extruded geometries are lit relative to the map or viewport.",
      "example": "map",
      "sdk-support": {
        "basic functionality": {
          "js": "0.27.0",
          "android": "5.1.0",
          "ios": "3.6.0",
          "macos": "0.5.0"
        }
      }
    },
    "position": {
      "type": "array",
      "default": [1.15, 210, 30],
      "length": 3,
      "value": "number",
      "transition": true,
      "function": "interpolated",
      "zoom-function": true,
      "property-function": false,
      "doc": "Position of the light source relative to lit (extruded) geometries, in [r radial coordinate, a azimuthal angle, p polar angle] where r indicates the distance from the center of the base of an object to its light, a indicates the position of the light relative to 0 (0 when `light.anchor` is set to `viewport` corresponds to the top of the viewport, or 0 when `light.anchor` is set to `map` corresponds to due north, and degrees proceed clockwise), and p indicates the height of the light (from 0, directly above, to 180, directly below).",
      "example": [1.5, 90, 80],
      "sdk-support": {
        "basic functionality": {
          "js": "0.27.0",
          "android": "5.1.0",
          "ios": "3.6.0",
          "macos": "0.5.0"
        }
      }
    },
    "color": {
      "type": "color",
      "default": "#ffffff",
      "function": "interpolated",
      "zoom-function": true,
      "property-function": false,
      "transition": true,
      "doc": "Color tint for lighting extruded geometries.",
      "sdk-support": {
        "basic functionality": {
          "js": "0.27.0",
          "android": "5.1.0",
          "ios": "3.6.0",
          "macos": "0.5.0"
        }
      }
    },
    "intensity": {
      "type": "number",
      "default": 0.5,
      "minimum": 0,
      "maximum": 1,
      "function": "interpolated",
      "zoom-function": true,
      "property-function": false,
      "transition": true,
      "doc": "Intensity of lighting (on a scale from 0 to 1). Higher numbers will present as more extreme contrast.",
      "sdk-support": {
        "basic functionality": {
          "js": "0.27.0",
          "android": "5.1.0",
          "ios": "3.6.0",
          "macos": "0.5.0"
        }
      }
    }
  },
  "paint": [
    "paint_fill",
    "paint_line",
    "paint_circle",
    "paint_heatmap",
    "paint_fill-extrusion",
    "paint_symbol",
    "paint_raster",
    "paint_background"
  ],
  "paint_fill": {
    "fill-antialias": {
      "type": "boolean",
      "function": "piecewise-constant",
      "zoom-function": true,
      "default": true,
      "doc": "Whether or not the fill should be antialiased.",
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {}
      }
    },
    "fill-opacity": {
      "type": "number",
      "function": "interpolated",
      "zoom-function": true,
      "property-function": true,
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "doc": "The opacity of the entire fill layer. In contrast to the `fill-color`, this value will also affect the 1px stroke around the fill, if the stroke is used.",
      "transition": true,
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {
          "js": "0.21.0",
          "android": "5.0.0",
          "ios": "3.5.0",
          "macos": "0.4.0"
        }
      }
    },
    "fill-color": {
      "type": "color",
      "default": "#000000",
      "doc": "The color of the filled part of this layer. This color can be specified as `rgba` with an alpha component and the color's opacity will not affect the opacity of the 1px stroke, if it is used.",
      "function": "interpolated",
      "zoom-function": true,
      "property-function": true,
      "transition": true,
      "requires": [
        {
          "!": "fill-pattern"
        }
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {
          "js": "0.19.0",
          "android": "5.0.0",
          "ios": "3.5.0",
          "macos": "0.4.0"
        }
      }
    },
    "fill-outline-color": {
      "type": "color",
      "doc": "The outline color of the fill. Matches the value of `fill-color` if unspecified.",
      "function": "interpolated",
      "zoom-function": true,
      "property-function": true,
      "transition": true,
      "requires": [
        {
          "!": "fill-pattern"
        },
        {
          "fill-antialias": true
        }
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {
          "js": "0.19.0",
          "android": "5.0.0",
          "ios": "3.5.0",
          "macos": "0.4.0"
        }
      }
    },
    "fill-translate": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        0,
        0
      ],
      "function": "interpolated",
      "zoom-function": true,
      "transition": true,
      "units": "pixels",
      "doc": "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively.",
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {}
      }
    },
    "fill-translate-anchor": {
      "type": "enum",
      "function": "piecewise-constant",
      "zoom-function": true,
      "values": {
        "map": {
            "doc": "The fill is translated relative to the map."
        },
        "viewport": {
            "doc": "The fill is translated relative to the viewport."
        }
      },
      "doc": "Controls the translation reference point.",
      "default": "map",
      "requires": [
        "fill-translate"
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {}
      }
    },
    "fill-pattern": {
      "type": "string",
      "function": "piecewise-constant",
      "zoom-function": true,
      "transition": true,
      "doc": "Name of image in sprite to use for drawing image fills. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512).",
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {}
      }
    }
  },
  "paint_fill-extrusion": {
    "fill-extrusion-opacity": {
      "type": "number",
      "function": "interpolated",
      "zoom-function": true,
      "property-function": false,
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "doc": "The opacity of the entire fill extrusion layer. This is rendered on a per-layer, not per-feature, basis, and data-driven styling is not available.",
      "transition": true,
      "sdk-support": {
        "basic functionality": {
          "js": "0.27.0",
          "android": "5.1.0",
          "ios": "3.6.0",
          "macos": "0.5.0"
        }
      }
    },
    "fill-extrusion-color": {
      "type": "color",
      "default": "#000000",
      "doc": "The base color of the extruded fill. The extrusion's surfaces will be shaded differently based on this color in combination with the root `light` settings. If this color is specified as `rgba` with an alpha component, the alpha component will be ignored; use `fill-extrusion-opacity` to set layer opacity.",
      "function": "interpolated",
      "zoom-function": true,
      "property-function": true,
      "transition": true,
      "requires": [
        {
          "!": "fill-extrusion-pattern"
        }
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.27.0",
          "android": "5.1.0",
          "ios": "3.6.0",
          "macos": "0.5.0"
        },
        "data-driven styling": {
          "js": "0.27.0",
          "android": "5.1.0",
          "ios": "3.6.0",
          "macos": "0.5.0"
        }
      }
    },
    "fill-extrusion-translate": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        0,
        0
      ],
      "function": "interpolated",
      "zoom-function": true,
      "transition": true,
      "units": "pixels",
      "doc": "The geometry's offset. Values are [x, y] where negatives indicate left and up (on the flat plane), respectively.",
      "sdk-support": {
        "basic functionality": {
          "js": "0.27.0",
          "android": "5.1.0",
          "ios": "3.6.0",
          "macos": "0.5.0"
        },
        "data-driven styling": {}
      }
    },
    "fill-extrusion-translate-anchor": {
      "type": "enum",
      "function": "piecewise-constant",
      "zoom-function": true,
      "values": {
        "map": {
            "doc": "The fill extrusion is translated relative to the map."
        },
        "viewport": {
            "doc": "The fill extrusion is translated relative to the viewport."
        }
      },
      "doc": "Controls the translation reference point.",
      "default": "map",
      "requires": [
        "fill-extrusion-translate"
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.27.0",
          "android": "5.1.0",
          "ios": "3.6.0",
          "macos": "0.5.0"
        },
        "data-driven styling": {}
      }
    },
    "fill-extrusion-pattern": {
      "type": "string",
      "function": "piecewise-constant",
      "zoom-function": true,
      "transition": true,
      "doc": "Name of image in sprite to use for drawing images on extruded fills. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512).",
      "sdk-support": {
        "basic functionality": {
          "js": "0.27.0",
          "android": "5.1.0",
          "ios": "3.6.0",
          "macos": "0.5.0"
        },
        "data-driven styling": {}
      }
    },
    "fill-extrusion-height": {
      "type": "number",
      "function": "interpolated",
      "zoom-function": true,
      "property-function": true,
      "default": 0,
      "minimum": 0,
      "units": "meters",
      "doc": "The height with which to extrude this layer.",
      "transition": true,
      "sdk-support": {
        "basic functionality": {
          "js": "0.27.0",
          "android": "5.1.0",
          "ios": "3.6.0",
          "macos": "0.5.0"
        },
        "data-driven styling": {
          "js": "0.27.0",
          "android": "5.1.0",
          "ios": "3.6.0",
          "macos": "0.5.0"
        }
      }
    },
    "fill-extrusion-base": {
      "type": "number",
      "function": "interpolated",
      "zoom-function": true,
      "property-function": true,
      "default": 0,
      "minimum": 0,
      "units": "meters",
      "doc": "The height with which to extrude the base of this layer. Must be less than or equal to `fill-extrusion-height`.",
      "transition": true,
      "requires": [
        "fill-extrusion-height"
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.27.0",
          "android": "5.1.0",
          "ios": "3.6.0",
          "macos": "0.5.0"
        },
        "data-driven styling": {
          "js": "0.27.0",
          "android": "5.1.0",
          "ios": "3.6.0",
          "macos": "0.5.0"
        }
      }
    }
  },
  "paint_line": {
    "line-opacity": {
      "type": "number",
      "doc": "The opacity at which the line will be drawn.",
      "function": "interpolated",
      "zoom-function": true,
      "property-function": true,
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "transition": true,
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {
          "js": "0.29.0",
          "android": "5.0.0",
          "ios": "3.5.0",
          "macos": "0.4.0"
        }
      }
    },
    "line-color": {
      "type": "color",
      "doc": "The color with which the line will be drawn.",
      "default": "#000000",
      "function": "interpolated",
      "zoom-function": true,
      "property-function": true,
      "transition": true,
      "requires": [
        {
          "!": "line-pattern"
        }
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {
          "js": "0.23.0",
          "android": "5.0.0",
          "ios": "3.5.0",
          "macos": "0.4.0"
        }
      }
    },
    "line-translate": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        0,
        0
      ],
      "function": "interpolated",
      "zoom-function": true,
      "transition": true,
      "units": "pixels",
      "doc": "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively.",
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {}
      }
    },
    "line-translate-anchor": {
      "type": "enum",
      "function": "piecewise-constant",
      "zoom-function": true,
      "values": {
        "map": {
            "doc": "The line is translated relative to the map."
        },
        "viewport": {
            "doc": "The line is translated relative to the viewport."
        }
      },
      "doc": "Controls the translation reference point.",
      "default": "map",
      "requires": [
        "line-translate"
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {}
      }
    },
    "line-width": {
      "type": "number",
      "default": 1,
      "minimum": 0,
      "function": "interpolated",
      "zoom-function": true,
      "property-function": true,
      "transition": true,
      "units": "pixels",
      "doc": "Stroke thickness.",
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {
          "js": "0.39.0"
        }
      }
    },
    "line-gap-width": {
      "type": "number",
      "default": 0,
      "minimum": 0,
      "doc": "Draws a line casing outside of a line's actual path. Value indicates the width of the inner gap.",
      "function": "interpolated",
      "zoom-function": true,
      "property-function": true,
      "transition": true,
      "units": "pixels",
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {
          "js": "0.29.0",
          "android": "5.0.0",
          "ios": "3.5.0",
          "macos": "0.4.0"
        }
      }
    },
    "line-offset": {
      "type": "number",
      "default": 0,
      "doc": "The line's offset. For linear features, a positive value offsets the line to the right, relative to the direction of the line, and a negative value to the left. For polygon features, a positive value results in an inset, and a negative value results in an outset.",
      "function": "interpolated",
      "zoom-function": true,
      "property-function": true,
      "transition": true,
      "units": "pixels",
      "sdk-support": {
        "basic functionality": {
          "js": "0.12.1",
          "android": "3.0.0",
          "ios": "3.1.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {
          "js": "0.29.0",
          "android": "5.0.0",
          "ios": "3.5.0",
          "macos": "0.4.0"
        }
      }
    },
    "line-blur": {
      "type": "number",
      "default": 0,
      "minimum": 0,
      "function": "interpolated",
      "zoom-function": true,
      "property-function": true,
      "transition": true,
      "units": "pixels",
      "doc": "Blur applied to the line, in pixels.",
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {
          "js": "0.29.0",
          "android": "5.0.0",
          "ios": "3.5.0",
          "macos": "0.4.0"
        }
      }
    },
    "line-dasharray": {
      "type": "array",
      "value": "number",
      "function": "piecewise-constant",
      "zoom-function": true,
      "doc": "Specifies the lengths of the alternating dashes and gaps that form the dash pattern. The lengths are later scaled by the line width. To convert a dash length to pixels, multiply the length by the current line width.",
      "minimum": 0,
      "transition": true,
      "units": "line widths",
      "requires": [
        {
          "!": "line-pattern"
        }
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {}
      }
    },
    "line-pattern": {
      "type": "string",
      "function": "piecewise-constant",
      "zoom-function": true,
      "transition": true,
      "doc": "Name of image in sprite to use for drawing image lines. For seamless patterns, image width must be a factor of two (2, 4, 8, ..., 512).",
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {}
      }
    }
  },
  "paint_circle": {
    "circle-radius": {
      "type": "number",
      "default": 5,
      "minimum": 0,
      "function": "interpolated",
      "zoom-function": true,
      "property-function": true,
      "transition": true,
      "units": "pixels",
      "doc": "Circle radius.",
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {
          "js": "0.18.0",
          "android": "5.0.0",
          "ios": "3.5.0",
          "macos": "0.4.0"
        }
      }
    },
    "circle-color": {
      "type": "color",
      "default": "#000000",
      "doc": "The fill color of the circle.",
      "function": "interpolated",
      "zoom-function": true,
      "property-function": true,
      "transition": true,
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {
          "js": "0.18.0",
          "android": "5.0.0",
          "ios": "3.5.0",
          "macos": "0.4.0"
        }
      }
    },
    "circle-blur": {
      "type": "number",
      "default": 0,
      "doc": "Amount to blur the circle. 1 blurs the circle such that only the centerpoint is full opacity.",
      "function": "interpolated",
      "zoom-function": true,
      "property-function": true,
      "transition": true,
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {
          "js": "0.20.0",
          "android": "5.0.0",
          "ios": "3.5.0",
          "macos": "0.4.0"
        }
      }
    },
    "circle-opacity": {
      "type": "number",
      "doc": "The opacity at which the circle will be drawn.",
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "function": "interpolated",
      "zoom-function": true,
      "property-function": true,
      "transition": true,
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {
          "js": "0.20.0",
          "android": "5.0.0",
          "ios": "3.5.0",
          "macos": "0.4.0"
        }
      }
    },
    "circle-translate": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [0, 0],
      "function": "interpolated",
      "zoom-function": true,
      "transition": true,
      "units": "pixels",
      "doc": "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively.",
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {}
      }
    },
    "circle-translate-anchor": {
      "type": "enum",
      "function": "piecewise-constant",
      "zoom-function": true,
      "values": {
        "map": {
            "doc": "The circle is translated relative to the map."
        },
        "viewport": {
            "doc": "The circle is translated relative to the viewport."
        }
      },
      "doc": "Controls the translation reference point.",
      "default": "map",
      "requires": [
        "circle-translate"
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {}
      }
    },
    "circle-pitch-scale": {
      "type": "enum",
      "function": "piecewise-constant",
      "zoom-function": true,
      "values": {
        "map": {
            "doc": "Circles are scaled according to their apparent distance to the camera."
        },
        "viewport": {
            "doc": "Circles are not scaled."
        }
      },
      "default": "map",
      "doc": "Controls the scaling behavior of the circle when the map is pitched.",
      "sdk-support": {
        "basic functionality": {
          "js": "0.21.0",
          "android": "4.2.0",
          "ios": "3.4.0",
          "macos": "0.2.1"
        },
        "data-driven styling": {}
      }
    },
    "circle-pitch-alignment": {
      "type": "enum",
      "function": "piecewise-constant",
      "zoom-function": true,
      "values": {
        "map": {
            "doc": "The circle is aligned to the plane of the map."
        },
        "viewport": {
            "doc": "The circle is aligned to the plane of the viewport."
        }
      },
      "default": "viewport",
      "doc": "Orientation of circle when map is pitched.",
      "sdk-support": {
        "basic functionality": {
          "js": "0.39.0"
        },
        "data-driven styling": {}
      }
    },
    "circle-stroke-width": {
      "type": "number",
      "default": 0,
      "minimum": 0,
      "function": "interpolated",
      "zoom-function": true,
      "property-function": true,
      "transition": true,
      "units": "pixels",
      "doc": "The width of the circle's stroke. Strokes are placed outside of the `circle-radius`.",
      "sdk-support": {
        "basic functionality": {
          "js": "0.29.0",
          "android": "5.0.0",
          "ios": "3.5.0",
          "macos": "0.4.0"
        },
        "data-driven styling": {
          "js": "0.29.0",
          "android": "5.0.0",
          "ios": "3.5.0",
          "macos": "0.4.0"
        }
      }
    },
    "circle-stroke-color": {
      "type": "color",
      "default": "#000000",
      "doc": "The stroke color of the circle.",
      "function": "interpolated",
      "zoom-function": true,
      "property-function": true,
      "transition": true,
      "sdk-support": {
        "basic functionality": {
          "js": "0.29.0",
          "android": "5.0.0",
          "ios": "3.5.0",
          "macos": "0.4.0"
        },
        "data-driven styling": {
          "js": "0.29.0",
          "android": "5.0.0",
          "ios": "3.5.0",
          "macos": "0.4.0"
        }
      }
    },
    "circle-stroke-opacity": {
      "type": "number",
      "doc": "The opacity of the circle's stroke.",
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "function": "interpolated",
      "zoom-function": true,
      "property-function": true,
      "transition": true,
      "sdk-support": {
        "basic functionality": {
          "js": "0.29.0",
          "android": "5.0.0",
          "ios": "3.5.0",
          "macos": "0.4.0"
        },
        "data-driven styling": {
          "js": "0.29.0",
          "android": "5.0.0",
          "ios": "3.5.0",
          "macos": "0.4.0"
        }
      }
    }
  },
  "paint_heatmap": {
    "heatmap-radius": {
      "type": "number",
      "default": 30,
      "minimum": 1,
      "function": "interpolated",
      "zoom-function": true,
      "property-function": false,
      "transition": true,
      "units": "pixels",
      "doc": "Radius of influence of one heatmap point in pixels. Increasing the value makes the heatmap smoother, but less detailed.",
      "sdk-support": {
        "basic functionality": {
          "js": "0.41.0"
        },
        "data-driven styling": {}
      }
    },
    "heatmap-weight": {
      "type": "number",
      "default": 1,
      "minimum": 0,
      "function": "interpolated",
      "zoom-function": true,
      "property-function": true,
      "transition": false,
      "doc": "A measure of how much an individual point contributes to the heatmap. A value of 10 would be equivalent to having 10 points of weight 1 in the same spot. Especially useful when combined with clustering.",
      "sdk-support": {
        "basic functionality": {
          "js": "0.41.0"
        },
        "data-driven styling": {
          "js": "0.41.0"
        }
      }
    },
    "heatmap-intensity": {
      "type": "number",
      "default": 1,
      "minimum": 0,
      "function": "interpolated",
      "zoom-function": true,
      "property-function": false,
      "transition": true,
      "doc": "Similar to `heatmap-weight` but controls the intensity of the heatmap globally. Primarily used for adjusting the heatmap based on zoom level.",
      "sdk-support": {
        "basic functionality": {
          "js": "0.41.0"
        },
        "data-driven styling": {}
      }
    },
    "heatmap-color": {
      "type": "color",
      "default": {
          "stops": [
              [0, "rgba(0, 0, 255, 0)"],
              [0.1, "royalblue"],
              [0.3, "cyan"],
              [0.5, "lime"],
              [0.7, "yellow"],
              [1, "red"]
          ]
      },
      "doc": "Defines the color of each pixel based on its density value in a heatmap. Should be either a stop function with input values ranging from `0` to `1`, or a curve expression with a special `[\"heatmap-density\"]` keyword as the input.",
      "function": "interpolated",
      "zoom-function": true,
      "property-function": false,
      "transition": true,
      "sdk-support": {
        "basic functionality": {
          "js": "0.41.0"
        },
        "data-driven styling": {}
      }
    },
    "heatmap-opacity": {
      "type": "number",
      "doc": "The global opacity at which the heatmap layer will be drawn.",
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "function": "interpolated",
      "zoom-function": true,
      "property-function": false,
      "transition": true,
      "sdk-support": {
        "basic functionality": {
          "js": "0.41.0"
        },
        "data-driven styling": {}
      }
    }
  },
  "paint_symbol": {
    "icon-opacity": {
      "doc": "The opacity at which the icon will be drawn.",
      "type": "number",
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "function": "interpolated",
      "zoom-function": true,
      "property-function": true,
      "transition": true,
      "requires": [
        "icon-image"
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {
          "js": "0.33.0",
          "android": "5.0.0",
          "ios": "3.5.0",
          "macos": "0.4.0"
        }
      }
    },
    "icon-color": {
      "type": "color",
      "default": "#000000",
      "function": "interpolated",
      "zoom-function": true,
      "property-function": true,
      "transition": true,
      "doc": "The color of the icon. This can only be used with sdf icons.",
      "requires": [
        "icon-image"
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {
          "js": "0.33.0",
          "android": "5.0.0",
          "ios": "3.5.0",
          "macos": "0.4.0"
        }
      }
    },
    "icon-halo-color": {
      "type": "color",
      "default": "rgba(0, 0, 0, 0)",
      "function": "interpolated",
      "zoom-function": true,
      "property-function": true,
      "transition": true,
      "doc": "The color of the icon's halo. Icon halos can only be used with SDF icons.",
      "requires": [
        "icon-image"
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {
          "js": "0.33.0",
          "android": "5.0.0",
          "ios": "3.5.0",
          "macos": "0.4.0"
        }
      }
    },
    "icon-halo-width": {
      "type": "number",
      "default": 0,
      "minimum": 0,
      "function": "interpolated",
      "zoom-function": true,
      "property-function": true,
      "transition": true,
      "units": "pixels",
      "doc": "Distance of halo to the icon outline.",
      "requires": [
        "icon-image"
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {
          "js": "0.33.0",
          "android": "5.0.0",
          "ios": "3.5.0",
          "macos": "0.4.0"
        }
      }
    },
    "icon-halo-blur": {
      "type": "number",
      "default": 0,
      "minimum": 0,
      "function": "interpolated",
      "zoom-function": true,
      "property-function": true,
      "transition": true,
      "units": "pixels",
      "doc": "Fade out the halo towards the outside.",
      "requires": [
        "icon-image"
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {
          "js": "0.33.0",
          "android": "5.0.0",
          "ios": "3.5.0",
          "macos": "0.4.0"
        }
      }
    },
    "icon-translate": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        0,
        0
      ],
      "function": "interpolated",
      "zoom-function": true,
      "transition": true,
      "units": "pixels",
      "doc": "Distance that the icon's anchor is moved from its original placement. Positive values indicate right and down, while negative values indicate left and up.",
      "requires": [
        "icon-image"
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {}
      }
    },
    "icon-translate-anchor": {
      "type": "enum",
      "function": "piecewise-constant",
      "zoom-function": true,
      "values": {
        "map": {
            "doc": "Icons are translated relative to the map."
        },
        "viewport": {
            "doc": "Icons are translated relative to the viewport."
        }
      },
      "doc": "Controls the translation reference point.",
      "default": "map",
      "requires": [
        "icon-image",
        "icon-translate"
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {}
      }
    },
    "text-opacity": {
      "type": "number",
      "doc": "The opacity at which the text will be drawn.",
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "function": "interpolated",
      "zoom-function": true,
      "property-function": true,
      "transition": true,
      "requires": [
        "text-field"
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {
          "js": "0.33.0",
          "android": "5.0.0",
          "ios": "3.5.0",
          "macos": "0.4.0"
        }
      }
    },
    "text-color": {
      "type": "color",
      "doc": "The color with which the text will be drawn.",
      "default": "#000000",
      "function": "interpolated",
      "zoom-function": true,
      "property-function": true,
      "transition": true,
      "requires": [
        "text-field"
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {
          "js": "0.33.0",
          "android": "5.0.0",
          "ios": "3.5.0",
          "macos": "0.4.0"
        }
      }
    },
    "text-halo-color": {
      "type": "color",
      "default": "rgba(0, 0, 0, 0)",
      "function": "interpolated",
      "zoom-function": true,
      "property-function": true,
      "transition": true,
      "doc": "The color of the text's halo, which helps it stand out from backgrounds.",
      "requires": [
        "text-field"
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {
          "js": "0.33.0",
          "android": "5.0.0",
          "ios": "3.5.0",
          "macos": "0.4.0"
        }
      }
    },
    "text-halo-width": {
      "type": "number",
      "default": 0,
      "minimum": 0,
      "function": "interpolated",
      "zoom-function": true,
      "property-function": true,
      "transition": true,
      "units": "pixels",
      "doc": "Distance of halo to the font outline. Max text halo width is 1/4 of the font-size.",
      "requires": [
        "text-field"
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {
          "js": "0.33.0",
          "android": "5.0.0",
          "ios": "3.5.0",
          "macos": "0.4.0"
        }
      }
    },
    "text-halo-blur": {
      "type": "number",
      "default": 0,
      "minimum": 0,
      "function": "interpolated",
      "zoom-function": true,
      "property-function": true,
      "transition": true,
      "units": "pixels",
      "doc": "The halo's fadeout distance towards the outside.",
      "requires": [
        "text-field"
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {
          "js": "0.33.0",
          "android": "5.0.0",
          "ios": "3.5.0",
          "macos": "0.4.0"
        }
      }
    },
    "text-translate": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        0,
        0
      ],
      "function": "interpolated",
      "zoom-function": true,
      "transition": true,
      "units": "pixels",
      "doc": "Distance that the text's anchor is moved from its original placement. Positive values indicate right and down, while negative values indicate left and up.",
      "requires": [
        "text-field"
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {}
      }
    },
    "text-translate-anchor": {
      "type": "enum",
      "function": "piecewise-constant",
      "zoom-function": true,
      "values": {
        "map": {
            "doc": "The text is translated relative to the map."
        },
        "viewport": {
            "doc": "The text is translated relative to the viewport."
        }
      },
      "doc": "Controls the translation reference point.",
      "default": "map",
      "requires": [
        "text-field",
        "text-translate"
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {}
      }
    }
  },
  "paint_raster": {
    "raster-opacity": {
      "type": "number",
      "doc": "The opacity at which the image will be drawn.",
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "function": "interpolated",
      "zoom-function": true,
      "transition": true,
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {}
      }
    },
    "raster-hue-rotate": {
      "type": "number",
      "default": 0,
      "period": 360,
      "function": "interpolated",
      "zoom-function": true,
      "transition": true,
      "units": "degrees",
      "doc": "Rotates hues around the color wheel.",
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {}
      }
    },
    "raster-brightness-min": {
      "type": "number",
      "function": "interpolated",
      "zoom-function": true,
      "doc": "Increase or reduce the brightness of the image. The value is the minimum brightness.",
      "default": 0,
      "minimum": 0,
      "maximum": 1,
      "transition": true,
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {}
      }
    },
    "raster-brightness-max": {
      "type": "number",
      "function": "interpolated",
      "zoom-function": true,
      "doc": "Increase or reduce the brightness of the image. The value is the maximum brightness.",
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "transition": true,
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {}
      }
    },
    "raster-saturation": {
      "type": "number",
      "doc": "Increase or reduce the saturation of the image.",
      "default": 0,
      "minimum": -1,
      "maximum": 1,
      "function": "interpolated",
      "zoom-function": true,
      "transition": true,
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {}
      }
    },
    "raster-contrast": {
      "type": "number",
      "doc": "Increase or reduce the contrast of the image.",
      "default": 0,
      "minimum": -1,
      "maximum": 1,
      "function": "interpolated",
      "zoom-function": true,
      "transition": true,
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {}
      }
    },
    "raster-fade-duration": {
      "type": "number",
      "default": 300,
      "minimum": 0,
      "function": "interpolated",
      "zoom-function": true,
      "transition": true,
      "units": "milliseconds",
      "doc": "Fade duration when a new tile is added.",
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        },
        "data-driven styling": {}
      }
    }
  },
  "paint_background": {
    "background-color": {
      "type": "color",
      "default": "#000000",
      "doc": "The color with which the background will be drawn.",
      "function": "interpolated",
      "zoom-function": true,
      "transition": true,
      "requires": [
        {
          "!": "background-pattern"
        }
      ],
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        }
      }
    },
    "background-pattern": {
      "type": "string",
      "function": "piecewise-constant",
      "zoom-function": true,
      "transition": true,
      "doc": "Name of image in sprite to use for drawing an image background. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512).",
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        }
      }
    },
    "background-opacity": {
      "type": "number",
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "doc": "The opacity at which the background will be drawn.",
      "function": "interpolated",
      "zoom-function": true,
      "transition": true,
      "sdk-support": {
        "basic functionality": {
          "js": "0.10.0",
          "android": "2.0.1",
          "ios": "2.0.0",
          "macos": "0.1.0"
        }
      }
    }
  },
  "transition": {
    "duration": {
      "type": "number",
      "default": 300,
      "minimum": 0,
      "units": "milliseconds",
      "doc": "Time allotted for transitions to complete."
    },
    "delay": {
      "type": "number",
      "default": 0,
      "minimum": 0,
      "units": "milliseconds",
      "doc": "Length of time before a transition begins."
    }
  }
}

},{}],58:[function(require,module,exports){

// Constants
var Xn = 0.950470, // D65 standard referent
    Yn = 1,
    Zn = 1.088830,
    t0 = 4 / 29,
    t1 = 6 / 29,
    t2 = 3 * t1 * t1,
    t3 = t1 * t1 * t1,
    deg2rad = Math.PI / 180,
    rad2deg = 180 / Math.PI;

// Utilities
function xyz2lab(t) {
    return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
    return t > t1 ? t * t * t : t2 * (t - t0);
}

function xyz2rgb(x) {
    return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2xyz(x) {
    x /= 255;
    return x <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

// LAB
function rgbToLab(rgbColor) {
    var b = rgb2xyz(rgbColor[0]),
        a = rgb2xyz(rgbColor[1]),
        l = rgb2xyz(rgbColor[2]),
        x = xyz2lab((0.4124564 * b + 0.3575761 * a + 0.1804375 * l) / Xn),
        y = xyz2lab((0.2126729 * b + 0.7151522 * a + 0.0721750 * l) / Yn),
        z = xyz2lab((0.0193339 * b + 0.1191920 * a + 0.9503041 * l) / Zn);

    return [
        116 * y - 16,
        500 * (x - y),
        200 * (y - z),
        rgbColor[3]
    ];
}

function labToRgb(labColor) {
    var y = (labColor[0] + 16) / 116,
        x = isNaN(labColor[1]) ? y : y + labColor[1] / 500,
        z = isNaN(labColor[2]) ? y : y - labColor[2] / 200;
    y = Yn * lab2xyz(y);
    x = Xn * lab2xyz(x);
    z = Zn * lab2xyz(z);
    return [
        xyz2rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z), // D65 -> sRGB
        xyz2rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z),
        xyz2rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z),
        labColor[3]
    ];
}

// HCL
function rgbToHcl(rgbColor) {
    var labColor = rgbToLab(rgbColor);
    var l = labColor[0],
        a = labColor[1],
        b = labColor[2];
    var h = Math.atan2(b, a) * rad2deg;
    return [
        h < 0 ? h + 360 : h,
        Math.sqrt(a * a + b * b),
        l,
        rgbColor[3]
    ];
}

function hclToRgb(hclColor) {
    var h = hclColor[0] * deg2rad,
        c = hclColor[1],
        l = hclColor[2];
    return labToRgb([
        l,
        Math.cos(h) * c,
        Math.sin(h) * c,
        hclColor[3]
    ]);
}

module.exports = {
    lab: {
        forward: rgbToLab,
        reverse: labToRgb
    },
    hcl: {
        forward: rgbToHcl,
        reverse: hclToRgb
    }
};

},{}],59:[function(require,module,exports){

module.exports = function (output) {
    var inputs = [], len = arguments.length - 1;
    while ( len-- > 0 ) inputs[ len ] = arguments[ len + 1 ];

    for (var i = 0, list = inputs; i < list.length; i += 1) {
        var input = list[i];

        for (var k in input) {
            output[k] = input[k];
        }
    }
    return output;
};

},{}],60:[function(require,module,exports){

module.exports = function getType(val) {
    if (val instanceof Number) {
        return 'number';
    } else if (val instanceof String) {
        return 'string';
    } else if (val instanceof Boolean) {
        return 'boolean';
    } else if (Array.isArray(val)) {
        return 'array';
    } else if (val === null) {
        return 'null';
    } else {
        return typeof val;
    }
};

},{}],61:[function(require,module,exports){

module.exports = interpolate;

function interpolate(a, b, t) {
    return (a * (1 - t)) + (b * t);
}

interpolate.number = interpolate;

interpolate.vec2 = function(from, to, t) {
    return [
        interpolate(from[0], to[0], t),
        interpolate(from[1], to[1], t)
    ];
};

/*
 * Interpolate between two colors given as 4-element arrays.
 *
 * @param {Color} from
 * @param {Color} to
 * @param {number} t interpolation factor between 0 and 1
 * @returns {Color} interpolated color
 */
interpolate.color = function(from, to, t) {
    return [
        interpolate(from[0], to[0], t),
        interpolate(from[1], to[1], t),
        interpolate(from[2], to[2], t),
        interpolate(from[3], to[3], t)
    ];
};

interpolate.array = function(from, to, t) {
    return from.map(function (d, i) {
        return interpolate(d, to[i], t);
    });
};

},{}],62:[function(require,module,exports){
//      

var parseColorString = require('csscolorparser').parseCSSColor;

module.exports = function parseColor(input                                           )                                    {
    if (typeof input === 'string') {
        var rgba = parseColorString(input);
        if (!rgba) { return undefined; }

        // GL expects all components to be in the range [0, 1] and to be
        // multipled by the alpha value.
        return [
            rgba[0] / 255 * rgba[3],
            rgba[1] / 255 * rgba[3],
            rgba[2] / 255 * rgba[3],
            rgba[3]
        ];

    } else if (Array.isArray(input)) {
        return input;

    } else {
        return undefined;
    }
};

},{"csscolorparser":7}],63:[function(require,module,exports){

// Turn jsonlint-lines-primitives objects into primitive objects
function unbundle(value) {
    if (value instanceof Number || value instanceof String || value instanceof Boolean) {
        return value.valueOf();
    } else {
        return value;
    }
}

function deepUnbundle(value) {
    if (Array.isArray(value)) {
        return value.map(deepUnbundle);
    }
    return unbundle(value);
}

module.exports = unbundle;
module.exports.deep = deepUnbundle;

},{}],64:[function(require,module,exports){

var ValidationError = require('../error/validation_error');
var getType = require('../util/get_type');
var extend = require('../util/extend');
var unbundle = require('../util/unbundle_jsonlint');
var ref = require('../expression');
var isExpression = ref.isExpression;
var ref$1 = require('../function');
var isFunction = ref$1.isFunction;

// Main recursive validation function. Tracks:
//
// - key: string representing location of validation in style tree. Used only
//   for more informative error reporting.
// - value: current value from style being evaluated. May be anything from a
//   high level object that needs to be descended into deeper or a simple
//   scalar value.
// - valueSpec: current spec being evaluated. Tracks value.

module.exports = function validate(options) {

    var validateFunction = require('./validate_function');
    var validateExpression = require('./validate_expression');
    var validateObject = require('./validate_object');
    var VALIDATORS = {
        '*': function() {
            return [];
        },
        'array': require('./validate_array'),
        'boolean': require('./validate_boolean'),
        'number': require('./validate_number'),
        'color': require('./validate_color'),
        'constants': require('./validate_constants'),
        'enum': require('./validate_enum'),
        'filter': require('./validate_filter'),
        'function': require('./validate_function'),
        'layer': require('./validate_layer'),
        'object': require('./validate_object'),
        'source': require('./validate_source'),
        'light': require('./validate_light'),
        'string': require('./validate_string')
    };

    var value = options.value;
    var valueSpec = options.valueSpec;
    var key = options.key;
    var styleSpec = options.styleSpec;
    var style = options.style;

    if (getType(value) === 'string' && value[0] === '@') {
        if (styleSpec.$version > 7) {
            return [new ValidationError(key, value, 'constants have been deprecated as of v8')];
        }
        if (!(value in style.constants)) {
            return [new ValidationError(key, value, 'constant "%s" not found', value)];
        }
        options = extend({}, options, { value: style.constants[value] });
    }

    if (valueSpec.function && isFunction(unbundle(value))) {
        return validateFunction(options);

    } else if (valueSpec.function && isExpression(unbundle.deep(value))) {
        return validateExpression(options);

    } else if (valueSpec.type && VALIDATORS[valueSpec.type]) {
        return VALIDATORS[valueSpec.type](options);

    } else {
        return validateObject(extend({}, options, {
            valueSpec: valueSpec.type ? styleSpec[valueSpec.type] : valueSpec
        }));
    }
};

},{"../error/validation_error":23,"../expression":38,"../function":49,"../util/extend":59,"../util/get_type":60,"../util/unbundle_jsonlint":63,"./validate_array":65,"./validate_boolean":66,"./validate_color":67,"./validate_constants":68,"./validate_enum":69,"./validate_expression":70,"./validate_filter":71,"./validate_function":72,"./validate_layer":74,"./validate_light":76,"./validate_number":77,"./validate_object":78,"./validate_source":81,"./validate_string":82}],65:[function(require,module,exports){

var getType = require('../util/get_type');
var validate = require('./validate');
var ValidationError = require('../error/validation_error');

module.exports = function validateArray(options) {
    var array = options.value;
    var arraySpec = options.valueSpec;
    var style = options.style;
    var styleSpec = options.styleSpec;
    var key = options.key;
    var validateArrayElement = options.arrayElementValidator || validate;

    if (getType(array) !== 'array') {
        return [new ValidationError(key, array, 'array expected, %s found', getType(array))];
    }

    if (arraySpec.length && array.length !== arraySpec.length) {
        return [new ValidationError(key, array, 'array length %d expected, length %d found', arraySpec.length, array.length)];
    }

    if (arraySpec['min-length'] && array.length < arraySpec['min-length']) {
        return [new ValidationError(key, array, 'array length at least %d expected, length %d found', arraySpec['min-length'], array.length)];
    }

    var arrayElementSpec = {
        "type": arraySpec.value
    };

    if (styleSpec.$version < 7) {
        arrayElementSpec.function = arraySpec.function;
    }

    if (getType(arraySpec.value) === 'object') {
        arrayElementSpec = arraySpec.value;
    }

    var errors = [];
    for (var i = 0; i < array.length; i++) {
        errors = errors.concat(validateArrayElement({
            array: array,
            arrayIndex: i,
            value: array[i],
            valueSpec: arrayElementSpec,
            style: style,
            styleSpec: styleSpec,
            key: (key + "[" + i + "]")
        }));
    }
    return errors;
};

},{"../error/validation_error":23,"../util/get_type":60,"./validate":64}],66:[function(require,module,exports){

var getType = require('../util/get_type');
var ValidationError = require('../error/validation_error');

module.exports = function validateBoolean(options) {
    var value = options.value;
    var key = options.key;
    var type = getType(value);

    if (type !== 'boolean') {
        return [new ValidationError(key, value, 'boolean expected, %s found', type)];
    }

    return [];
};

},{"../error/validation_error":23,"../util/get_type":60}],67:[function(require,module,exports){

var ValidationError = require('../error/validation_error');
var getType = require('../util/get_type');
var parseCSSColor = require('csscolorparser').parseCSSColor;

module.exports = function validateColor(options) {
    var key = options.key;
    var value = options.value;
    var type = getType(value);

    if (type !== 'string') {
        return [new ValidationError(key, value, 'color expected, %s found', type)];
    }

    if (parseCSSColor(value) === null) {
        return [new ValidationError(key, value, 'color expected, "%s" found', value)];
    }

    return [];
};

},{"../error/validation_error":23,"../util/get_type":60,"csscolorparser":7}],68:[function(require,module,exports){

var ValidationError = require('../error/validation_error');
var getType = require('../util/get_type');

module.exports = function validateConstants(options) {
    var key = options.key;
    var constants = options.value;
    var styleSpec = options.styleSpec;

    if (styleSpec.$version > 7) {
        if (constants) {
            return [new ValidationError(key, constants, 'constants have been deprecated as of v8')];
        } else {
            return [];
        }
    } else {
        var type = getType(constants);
        if (type !== 'object') {
            return [new ValidationError(key, constants, 'object expected, %s found', type)];
        }

        var errors = [];
        for (var constantName in constants) {
            if (constantName[0] !== '@') {
                errors.push(new ValidationError((key + "." + constantName), constants[constantName], 'constants must start with "@"'));
            }
        }
        return errors;
    }

};

},{"../error/validation_error":23,"../util/get_type":60}],69:[function(require,module,exports){

var ValidationError = require('../error/validation_error');
var unbundle = require('../util/unbundle_jsonlint');

module.exports = function validateEnum(options) {
    var key = options.key;
    var value = options.value;
    var valueSpec = options.valueSpec;
    var errors = [];

    if (Array.isArray(valueSpec.values)) { // <=v7
        if (valueSpec.values.indexOf(unbundle(value)) === -1) {
            errors.push(new ValidationError(key, value, 'expected one of [%s], %s found', valueSpec.values.join(', '), JSON.stringify(value)));
        }
    } else { // >=v8
        if (Object.keys(valueSpec.values).indexOf(unbundle(value)) === -1) {
            errors.push(new ValidationError(key, value, 'expected one of [%s], %s found', Object.keys(valueSpec.values).join(', '), JSON.stringify(value)));
        }
    }
    return errors;
};

},{"../error/validation_error":23,"../util/unbundle_jsonlint":63}],70:[function(require,module,exports){

var ValidationError = require('../error/validation_error');
var ref = require('../expression');
var createExpression = ref.createExpression;
var unbundle = require('../util/unbundle_jsonlint');

module.exports = function validateExpression(options) {
    var expression = createExpression(unbundle.deep(options.value), options.valueSpec, options.expressionContext);
    if (expression.result === 'success') {
        return [];
    }

    return expression.errors.map(function (error) {
        return new ValidationError(("" + (options.key) + (error.key)), options.value, error.message);
    });
};

},{"../error/validation_error":23,"../expression":38,"../util/unbundle_jsonlint":63}],71:[function(require,module,exports){

var ValidationError = require('../error/validation_error');
var validateExpression = require('./validate_expression');
var validateEnum = require('./validate_enum');
var getType = require('../util/get_type');
var unbundle = require('../util/unbundle_jsonlint');
var extend = require('../util/extend');
var ref = require('../feature_filter');
var isExpressionFilter = ref.isExpressionFilter;

module.exports = function validateFilter(options) {
    var value = options.value;
    var key = options.key;
    var styleSpec = options.styleSpec;
    var type;

    var errors = [];

    if (getType(value) !== 'array') {
        return [new ValidationError(key, value, 'array expected, %s found', getType(value))];
    }

    if (isExpressionFilter(unbundle.deep(value))) {
        return validateExpression(extend({}, options, {
            expressionContext: 'filter',
            valueSpec: { value: 'boolean' }
        }));
    }

    if (value.length < 1) {
        return [new ValidationError(key, value, 'filter array must have at least 1 element')];
    }

    errors = errors.concat(validateEnum({
        key: (key + "[0]"),
        value: value[0],
        valueSpec: styleSpec.filter_operator,
        style: options.style,
        styleSpec: options.styleSpec
    }));

    switch (unbundle(value[0])) {
    case '<':
    case '<=':
    case '>':
    case '>=':
        if (value.length >= 2 && unbundle(value[1]) === '$type') {
            errors.push(new ValidationError(key, value, '"$type" cannot be use with operator "%s"', value[0]));
        }
        /* falls through */
    case '==':
    case '!=':
        if (value.length !== 3) {
            errors.push(new ValidationError(key, value, 'filter array for operator "%s" must have 3 elements', value[0]));
        }
        /* falls through */
    case 'in':
    case '!in':
        if (value.length >= 2) {
            type = getType(value[1]);
            if (type !== 'string') {
                errors.push(new ValidationError((key + "[1]"), value[1], 'string expected, %s found', type));
            }
        }
        for (var i = 2; i < value.length; i++) {
            type = getType(value[i]);
            if (unbundle(value[1]) === '$type') {
                errors = errors.concat(validateEnum({
                    key: (key + "[" + i + "]"),
                    value: value[i],
                    valueSpec: styleSpec.geometry_type,
                    style: options.style,
                    styleSpec: options.styleSpec
                }));
            } else if (type !== 'string' && type !== 'number' && type !== 'boolean') {
                errors.push(new ValidationError((key + "[" + i + "]"), value[i], 'string, number, or boolean expected, %s found', type));
            }
        }
        break;

    case 'any':
    case 'all':
    case 'none':
        for (var i$1 = 1; i$1 < value.length; i$1++) {
            errors = errors.concat(validateFilter({
                key: (key + "[" + i$1 + "]"),
                value: value[i$1],
                style: options.style,
                styleSpec: options.styleSpec
            }));
        }
        break;

    case 'has':
    case '!has':
        type = getType(value[1]);
        if (value.length !== 2) {
            errors.push(new ValidationError(key, value, 'filter array for "%s" operator must have 2 elements', value[0]));
        } else if (type !== 'string') {
            errors.push(new ValidationError((key + "[1]"), value[1], 'string expected, %s found', type));
        }
        break;

    }

    return errors;
};

},{"../error/validation_error":23,"../feature_filter":46,"../util/extend":59,"../util/get_type":60,"../util/unbundle_jsonlint":63,"./validate_enum":69,"./validate_expression":70}],72:[function(require,module,exports){

var ValidationError = require('../error/validation_error');
var getType = require('../util/get_type');
var validate = require('./validate');
var validateObject = require('./validate_object');
var validateArray = require('./validate_array');
var validateNumber = require('./validate_number');
var unbundle = require('../util/unbundle_jsonlint');

module.exports = function validateFunction(options) {
    var functionValueSpec = options.valueSpec;
    var functionType = unbundle(options.value.type);
    var stopKeyType;
    var stopDomainValues = {};
    var previousStopDomainValue;
    var previousStopDomainZoom;

    var isZoomFunction = functionType !== 'categorical' && options.value.property === undefined;
    var isPropertyFunction = !isZoomFunction;
    var isZoomAndPropertyFunction =
        getType(options.value.stops) === 'array' &&
        getType(options.value.stops[0]) === 'array' &&
        getType(options.value.stops[0][0]) === 'object';

    var errors = validateObject({
        key: options.key,
        value: options.value,
        valueSpec: options.styleSpec.function,
        style: options.style,
        styleSpec: options.styleSpec,
        objectElementValidators: {
            stops: validateFunctionStops,
            default: validateFunctionDefault
        }
    });

    if (functionType === 'identity' && isZoomFunction) {
        errors.push(new ValidationError(options.key, options.value, 'missing required property "property"'));
    }

    if (functionType !== 'identity' && !options.value.stops) {
        errors.push(new ValidationError(options.key, options.value, 'missing required property "stops"'));
    }

    if (functionType === 'exponential' && options.valueSpec['function'] === 'piecewise-constant') {
        errors.push(new ValidationError(options.key, options.value, 'exponential functions not supported'));
    }

    if (options.styleSpec.$version >= 8) {
        if (isPropertyFunction && !options.valueSpec['property-function']) {
            errors.push(new ValidationError(options.key, options.value, 'property functions not supported'));
        } else if (isZoomFunction && !options.valueSpec['zoom-function']) {
            errors.push(new ValidationError(options.key, options.value, 'zoom functions not supported'));
        }
    }

    if ((functionType === 'categorical' || isZoomAndPropertyFunction) && options.value.property === undefined) {
        errors.push(new ValidationError(options.key, options.value, '"property" property is required'));
    }

    return errors;

    function validateFunctionStops(options) {
        if (functionType === 'identity') {
            return [new ValidationError(options.key, options.value, 'identity function may not have a "stops" property')];
        }

        var errors = [];
        var value = options.value;

        errors = errors.concat(validateArray({
            key: options.key,
            value: value,
            valueSpec: options.valueSpec,
            style: options.style,
            styleSpec: options.styleSpec,
            arrayElementValidator: validateFunctionStop
        }));

        if (getType(value) === 'array' && value.length === 0) {
            errors.push(new ValidationError(options.key, value, 'array must have at least one stop'));
        }

        return errors;
    }

    function validateFunctionStop(options) {
        var errors = [];
        var value = options.value;
        var key = options.key;

        if (getType(value) !== 'array') {
            return [new ValidationError(key, value, 'array expected, %s found', getType(value))];
        }

        if (value.length !== 2) {
            return [new ValidationError(key, value, 'array length %d expected, length %d found', 2, value.length)];
        }

        if (isZoomAndPropertyFunction) {
            if (getType(value[0]) !== 'object') {
                return [new ValidationError(key, value, 'object expected, %s found', getType(value[0]))];
            }
            if (value[0].zoom === undefined) {
                return [new ValidationError(key, value, 'object stop key must have zoom')];
            }
            if (value[0].value === undefined) {
                return [new ValidationError(key, value, 'object stop key must have value')];
            }
            if (previousStopDomainZoom && previousStopDomainZoom > unbundle(value[0].zoom)) {
                return [new ValidationError(key, value[0].zoom, 'stop zoom values must appear in ascending order')];
            }
            if (unbundle(value[0].zoom) !== previousStopDomainZoom) {
                previousStopDomainZoom = unbundle(value[0].zoom);
                previousStopDomainValue = undefined;
                stopDomainValues = {};
            }
            errors = errors.concat(validateObject({
                key: (key + "[0]"),
                value: value[0],
                valueSpec: { zoom: {} },
                style: options.style,
                styleSpec: options.styleSpec,
                objectElementValidators: { zoom: validateNumber, value: validateStopDomainValue }
            }));
        } else {
            errors = errors.concat(validateStopDomainValue({
                key: (key + "[0]"),
                value: value[0],
                valueSpec: {},
                style: options.style,
                styleSpec: options.styleSpec
            }, value));
        }

        return errors.concat(validate({
            key: (key + "[1]"),
            value: value[1],
            valueSpec: functionValueSpec,
            style: options.style,
            styleSpec: options.styleSpec
        }));
    }

    function validateStopDomainValue(options, stop) {
        var type = getType(options.value);
        var value = unbundle(options.value);

        var reportValue = options.value !== null ? options.value : stop;

        if (!stopKeyType) {
            stopKeyType = type;
        } else if (type !== stopKeyType) {
            return [new ValidationError(options.key, reportValue, '%s stop domain type must match previous stop domain type %s', type, stopKeyType)];
        }

        if (type !== 'number' && type !== 'string' && type !== 'boolean') {
            return [new ValidationError(options.key, reportValue, 'stop domain value must be a number, string, or boolean')];
        }

        if (type !== 'number' && functionType !== 'categorical') {
            var message = 'number expected, %s found';
            if (functionValueSpec['property-function'] && functionType === undefined) {
                message += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.';
            }
            return [new ValidationError(options.key, reportValue, message, type)];
        }

        if (functionType === 'categorical' && type === 'number' && (!isFinite(value) || Math.floor(value) !== value)) {
            return [new ValidationError(options.key, reportValue, 'integer expected, found %s', value)];
        }

        if (functionType !== 'categorical' && type === 'number' && previousStopDomainValue !== undefined && value < previousStopDomainValue) {
            return [new ValidationError(options.key, reportValue, 'stop domain values must appear in ascending order')];
        } else {
            previousStopDomainValue = value;
        }

        if (functionType === 'categorical' && value in stopDomainValues) {
            return [new ValidationError(options.key, reportValue, 'stop domain values must be unique')];
        } else {
            stopDomainValues[value] = true;
        }

        return [];
    }

    function validateFunctionDefault(options) {
        return validate({
            key: options.key,
            value: options.value,
            valueSpec: functionValueSpec,
            style: options.style,
            styleSpec: options.styleSpec
        });
    }
};

},{"../error/validation_error":23,"../util/get_type":60,"../util/unbundle_jsonlint":63,"./validate":64,"./validate_array":65,"./validate_number":77,"./validate_object":78}],73:[function(require,module,exports){

var ValidationError = require('../error/validation_error');
var validateString = require('./validate_string');

module.exports = function(options) {
    var value = options.value;
    var key = options.key;

    var errors = validateString(options);
    if (errors.length) { return errors; }

    if (value.indexOf('{fontstack}') === -1) {
        errors.push(new ValidationError(key, value, '"glyphs" url must include a "{fontstack}" token'));
    }

    if (value.indexOf('{range}') === -1) {
        errors.push(new ValidationError(key, value, '"glyphs" url must include a "{range}" token'));
    }

    return errors;
};

},{"../error/validation_error":23,"./validate_string":82}],74:[function(require,module,exports){

var ValidationError = require('../error/validation_error');
var unbundle = require('../util/unbundle_jsonlint');
var validateObject = require('./validate_object');
var validateFilter = require('./validate_filter');
var validatePaintProperty = require('./validate_paint_property');
var validateLayoutProperty = require('./validate_layout_property');
var extend = require('../util/extend');

module.exports = function validateLayer(options) {
    var errors = [];

    var layer = options.value;
    var key = options.key;
    var style = options.style;
    var styleSpec = options.styleSpec;

    if (!layer.type && !layer.ref) {
        errors.push(new ValidationError(key, layer, 'either "type" or "ref" is required'));
    }
    var type = unbundle(layer.type);
    var ref = unbundle(layer.ref);

    if (layer.id) {
        var layerId = unbundle(layer.id);
        for (var i = 0; i < options.arrayIndex; i++) {
            var otherLayer = style.layers[i];
            if (unbundle(otherLayer.id) === layerId) {
                errors.push(new ValidationError(key, layer.id, 'duplicate layer id "%s", previously used at line %d', layer.id, otherLayer.id.__line__));
            }
        }
    }

    if ('ref' in layer) {
        ['type', 'source', 'source-layer', 'filter', 'layout'].forEach(function (p) {
            if (p in layer) {
                errors.push(new ValidationError(key, layer[p], '"%s" is prohibited for ref layers', p));
            }
        });

        var parent;

        style.layers.forEach(function (layer) {
            if (unbundle(layer.id) === ref) { parent = layer; }
        });

        if (!parent) {
            errors.push(new ValidationError(key, layer.ref, 'ref layer "%s" not found', ref));
        } else if (parent.ref) {
            errors.push(new ValidationError(key, layer.ref, 'ref cannot reference another ref layer'));
        } else {
            type = unbundle(parent.type);
        }
    } else if (type !== 'background') {
        if (!layer.source) {
            errors.push(new ValidationError(key, layer, 'missing required property "source"'));
        } else {
            var source = style.sources && style.sources[layer.source];
            var sourceType = source && unbundle(source.type);
            if (!source) {
                errors.push(new ValidationError(key, layer.source, 'source "%s" not found', layer.source));
            } else if (sourceType === 'vector' && type === 'raster') {
                errors.push(new ValidationError(key, layer.source, 'layer "%s" requires a raster source', layer.id));
            } else if (sourceType === 'raster' && type !== 'raster') {
                errors.push(new ValidationError(key, layer.source, 'layer "%s" requires a vector source', layer.id));
            } else if (sourceType === 'vector' && !layer['source-layer']) {
                errors.push(new ValidationError(key, layer, 'layer "%s" must specify a "source-layer"', layer.id));
            }
        }
    }

    errors = errors.concat(validateObject({
        key: key,
        value: layer,
        valueSpec: styleSpec.layer,
        style: options.style,
        styleSpec: options.styleSpec,
        objectElementValidators: {
            '*': function() {
                return [];
            },
            filter: validateFilter,
            layout: function(options) {
                return validateObject({
                    layer: layer,
                    key: options.key,
                    value: options.value,
                    style: options.style,
                    styleSpec: options.styleSpec,
                    objectElementValidators: {
                        '*': function(options) {
                            return validateLayoutProperty(extend({layerType: type}, options));
                        }
                    }
                });
            },
            paint: function(options) {
                return validateObject({
                    layer: layer,
                    key: options.key,
                    value: options.value,
                    style: options.style,
                    styleSpec: options.styleSpec,
                    objectElementValidators: {
                        '*': function(options) {
                            return validatePaintProperty(extend({layerType: type}, options));
                        }
                    }
                });
            }
        }
    }));

    return errors;
};

},{"../error/validation_error":23,"../util/extend":59,"../util/unbundle_jsonlint":63,"./validate_filter":71,"./validate_layout_property":75,"./validate_object":78,"./validate_paint_property":79}],75:[function(require,module,exports){

var validateProperty = require('./validate_property');

module.exports = function validateLayoutProperty(options) {
    return validateProperty(options, 'layout');
};

},{"./validate_property":80}],76:[function(require,module,exports){

var ValidationError = require('../error/validation_error');
var getType = require('../util/get_type');
var validate = require('./validate');

module.exports = function validateLight(options) {
    var light = options.value;
    var styleSpec = options.styleSpec;
    var lightSpec = styleSpec.light;
    var style = options.style;

    var errors = [];

    var rootType = getType(light);
    if (light === undefined) {
        return errors;
    } else if (rootType !== 'object') {
        errors = errors.concat([new ValidationError('light', light, 'object expected, %s found', rootType)]);
        return errors;
    }

    for (var key in light) {
        var transitionMatch = key.match(/^(.*)-transition$/);

        if (transitionMatch && lightSpec[transitionMatch[1]] && lightSpec[transitionMatch[1]].transition) {
            errors = errors.concat(validate({
                key: key,
                value: light[key],
                valueSpec: styleSpec.transition,
                style: style,
                styleSpec: styleSpec
            }));
        } else if (lightSpec[key]) {
            errors = errors.concat(validate({
                key: key,
                value: light[key],
                valueSpec: lightSpec[key],
                style: style,
                styleSpec: styleSpec
            }));
        } else {
            errors = errors.concat([new ValidationError(key, light[key], 'unknown property "%s"', key)]);
        }
    }

    return errors;
};

},{"../error/validation_error":23,"../util/get_type":60,"./validate":64}],77:[function(require,module,exports){

var getType = require('../util/get_type');
var ValidationError = require('../error/validation_error');

module.exports = function validateNumber(options) {
    var key = options.key;
    var value = options.value;
    var valueSpec = options.valueSpec;
    var type = getType(value);

    if (type !== 'number') {
        return [new ValidationError(key, value, 'number expected, %s found', type)];
    }

    if ('minimum' in valueSpec && value < valueSpec.minimum) {
        return [new ValidationError(key, value, '%s is less than the minimum value %s', value, valueSpec.minimum)];
    }

    if ('maximum' in valueSpec && value > valueSpec.maximum) {
        return [new ValidationError(key, value, '%s is greater than the maximum value %s', value, valueSpec.maximum)];
    }

    return [];
};

},{"../error/validation_error":23,"../util/get_type":60}],78:[function(require,module,exports){

var ValidationError = require('../error/validation_error');
var getType = require('../util/get_type');
var validateSpec = require('./validate');

module.exports = function validateObject(options) {
    var key = options.key;
    var object = options.value;
    var elementSpecs = options.valueSpec || {};
    var elementValidators = options.objectElementValidators || {};
    var style = options.style;
    var styleSpec = options.styleSpec;
    var errors = [];

    var type = getType(object);
    if (type !== 'object') {
        return [new ValidationError(key, object, 'object expected, %s found', type)];
    }

    for (var objectKey in object) {
        var elementSpecKey = objectKey.split('.')[0]; // treat 'paint.*' as 'paint'
        var elementSpec = elementSpecs[elementSpecKey] || elementSpecs['*'];

        var validateElement = (void 0);
        if (elementValidators[elementSpecKey]) {
            validateElement = elementValidators[elementSpecKey];
        } else if (elementSpecs[elementSpecKey]) {
            validateElement = validateSpec;
        } else if (elementValidators['*']) {
            validateElement = elementValidators['*'];
        } else if (elementSpecs['*']) {
            validateElement = validateSpec;
        } else {
            errors.push(new ValidationError(key, object[objectKey], 'unknown property "%s"', objectKey));
            continue;
        }

        errors = errors.concat(validateElement({
            key: (key ? (key + ".") : key) + objectKey,
            value: object[objectKey],
            valueSpec: elementSpec,
            style: style,
            styleSpec: styleSpec,
            object: object,
            objectKey: objectKey
        }, object));
    }

    for (var elementSpecKey$1 in elementSpecs) {
        if (elementSpecs[elementSpecKey$1].required && elementSpecs[elementSpecKey$1]['default'] === undefined && object[elementSpecKey$1] === undefined) {
            errors.push(new ValidationError(key, object, 'missing required property "%s"', elementSpecKey$1));
        }
    }

    return errors;
};

},{"../error/validation_error":23,"../util/get_type":60,"./validate":64}],79:[function(require,module,exports){

var validateProperty = require('./validate_property');

module.exports = function validatePaintProperty(options) {
    return validateProperty(options, 'paint');
};

},{"./validate_property":80}],80:[function(require,module,exports){

var validate = require('./validate');
var ValidationError = require('../error/validation_error');
var getType = require('../util/get_type');

module.exports = function validateProperty(options, propertyType) {
    var key = options.key;
    var style = options.style;
    var styleSpec = options.styleSpec;
    var value = options.value;
    var propertyKey = options.objectKey;
    var layerSpec = styleSpec[(propertyType + "_" + (options.layerType))];

    if (!layerSpec) { return []; }

    var transitionMatch = propertyKey.match(/^(.*)-transition$/);
    if (propertyType === 'paint' && transitionMatch && layerSpec[transitionMatch[1]] && layerSpec[transitionMatch[1]].transition) {
        return validate({
            key: key,
            value: value,
            valueSpec: styleSpec.transition,
            style: style,
            styleSpec: styleSpec
        });
    }

    var valueSpec = options.valueSpec || layerSpec[propertyKey];
    if (!valueSpec) {
        return [new ValidationError(key, value, 'unknown property "%s"', propertyKey)];
    }

    var tokenMatch;
    if (getType(value) === 'string' && valueSpec['property-function'] && !valueSpec.tokens && (tokenMatch = /^{([^}]+)}$/.exec(value))) {
        return [new ValidationError(
            key, value,
            '"%s" does not support interpolation syntax\n' +
                'Use an identity property function instead: `{ "type": "identity", "property": %s` }`.',
            propertyKey, JSON.stringify(tokenMatch[1])
        )];
    }

    var errors = [];

    if (options.layerType === 'symbol') {
        if (propertyKey === 'text-field' && style && !style.glyphs) {
            errors.push(new ValidationError(key, value, 'use of "text-field" requires a style "glyphs" property'));
        }
    }

    return errors.concat(validate({
        key: options.key,
        value: value,
        valueSpec: valueSpec,
        style: style,
        styleSpec: styleSpec,
        expressionContext: 'property'
    }));
};

},{"../error/validation_error":23,"../util/get_type":60,"./validate":64}],81:[function(require,module,exports){

var ValidationError = require('../error/validation_error');
var unbundle = require('../util/unbundle_jsonlint');
var validateObject = require('./validate_object');
var validateEnum = require('./validate_enum');

module.exports = function validateSource(options) {
    var value = options.value;
    var key = options.key;
    var styleSpec = options.styleSpec;
    var style = options.style;

    if (!value.type) {
        return [new ValidationError(key, value, '"type" is required')];
    }

    var type = unbundle(value.type);
    var errors = [];

    switch (type) {
    case 'vector':
    case 'raster':
        errors = errors.concat(validateObject({
            key: key,
            value: value,
            valueSpec: styleSpec.source_tile,
            style: options.style,
            styleSpec: styleSpec
        }));
        if ('url' in value) {
            for (var prop in value) {
                if (['type', 'url', 'tileSize'].indexOf(prop) < 0) {
                    errors.push(new ValidationError((key + "." + prop), value[prop], 'a source with a "url" property may not include a "%s" property', prop));
                }
            }
        }
        return errors;

    case 'geojson':
        return validateObject({
            key: key,
            value: value,
            valueSpec: styleSpec.source_geojson,
            style: style,
            styleSpec: styleSpec
        });

    case 'video':
        return validateObject({
            key: key,
            value: value,
            valueSpec: styleSpec.source_video,
            style: style,
            styleSpec: styleSpec
        });

    case 'image':
        return validateObject({
            key: key,
            value: value,
            valueSpec: styleSpec.source_image,
            style: style,
            styleSpec: styleSpec
        });

    case 'canvas':
        return validateObject({
            key: key,
            value: value,
            valueSpec: styleSpec.source_canvas,
            style: style,
            styleSpec: styleSpec
        });

    default:
        return validateEnum({
            key: (key + ".type"),
            value: value.type,
            valueSpec: {values: ['vector', 'raster', 'geojson', 'video', 'image', 'canvas']},
            style: style,
            styleSpec: styleSpec
        });
    }
};

},{"../error/validation_error":23,"../util/unbundle_jsonlint":63,"./validate_enum":69,"./validate_object":78}],82:[function(require,module,exports){

var getType = require('../util/get_type');
var ValidationError = require('../error/validation_error');

module.exports = function validateString(options) {
    var value = options.value;
    var key = options.key;
    var type = getType(value);

    if (type !== 'string') {
        return [new ValidationError(key, value, 'string expected, %s found', type)];
    }

    return [];
};

},{"../error/validation_error":23,"../util/get_type":60}],83:[function(require,module,exports){
(function (Buffer){

var validateStyleMin = require('./validate_style.min');
var ParsingError = require('./error/parsing_error');
var jsonlint = require('jsonlint-lines-primitives');

/**
 * Validate a Mapbox GL style against the style specification.
 *
 * @private
 * @alias validate
 * @param {Object|String|Buffer} style The style to be validated. If a `String`
 *     or `Buffer` is provided, the returned errors will contain line numbers.
 * @param {Object} [styleSpec] The style specification to validate against.
 *     If omitted, the spec version is inferred from the stylesheet.
 * @returns {Array<ValidationError|ParsingError>}
 * @example
 *   var validate = require('mapbox-gl-style-spec').validate;
 *   var style = fs.readFileSync('./style.json', 'utf8');
 *   var errors = validate(style);
 */

module.exports = function validateStyle(style, styleSpec) {
    var index = require('./');

    if (style instanceof String || typeof style === 'string' || style instanceof Buffer) {
        try {
            style = jsonlint.parse(style.toString());
        } catch (e) {
            return [new ParsingError(e)];
        }
    }

    styleSpec = styleSpec || index[("v" + (style.version))];

    return validateStyleMin(style, styleSpec);
};

exports.source = validateStyleMin.source;
exports.light = validateStyleMin.light;
exports.layer = validateStyleMin.layer;
exports.filter = validateStyleMin.filter;
exports.paintProperty = validateStyleMin.paintProperty;
exports.layoutProperty = validateStyleMin.layoutProperty;

}).call(this,require("buffer").Buffer)

},{"./":50,"./error/parsing_error":22,"./validate_style.min":84,"buffer":5,"jsonlint-lines-primitives":11}],84:[function(require,module,exports){

var validateConstants = require('./validate/validate_constants');
var validate = require('./validate/validate');
var latestStyleSpec = require('./reference/latest');
var validateGlyphsURL = require('./validate/validate_glyphs_url');

/**
 * Validate a Mapbox GL style against the style specification. This entrypoint,
 * `mapbox-gl-style-spec/lib/validate_style.min`, is designed to produce as
 * small a browserify bundle as possible by omitting unnecessary functionality
 * and legacy style specifications.
 *
 * @private
 * @param {Object} style The style to be validated.
 * @param {Object} [styleSpec] The style specification to validate against.
 *     If omitted, the latest style spec is used.
 * @returns {Array<ValidationError>}
 * @example
 *   var validate = require('mapbox-gl-style-spec/lib/validate_style.min');
 *   var errors = validate(style);
 */
function validateStyleMin(style, styleSpec) {
    styleSpec = styleSpec || latestStyleSpec;

    var errors = [];

    errors = errors.concat(validate({
        key: '',
        value: style,
        valueSpec: styleSpec.$root,
        styleSpec: styleSpec,
        style: style,
        objectElementValidators: {
            glyphs: validateGlyphsURL,
            '*': function() {
                return [];
            }
        }
    }));

    if (styleSpec.$version > 7 && style.constants) {
        errors = errors.concat(validateConstants({
            key: 'constants',
            value: style.constants,
            style: style,
            styleSpec: styleSpec
        }));
    }

    return sortErrors(errors);
}

validateStyleMin.source = wrapCleanErrors(require('./validate/validate_source'));
validateStyleMin.light = wrapCleanErrors(require('./validate/validate_light'));
validateStyleMin.layer = wrapCleanErrors(require('./validate/validate_layer'));
validateStyleMin.filter = wrapCleanErrors(require('./validate/validate_filter'));
validateStyleMin.paintProperty = wrapCleanErrors(require('./validate/validate_paint_property'));
validateStyleMin.layoutProperty = wrapCleanErrors(require('./validate/validate_layout_property'));

function sortErrors(errors) {
    return [].concat(errors).sort(function (a, b) {
        return a.line - b.line;
    });
}

function wrapCleanErrors(inner) {
    return function() {
        return sortErrors(inner.apply(this, arguments));
    };
}

module.exports = validateStyleMin;

},{"./reference/latest":54,"./validate/validate":64,"./validate/validate_constants":68,"./validate/validate_filter":71,"./validate/validate_glyphs_url":73,"./validate/validate_layer":74,"./validate/validate_layout_property":75,"./validate/validate_light":76,"./validate/validate_paint_property":79,"./validate/validate_source":81}],85:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":86}],86:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],87:[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],88:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],89:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],90:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":88,"./encode":89}],91:[function(require,module,exports){
/*!
 * sort-asc <https://github.com/helpers/sort-asc>
 *
 * Copyright (c) 2014 Jon Schlinkert, contributors.
 * Licensed under the MIT License
 */

'use strict';

module.exports = function (a, b) {
  return b < a ? -1 : 1;
};
},{}],92:[function(require,module,exports){
/*!
 * sort-desc <https://github.com/helpers/sort-desc>
 *
 * Copyright (c) 2014 Jon Schlinkert, contributors.
 * Licensed under the MIT License
 */

'use strict';

module.exports = function (a, b) {
  return a < b ? -1 : 1;
};
},{}],93:[function(require,module,exports){
/*!
 * sort-keys <https://github.com/helpers/sort-keys>
 *
 * Copyright (c) 2014 Brian Woodward, Jon Schlinkert, contributors.
 * Licensed under the MIT License
 */

'use strict';

var sortDesc = require('sort-desc');
var sortAsc = require('sort-asc');


module.exports = function (obj, options) {
  var sort = {desc: sortDesc, asc: sortAsc};
  var fn, opts = {}, keys = Object.keys(obj);

  // if `options` is an array, assume it's keys
  if (Array.isArray(options)) {
    opts.keys = options;
    options = {};

  // if `options` is a function, assume it's a sorting function
  } else if (typeof options === 'function') {
    fn = options;
  } else {
    for (var opt in options) {
      if (options.hasOwnProperty(opt)) {
        opts[opt] = options[opt]
      }
    }
  }

  // Default sort order is descending
  fn = opts.sort || sortDesc;

  if (Boolean(opts.sortOrder)) {
    fn = sort[opts.sortOrder.toLowerCase()];
  }

  if (Boolean(opts.sortBy)) {
    keys = opts.sortBy(obj);
    fn = null;
  }

  if (Boolean(opts.keys)) {
    keys = opts.keys;
    if (!opts.sort && !opts.sortOrder && !opts.sortBy) {
      fn = null;
    }
  }

  if (fn) {
    keys = keys.sort(fn);
  }

  var o = {};
  var len = keys.length;
  var i = -1;

  while (++i < len) {
    o[keys[i]] = obj[keys[i]];
  }

  return o;
};
},{"sort-asc":91,"sort-desc":92}],94:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

},{"./util":95,"punycode":87,"querystring":90}],95:[function(require,module,exports){
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

},{}],96:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],97:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],98:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":97,"_process":86,"inherits":96}]},{},[1])(1)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvVXNlcnMvYW5hbmQvYy9tYXBib3gvbWFwYm94LWdsLWV4cHJlc3Npb25zL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtYXBib3gvdW5pdGJlemllci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hc3NlcnQvYXNzZXJ0LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbGliL19lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY3NzY29sb3JwYXJzZXIvY3NzY29sb3JwYXJzZXIuanMiLCJub2RlX21vZHVsZXMvc3JjL2NvbnZlcnQveG1sLmpzIiwibm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanNvbi1zdHJpbmdpZnktcHJldHR5LWNvbXBhY3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanNvbmxpbnQtbGluZXMtcHJpbWl0aXZlcy9saWIvanNvbmxpbnQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoLl9iYXNlaXNlcXVhbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2guX2JpbmRjYWxsYmFjay9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2guX2dldG5hdGl2ZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2guaXNhcmd1bWVudHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoLmlzYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoLmlzZXF1YWwvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoLmlzdHlwZWRhcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gua2V5cy9pbmRleC5qcyIsIi9Vc2Vycy9hbmFuZC9jL21hcGJveC9tYXBib3gtZ2wtZXhwcmVzc2lvbnMvbm9kZV9tb2R1bGVzL21hcGJveC1nbC9zcmMvc3R5bGUtc3BlYy9jb21wb3NpdGUuanMiLCIvVXNlcnMvYW5hbmQvYy9tYXBib3gvbWFwYm94LWdsLWV4cHJlc3Npb25zL25vZGVfbW9kdWxlcy9tYXBib3gtZ2wvc3JjL3N0eWxlLXNwZWMvZGlmZi5qcyIsIi9Vc2Vycy9hbmFuZC9jL21hcGJveC9tYXBib3gtZ2wtZXhwcmVzc2lvbnMvbm9kZV9tb2R1bGVzL21hcGJveC1nbC9zcmMvc3R5bGUtc3BlYy9lcnJvci9wYXJzaW5nX2Vycm9yLmpzIiwiL1VzZXJzL2FuYW5kL2MvbWFwYm94L21hcGJveC1nbC1leHByZXNzaW9ucy9ub2RlX21vZHVsZXMvbWFwYm94LWdsL3NyYy9zdHlsZS1zcGVjL2Vycm9yL3ZhbGlkYXRpb25fZXJyb3IuanMiLCIvVXNlcnMvYW5hbmQvYy9tYXBib3gvbWFwYm94LWdsLWV4cHJlc3Npb25zL25vZGVfbW9kdWxlcy9tYXBib3gtZ2wvc3JjL3N0eWxlLXNwZWMvZXhwcmVzc2lvbi9jb21wb3VuZF9leHByZXNzaW9uLmpzIiwiL1VzZXJzL2FuYW5kL2MvbWFwYm94L21hcGJveC1nbC1leHByZXNzaW9ucy9ub2RlX21vZHVsZXMvbWFwYm94LWdsL3NyYy9zdHlsZS1zcGVjL2V4cHJlc3Npb24vZGVmaW5pdGlvbnMvYXJyYXkuanMiLCIvVXNlcnMvYW5hbmQvYy9tYXBib3gvbWFwYm94LWdsLWV4cHJlc3Npb25zL25vZGVfbW9kdWxlcy9tYXBib3gtZ2wvc3JjL3N0eWxlLXNwZWMvZXhwcmVzc2lvbi9kZWZpbml0aW9ucy9hc3NlcnRpb24uanMiLCIvVXNlcnMvYW5hbmQvYy9tYXBib3gvbWFwYm94LWdsLWV4cHJlc3Npb25zL25vZGVfbW9kdWxlcy9tYXBib3gtZ2wvc3JjL3N0eWxlLXNwZWMvZXhwcmVzc2lvbi9kZWZpbml0aW9ucy9hdC5qcyIsIi9Vc2Vycy9hbmFuZC9jL21hcGJveC9tYXBib3gtZ2wtZXhwcmVzc2lvbnMvbm9kZV9tb2R1bGVzL21hcGJveC1nbC9zcmMvc3R5bGUtc3BlYy9leHByZXNzaW9uL2RlZmluaXRpb25zL2Nhc2UuanMiLCIvVXNlcnMvYW5hbmQvYy9tYXBib3gvbWFwYm94LWdsLWV4cHJlc3Npb25zL25vZGVfbW9kdWxlcy9tYXBib3gtZ2wvc3JjL3N0eWxlLXNwZWMvZXhwcmVzc2lvbi9kZWZpbml0aW9ucy9jb2FsZXNjZS5qcyIsIi9Vc2Vycy9hbmFuZC9jL21hcGJveC9tYXBib3gtZ2wtZXhwcmVzc2lvbnMvbm9kZV9tb2R1bGVzL21hcGJveC1nbC9zcmMvc3R5bGUtc3BlYy9leHByZXNzaW9uL2RlZmluaXRpb25zL2NvZXJjaW9uLmpzIiwiL1VzZXJzL2FuYW5kL2MvbWFwYm94L21hcGJveC1nbC1leHByZXNzaW9ucy9ub2RlX21vZHVsZXMvbWFwYm94LWdsL3NyYy9zdHlsZS1zcGVjL2V4cHJlc3Npb24vZGVmaW5pdGlvbnMvY3VydmUuanMiLCIvVXNlcnMvYW5hbmQvYy9tYXBib3gvbWFwYm94LWdsLWV4cHJlc3Npb25zL25vZGVfbW9kdWxlcy9tYXBib3gtZ2wvc3JjL3N0eWxlLXNwZWMvZXhwcmVzc2lvbi9kZWZpbml0aW9ucy9pbmRleC5qcyIsIi9Vc2Vycy9hbmFuZC9jL21hcGJveC9tYXBib3gtZ2wtZXhwcmVzc2lvbnMvbm9kZV9tb2R1bGVzL21hcGJveC1nbC9zcmMvc3R5bGUtc3BlYy9leHByZXNzaW9uL2RlZmluaXRpb25zL2xldC5qcyIsIi9Vc2Vycy9hbmFuZC9jL21hcGJveC9tYXBib3gtZ2wtZXhwcmVzc2lvbnMvbm9kZV9tb2R1bGVzL21hcGJveC1nbC9zcmMvc3R5bGUtc3BlYy9leHByZXNzaW9uL2RlZmluaXRpb25zL2xpdGVyYWwuanMiLCIvVXNlcnMvYW5hbmQvYy9tYXBib3gvbWFwYm94LWdsLWV4cHJlc3Npb25zL25vZGVfbW9kdWxlcy9tYXBib3gtZ2wvc3JjL3N0eWxlLXNwZWMvZXhwcmVzc2lvbi9kZWZpbml0aW9ucy9tYXRjaC5qcyIsIi9Vc2Vycy9hbmFuZC9jL21hcGJveC9tYXBib3gtZ2wtZXhwcmVzc2lvbnMvbm9kZV9tb2R1bGVzL21hcGJveC1nbC9zcmMvc3R5bGUtc3BlYy9leHByZXNzaW9uL2RlZmluaXRpb25zL3Zhci5qcyIsIi9Vc2Vycy9hbmFuZC9jL21hcGJveC9tYXBib3gtZ2wtZXhwcmVzc2lvbnMvbm9kZV9tb2R1bGVzL21hcGJveC1nbC9zcmMvc3R5bGUtc3BlYy9leHByZXNzaW9uL2V2YWx1YXRpb25fY29udGV4dC5qcyIsIi9Vc2Vycy9hbmFuZC9jL21hcGJveC9tYXBib3gtZ2wtZXhwcmVzc2lvbnMvbm9kZV9tb2R1bGVzL21hcGJveC1nbC9zcmMvc3R5bGUtc3BlYy9leHByZXNzaW9uL2luZGV4LmpzIiwiL1VzZXJzL2FuYW5kL2MvbWFwYm94L21hcGJveC1nbC1leHByZXNzaW9ucy9ub2RlX21vZHVsZXMvbWFwYm94LWdsL3NyYy9zdHlsZS1zcGVjL2V4cHJlc3Npb24vaXNfY29uc3RhbnQuanMiLCIvVXNlcnMvYW5hbmQvYy9tYXBib3gvbWFwYm94LWdsLWV4cHJlc3Npb25zL25vZGVfbW9kdWxlcy9tYXBib3gtZ2wvc3JjL3N0eWxlLXNwZWMvZXhwcmVzc2lvbi9wYXJzaW5nX2NvbnRleHQuanMiLCIvVXNlcnMvYW5hbmQvYy9tYXBib3gvbWFwYm94LWdsLWV4cHJlc3Npb25zL25vZGVfbW9kdWxlcy9tYXBib3gtZ2wvc3JjL3N0eWxlLXNwZWMvZXhwcmVzc2lvbi9wYXJzaW5nX2Vycm9yLmpzIiwiL1VzZXJzL2FuYW5kL2MvbWFwYm94L21hcGJveC1nbC1leHByZXNzaW9ucy9ub2RlX21vZHVsZXMvbWFwYm94LWdsL3NyYy9zdHlsZS1zcGVjL2V4cHJlc3Npb24vcnVudGltZV9lcnJvci5qcyIsIi9Vc2Vycy9hbmFuZC9jL21hcGJveC9tYXBib3gtZ2wtZXhwcmVzc2lvbnMvbm9kZV9tb2R1bGVzL21hcGJveC1nbC9zcmMvc3R5bGUtc3BlYy9leHByZXNzaW9uL3Njb3BlLmpzIiwiL1VzZXJzL2FuYW5kL2MvbWFwYm94L21hcGJveC1nbC1leHByZXNzaW9ucy9ub2RlX21vZHVsZXMvbWFwYm94LWdsL3NyYy9zdHlsZS1zcGVjL2V4cHJlc3Npb24vdHlwZXMuanMiLCIvVXNlcnMvYW5hbmQvYy9tYXBib3gvbWFwYm94LWdsLWV4cHJlc3Npb25zL25vZGVfbW9kdWxlcy9tYXBib3gtZ2wvc3JjL3N0eWxlLXNwZWMvZXhwcmVzc2lvbi92YWx1ZXMuanMiLCIvVXNlcnMvYW5hbmQvYy9tYXBib3gvbWFwYm94LWdsLWV4cHJlc3Npb25zL25vZGVfbW9kdWxlcy9tYXBib3gtZ2wvc3JjL3N0eWxlLXNwZWMvZmVhdHVyZV9maWx0ZXIvaW5kZXguanMiLCIvVXNlcnMvYW5hbmQvYy9tYXBib3gvbWFwYm94LWdsLWV4cHJlc3Npb25zL25vZGVfbW9kdWxlcy9tYXBib3gtZ2wvc3JjL3N0eWxlLXNwZWMvZm9ybWF0LmpzIiwiL1VzZXJzL2FuYW5kL2MvbWFwYm94L21hcGJveC1nbC1leHByZXNzaW9ucy9ub2RlX21vZHVsZXMvbWFwYm94LWdsL3NyYy9zdHlsZS1zcGVjL2Z1bmN0aW9uL2NvbnZlcnQuanMiLCIvVXNlcnMvYW5hbmQvYy9tYXBib3gvbWFwYm94LWdsLWV4cHJlc3Npb25zL25vZGVfbW9kdWxlcy9tYXBib3gtZ2wvc3JjL3N0eWxlLXNwZWMvZnVuY3Rpb24vaW5kZXguanMiLCIvVXNlcnMvYW5hbmQvYy9tYXBib3gvbWFwYm94LWdsLWV4cHJlc3Npb25zL25vZGVfbW9kdWxlcy9tYXBib3gtZ2wvc3JjL3N0eWxlLXNwZWMvaW5kZXguanMiLCIvVXNlcnMvYW5hbmQvYy9tYXBib3gvbWFwYm94LWdsLWV4cHJlc3Npb25zL25vZGVfbW9kdWxlcy9tYXBib3gtZ2wvc3JjL3N0eWxlLXNwZWMvbWlncmF0ZS5qcyIsIi9Vc2Vycy9hbmFuZC9jL21hcGJveC9tYXBib3gtZ2wtZXhwcmVzc2lvbnMvbm9kZV9tb2R1bGVzL21hcGJveC1nbC9zcmMvc3R5bGUtc3BlYy9taWdyYXRlL3Y3LmpzIiwiL1VzZXJzL2FuYW5kL2MvbWFwYm94L21hcGJveC1nbC1leHByZXNzaW9ucy9ub2RlX21vZHVsZXMvbWFwYm94LWdsL3NyYy9zdHlsZS1zcGVjL21pZ3JhdGUvdjguanMiLCIvVXNlcnMvYW5hbmQvYy9tYXBib3gvbWFwYm94LWdsLWV4cHJlc3Npb25zL25vZGVfbW9kdWxlcy9tYXBib3gtZ2wvc3JjL3N0eWxlLXNwZWMvcmVmZXJlbmNlL2xhdGVzdC5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvc3JjL3N0eWxlLXNwZWMvcmVmZXJlbmNlL3Y2Lmpzb24iLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL3NyYy9zdHlsZS1zcGVjL3JlZmVyZW5jZS92Ny5qc29uIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9zcmMvc3R5bGUtc3BlYy9yZWZlcmVuY2UvdjguanNvbiIsIi9Vc2Vycy9hbmFuZC9jL21hcGJveC9tYXBib3gtZ2wtZXhwcmVzc2lvbnMvbm9kZV9tb2R1bGVzL21hcGJveC1nbC9zcmMvc3R5bGUtc3BlYy91dGlsL2NvbG9yX3NwYWNlcy5qcyIsIi9Vc2Vycy9hbmFuZC9jL21hcGJveC9tYXBib3gtZ2wtZXhwcmVzc2lvbnMvbm9kZV9tb2R1bGVzL21hcGJveC1nbC9zcmMvc3R5bGUtc3BlYy91dGlsL2V4dGVuZC5qcyIsIi9Vc2Vycy9hbmFuZC9jL21hcGJveC9tYXBib3gtZ2wtZXhwcmVzc2lvbnMvbm9kZV9tb2R1bGVzL21hcGJveC1nbC9zcmMvc3R5bGUtc3BlYy91dGlsL2dldF90eXBlLmpzIiwiL1VzZXJzL2FuYW5kL2MvbWFwYm94L21hcGJveC1nbC1leHByZXNzaW9ucy9ub2RlX21vZHVsZXMvbWFwYm94LWdsL3NyYy9zdHlsZS1zcGVjL3V0aWwvaW50ZXJwb2xhdGUuanMiLCIvVXNlcnMvYW5hbmQvYy9tYXBib3gvbWFwYm94LWdsLWV4cHJlc3Npb25zL25vZGVfbW9kdWxlcy9tYXBib3gtZ2wvc3JjL3N0eWxlLXNwZWMvdXRpbC9wYXJzZV9jb2xvci5qcyIsIi9Vc2Vycy9hbmFuZC9jL21hcGJveC9tYXBib3gtZ2wtZXhwcmVzc2lvbnMvbm9kZV9tb2R1bGVzL21hcGJveC1nbC9zcmMvc3R5bGUtc3BlYy91dGlsL3VuYnVuZGxlX2pzb25saW50LmpzIiwiL1VzZXJzL2FuYW5kL2MvbWFwYm94L21hcGJveC1nbC1leHByZXNzaW9ucy9ub2RlX21vZHVsZXMvbWFwYm94LWdsL3NyYy9zdHlsZS1zcGVjL3ZhbGlkYXRlL3ZhbGlkYXRlLmpzIiwiL1VzZXJzL2FuYW5kL2MvbWFwYm94L21hcGJveC1nbC1leHByZXNzaW9ucy9ub2RlX21vZHVsZXMvbWFwYm94LWdsL3NyYy9zdHlsZS1zcGVjL3ZhbGlkYXRlL3ZhbGlkYXRlX2FycmF5LmpzIiwiL1VzZXJzL2FuYW5kL2MvbWFwYm94L21hcGJveC1nbC1leHByZXNzaW9ucy9ub2RlX21vZHVsZXMvbWFwYm94LWdsL3NyYy9zdHlsZS1zcGVjL3ZhbGlkYXRlL3ZhbGlkYXRlX2Jvb2xlYW4uanMiLCIvVXNlcnMvYW5hbmQvYy9tYXBib3gvbWFwYm94LWdsLWV4cHJlc3Npb25zL25vZGVfbW9kdWxlcy9tYXBib3gtZ2wvc3JjL3N0eWxlLXNwZWMvdmFsaWRhdGUvdmFsaWRhdGVfY29sb3IuanMiLCIvVXNlcnMvYW5hbmQvYy9tYXBib3gvbWFwYm94LWdsLWV4cHJlc3Npb25zL25vZGVfbW9kdWxlcy9tYXBib3gtZ2wvc3JjL3N0eWxlLXNwZWMvdmFsaWRhdGUvdmFsaWRhdGVfY29uc3RhbnRzLmpzIiwiL1VzZXJzL2FuYW5kL2MvbWFwYm94L21hcGJveC1nbC1leHByZXNzaW9ucy9ub2RlX21vZHVsZXMvbWFwYm94LWdsL3NyYy9zdHlsZS1zcGVjL3ZhbGlkYXRlL3ZhbGlkYXRlX2VudW0uanMiLCIvVXNlcnMvYW5hbmQvYy9tYXBib3gvbWFwYm94LWdsLWV4cHJlc3Npb25zL25vZGVfbW9kdWxlcy9tYXBib3gtZ2wvc3JjL3N0eWxlLXNwZWMvdmFsaWRhdGUvdmFsaWRhdGVfZXhwcmVzc2lvbi5qcyIsIi9Vc2Vycy9hbmFuZC9jL21hcGJveC9tYXBib3gtZ2wtZXhwcmVzc2lvbnMvbm9kZV9tb2R1bGVzL21hcGJveC1nbC9zcmMvc3R5bGUtc3BlYy92YWxpZGF0ZS92YWxpZGF0ZV9maWx0ZXIuanMiLCIvVXNlcnMvYW5hbmQvYy9tYXBib3gvbWFwYm94LWdsLWV4cHJlc3Npb25zL25vZGVfbW9kdWxlcy9tYXBib3gtZ2wvc3JjL3N0eWxlLXNwZWMvdmFsaWRhdGUvdmFsaWRhdGVfZnVuY3Rpb24uanMiLCIvVXNlcnMvYW5hbmQvYy9tYXBib3gvbWFwYm94LWdsLWV4cHJlc3Npb25zL25vZGVfbW9kdWxlcy9tYXBib3gtZ2wvc3JjL3N0eWxlLXNwZWMvdmFsaWRhdGUvdmFsaWRhdGVfZ2x5cGhzX3VybC5qcyIsIi9Vc2Vycy9hbmFuZC9jL21hcGJveC9tYXBib3gtZ2wtZXhwcmVzc2lvbnMvbm9kZV9tb2R1bGVzL21hcGJveC1nbC9zcmMvc3R5bGUtc3BlYy92YWxpZGF0ZS92YWxpZGF0ZV9sYXllci5qcyIsIi9Vc2Vycy9hbmFuZC9jL21hcGJveC9tYXBib3gtZ2wtZXhwcmVzc2lvbnMvbm9kZV9tb2R1bGVzL21hcGJveC1nbC9zcmMvc3R5bGUtc3BlYy92YWxpZGF0ZS92YWxpZGF0ZV9sYXlvdXRfcHJvcGVydHkuanMiLCIvVXNlcnMvYW5hbmQvYy9tYXBib3gvbWFwYm94LWdsLWV4cHJlc3Npb25zL25vZGVfbW9kdWxlcy9tYXBib3gtZ2wvc3JjL3N0eWxlLXNwZWMvdmFsaWRhdGUvdmFsaWRhdGVfbGlnaHQuanMiLCIvVXNlcnMvYW5hbmQvYy9tYXBib3gvbWFwYm94LWdsLWV4cHJlc3Npb25zL25vZGVfbW9kdWxlcy9tYXBib3gtZ2wvc3JjL3N0eWxlLXNwZWMvdmFsaWRhdGUvdmFsaWRhdGVfbnVtYmVyLmpzIiwiL1VzZXJzL2FuYW5kL2MvbWFwYm94L21hcGJveC1nbC1leHByZXNzaW9ucy9ub2RlX21vZHVsZXMvbWFwYm94LWdsL3NyYy9zdHlsZS1zcGVjL3ZhbGlkYXRlL3ZhbGlkYXRlX29iamVjdC5qcyIsIi9Vc2Vycy9hbmFuZC9jL21hcGJveC9tYXBib3gtZ2wtZXhwcmVzc2lvbnMvbm9kZV9tb2R1bGVzL21hcGJveC1nbC9zcmMvc3R5bGUtc3BlYy92YWxpZGF0ZS92YWxpZGF0ZV9wYWludF9wcm9wZXJ0eS5qcyIsIi9Vc2Vycy9hbmFuZC9jL21hcGJveC9tYXBib3gtZ2wtZXhwcmVzc2lvbnMvbm9kZV9tb2R1bGVzL21hcGJveC1nbC9zcmMvc3R5bGUtc3BlYy92YWxpZGF0ZS92YWxpZGF0ZV9wcm9wZXJ0eS5qcyIsIi9Vc2Vycy9hbmFuZC9jL21hcGJveC9tYXBib3gtZ2wtZXhwcmVzc2lvbnMvbm9kZV9tb2R1bGVzL21hcGJveC1nbC9zcmMvc3R5bGUtc3BlYy92YWxpZGF0ZS92YWxpZGF0ZV9zb3VyY2UuanMiLCIvVXNlcnMvYW5hbmQvYy9tYXBib3gvbWFwYm94LWdsLWV4cHJlc3Npb25zL25vZGVfbW9kdWxlcy9tYXBib3gtZ2wvc3JjL3N0eWxlLXNwZWMvdmFsaWRhdGUvdmFsaWRhdGVfc3RyaW5nLmpzIiwiL1VzZXJzL2FuYW5kL2MvbWFwYm94L21hcGJveC1nbC1leHByZXNzaW9ucy9ub2RlX21vZHVsZXMvbWFwYm94LWdsL3NyYy9zdHlsZS1zcGVjL3ZhbGlkYXRlX3N0eWxlLmpzIiwiL1VzZXJzL2FuYW5kL2MvbWFwYm94L21hcGJveC1nbC1leHByZXNzaW9ucy9ub2RlX21vZHVsZXMvbWFwYm94LWdsL3NyYy9zdHlsZS1zcGVjL3ZhbGlkYXRlX3N0eWxlLm1pbi5qcyIsIm5vZGVfbW9kdWxlcy9wYXRoLWJyb3dzZXJpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmpzIiwibm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9kZWNvZGUuanMiLCJub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2VuY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc29ydC1hc2MvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc29ydC1kZXNjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NvcnQtb2JqZWN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3VybC91cmwuanMiLCJub2RlX21vZHVsZXMvdXJsL3V0aWwuanMiLCJub2RlX21vZHVsZXMvdXRpbC9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBLFlBQVksQ0FBQzs7QUFFYixHQUFLLENBQUMsZUFBZSxHQUFHLE9BQU8sQ0FBQywyQ0FBMkMsQ0FBQyxDQUFDO0FBQzdFLEFBQUssQUFBbUIsT0FBQSxHQUFHLE9BQU8sQ0FBQyxxQ0FBcUMsQ0FBQztBQUFsRSxJQUFBLGdCQUFnQix3QkFBakIsQUFBaUIsQUFBa0QsQUFBQztBQUMxRSxBQUFLLEFBQWEsU0FBQSxHQUFHLE9BQU8sQ0FBQyxtQ0FBbUMsQ0FBQztBQUExRCxJQUFBLFVBQVUsb0JBQVgsQUFBVyxBQUFnRCxBQUFDO0FBQ2xFLEdBQUssQ0FBQyxRQUFRLEdBQUcsT0FBTyxDQUFDLDBCQUEwQixDQUFDLENBQUMsUUFBUSxDQUFDO0FBQzlELEdBQUssQ0FBQyxJQUFJLEdBQUcsT0FBTyxDQUFDLDRDQUE0QyxDQUFDLENBQUM7O0FBRW5FLEdBQUssQ0FBQyxTQUFTLEdBQUcsT0FBTyxDQUFDLCtCQUErQixDQUFDLENBQUM7QUFDM0QsR0FBSyxDQUFDLElBQUksR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7O0FBRTdCLEdBQUssQ0FBQyxZQUFZLEdBQUc7SUFDakIsT0FBTyxFQUFFLENBQUM7SUFDVixPQUFPLEVBQUU7UUFDTCxNQUFNLEVBQUU7WUFDSixJQUFJLEVBQUUsUUFBUTtZQUNkLEdBQUcsRUFBRSw0QkFBNEI7U0FDcEM7S0FDSjtJQUNELE1BQU0sRUFBRSxDQUFDO1FB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QUFDQTtBQUNBO0FBQ0E7OztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMWVBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbHJEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O2dDQ3pNZ0IsbUIsR0FBQSxtQjtBQUFULFNBQVMsbUJBQVQsQ0FBNkIsT0FBN0IsRUFBc0M7QUFDM0MsTUFBSSxNQUFNLEVBQVY7QUFDQSxPQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksUUFBUSxNQUE1QixFQUFvQyxHQUFwQyxFQUF5QztBQUN2QyxRQUFJLFNBQVMsUUFBUSxDQUFSLENBQWI7QUFDQSxRQUFJLE9BQU8sS0FBWCxFQUFrQjtBQUNoQixVQUFJLElBQUosQ0FBUyxPQUFUO0FBQ0QsS0FGRCxNQUVPLElBQUksT0FBTyxPQUFYLEVBQW9CO0FBQ3pCLFVBQUksSUFBSixDQUFTLE9BQVQ7QUFDRDs7QUFFRCxRQUFJLElBQUosQ0FBUyxXQUFXLE9BQU8sS0FBbEIsQ0FBVDs7QUFFQSxRQUFJLE9BQU8sS0FBWCxFQUFrQjtBQUNoQixVQUFJLElBQUosQ0FBUyxRQUFUO0FBQ0QsS0FGRCxNQUVPLElBQUksT0FBTyxPQUFYLEVBQW9CO0FBQ3pCLFVBQUksSUFBSixDQUFTLFFBQVQ7QUFDRDtBQUNGO0FBQ0QsU0FBTyxJQUFJLElBQUosQ0FBUyxFQUFULENBQVA7QUFDRDs7QUFFRCxTQUFTLFVBQVQsQ0FBb0IsQ0FBcEIsRUFBdUI7QUFDckIsTUFBSSxJQUFJLENBQVI7QUFDQSxNQUFJLEVBQUUsT0FBRixDQUFVLElBQVYsRUFBZ0IsT0FBaEIsQ0FBSjtBQUNBLE1BQUksRUFBRSxPQUFGLENBQVUsSUFBVixFQUFnQixNQUFoQixDQUFKO0FBQ0EsTUFBSSxFQUFFLE9BQUYsQ0FBVSxJQUFWLEVBQWdCLE1BQWhCLENBQUo7QUFDQSxNQUFJLEVBQUUsT0FBRixDQUFVLElBQVYsRUFBZ0IsUUFBaEIsQ0FBSjs7QUFFQSxTQUFPLENBQVA7QUFDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzdCRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNuckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVPQTtBQUNBLE1BQU0sQ0FBQyxPQUFPLEdBQUcsVUFBVSxLQUFLLEVBQUU7SUFDOUIsR0FBSyxDQUFDLFFBQVEsR0FBRyxFQUFFLENBQUM7SUFDcEIsR0FBSyxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUM7SUFDckIsR0FBSyxDQUFDLHNCQUFzQixHQUFHLEVBQUUsQ0FBQzs7SUFFbEMsS0FBSyxHQUFLLENBQUMsRUFBRSxJQUFJLEtBQUssQ0FBQyxPQUFPLEVBQUU7UUFDNUIsR0FBSyxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDOztRQUVqQyxJQUFJLE1BQU0sQ0FBQyxJQUFJLEtBQUssUUFBUTtZQUN4QixFQUFBLFNBQVMsRUFBQTs7UUFFYixHQUFLLENBQUMsS0FBSyxHQUFHLGtCQUFrQixDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDbEQs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RWxCLElBQUk7O1FBRUEsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxPQUFPLENBQUMsRUFBRTtZQUN6QyxPQUFPLENBQUMsRUFBRSxPQUFPLEVBQUUsVUFBVSxDQUFDLFFBQVEsRUFBRSxJQUFJLEVBQUUsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7U0FDNUQ7UUFDRCxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQ3ZDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRSxPQUFPLEVBQUUsVUFBVSxDQUFDLFNBQVMsRUFBRSxJQUFJLEVBQUUsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1NBQzFFO1FBQ0QsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUNuQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUUsT0FBTyxFQUFFLFVBQVUsQ0FBQyxPQUFPLEVBQUUsSUFBSSxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztTQUN0RTtRQUNELElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLE9BQU8sRUFBRSxLQUFLLENBQUMsT0FBTyxDQUFDLEVBQUU7WUFDekMsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFLE9BQU8sRUFBRSxVQUFVLENBQUMsVUFBVSxFQUFFLElBQUksRUFBRSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLENBQUM7U0FDNUU7UUFDRCxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ3JDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRSxPQUFPLEVBQUUsVUFBVSxDQUFDLFFBQVEsRUFBRSxJQUFJLEVBQUUsQ0FBQyxLQUFLLENBQUMsS0FBSyxD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LENBQUMsS0FBSyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUU7QUFDeEUsU0FBUyxFQUFFLENBQUMsR0FBRyxFQUFFLEdBQUEsQUFBRSxBQUFHLEFBQUMsRUFBRSxDQUFQO0lBQUEsQ0FBQyxVQUFFO0lBQUEsQ0FBQztBQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRTtBQUN4RSxTQUFTLEVBQUUsQ0FBQyxHQUFHLEVBQUUsR0FBQSxBQUFFLEFBQUcsQUFBQyxFQUFFLENBQVA7SUFBQSxDQUFDLFVBQUU7SUFBQSxDQUFDO0FBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFO0FBQ3RFLFNBQVMsRUFBRSxDQUFDLEdBQUcsRUFBRSxHQUFBLEFBQUUsQUFBRyxBQUFDLEVBQUUsQ0FBUDtJQUFBLENBQUMsVUFBRTtJQUFBLENBQUM7QUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUU7QUFDdEUsU0FBUyxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUEsQUFBRSxBQUFHLEFBQUMsRUFBRSxDQUFQO0lBQUEsQ0FBQyxVQUFFO0lBQUEsQ0FBQztBQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRTtBQUN6RSxTQUFTLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBQSxBQUFFLEFBQUcsQUFBQyxFQUFFLENBQVA7SUFBQSxDQUFDLFVBQUU7SUFBQSxDQUFDO0FBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcmxDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2cUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbm9IQTs7QUFFQSxH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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1dEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgY29udmVydEZ1bmN0aW9uID0gcmVxdWlyZSgnbWFwYm94LWdsL3NyYy9zdHlsZS1zcGVjL2Z1bmN0aW9uL2NvbnZlcnQnKTtcbmNvbnN0IHtjcmVhdGVFeHByZXNzaW9ufSA9IHJlcXVpcmUoJ21hcGJveC1nbC9zcmMvc3R5bGUtc3BlYy9leHByZXNzaW9uJyk7XG5jb25zdCB7aXNGdW5jdGlvbn0gPSByZXF1aXJlKCdtYXBib3gtZ2wvc3JjL3N0eWxlLXNwZWMvZnVuY3Rpb24nKTtcbmNvbnN0IHZhbGlkYXRlID0gcmVxdWlyZSgnbWFwYm94LWdsL3NyYy9zdHlsZS1zcGVjJykudmFsaWRhdGU7XG5jb25zdCBzcGVjID0gcmVxdWlyZSgnbWFwYm94LWdsL3NyYy9zdHlsZS1zcGVjL3JlZmVyZW5jZS92OC5qc29uJyk7XG5cbmNvbnN0IHN0cmluZ2lmeSA9IHJlcXVpcmUoJ2pzb24tc3RyaW5naWZ5LXByZXR0eS1jb21wYWN0Jyk7XG5jb25zdCBkaWZmID0gcmVxdWlyZSgnZGlmZicpO1xuXG5jb25zdCBpbml0aWFsU3R5bGUgPSB7XG4gICAgdmVyc2lvbjogOCxcbiAgICBzb3VyY2VzOiB7XG4gICAgICAgIG1hcGJveDoge1xuICAgICAgICAgICAgdHlwZTogJ3ZlY3RvcicsXG4gICAgICAgICAgICB1cmw6ICdtYXBib3g6Ly9tYXBib3gtc3RyZWV0cy12NydcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbGF5ZXJzOiBbe1xuICAgICAgICBpZDogJ3BsYWNlcycsXG4gICAgICAgIHNvdXJjZTogJ21hcGJveCcsXG4gICAgICAgICdzb3VyY2UtbGF5ZXInOiAncG9pX2xhYmVsJyxcbiAgICAgICAgdHlwZTogJ2NpcmNsZScsXG4gICAgICAgIHBhaW50OiB7XG4gICAgICAgICAgICAnY2lyY2xlLXJhZGl1cyc6IHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eTogJ3NjYWxlcmFuaycsXG4gICAgICAgICAgICAgICAgc3RvcHM6IFtcbiAgICAgICAgICAgICAgICAgICAgW3t6b29tOiAwLCB2YWx1ZTogMH0sIDFdLFxuICAgICAgICAgICAgICAgICAgICBbe3pvb206IDAsIHZhbHVlOiA1fSwgM10sXG4gICAgICAgICAgICAgICAgICAgIFt7em9vbTogMTQsIHZhbHVlOiAwfSwgNV0sXG4gICAgICAgICAgICAgICAgICAgIFt7em9vbTogMTQsIHZhbHVlOiA1fSwgMTBdXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfV1cbn07XG5cbmNsYXNzIE1pZ3JhdGlvblRvb2wgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBpbnB1dFN0eWxlOiBzdHJpbmdpZnkoaW5pdGlhbFN0eWxlLCBudWxsLCAyKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vbkVkaXQgPSB0aGlzLm9uRWRpdC5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IGRpZmZPdXRwdXQ7XG4gICAgICAgIGxldCBlcnJvcjtcblxuICAgICAgICBsZXQgdmFsaWRhdGlvbkVycm9ycyA9IHZhbGlkYXRlKHRoaXMuc3RhdGUuaW5wdXRTdHlsZSk7XG4gICAgICAgIGlmICh2YWxpZGF0aW9uRXJyb3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZSh0aGlzLnN0YXRlLmlucHV0U3R5bGUpXG4gICAgICAgICAgICBjb25zdCBtaWdyYXRlZCA9IG1pZ3JhdGUocGFyc2VkKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGRpZmYuZGlmZkxpbmVzKHN0cmluZ2lmeShwYXJzZWQpLCBzdHJpbmdpZnkobWlncmF0ZWQpKTtcbiAgICAgICAgICAgIGRpZmZPdXRwdXQgPSByZXN1bHQubWFwKChwYXJ0LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBrbGFzcyA9ICcnO1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0LmFkZGVkKSB7IGtsYXNzID0nYmctZ3JlZW4tZmFpbnQnOyB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcnQucmVtb3ZlZCkgeyBrbGFzcz0nYmctcmVkLWZhaW50JzsgfVxuICAgICAgICAgICAgICAgIHJldHVybiA8ZGl2IGtleT17aW5kZXh9IGNsYXNzTmFtZT17a2xhc3N9PntwYXJ0LnZhbHVlfTwvZGl2PlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IgPSB2YWxpZGF0aW9uRXJyb3JzLm1hcCgoZXJyb3IsIGluZGV4KSA9PiA8ZGl2IGNsYXNzTmFtZT0nY29sb3ItcmVkLWRhcmsnIGtleT17aW5kZXh9PntlcnJvci5saW5lfToge2Vycm9yLm1lc3NhZ2V9PC9kaXY+KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPSd3LWZ1bGwgZ3JpZCBncmlkLS1ndXQxMiBmbGV4LXBhcmVudC0tc3RyZXRjaC1jcm9zcyc+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nY29sIGNvbC0tMTIgY29sLS1hdXRvLW1sJz5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0naC1mdWxsIHB4MTInPlxuICAgICAgICAgICAgICAgICAgICA8aDMgY2xhc3NOYW1lPVwidHh0LWgzXCI+T3JpZ2luYWw8L2gzPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0ndy1mdWxsIHNjcm9sbC1hdXRvJz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0YXJlYSBjb2xzPXswfSByb3dzPXsyNX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9J3RleHRhcmVhJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXt0aGlzLnN0YXRlLmlucHV0U3R5bGV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMub25FZGl0fVxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSdjb2wgY29sLS0xMiBjb2wtLWF1dG8tbWwnPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSdoLWZ1bGwnPlxuICAgICAgICAgICAgICAgICAgICA8aDMgY2xhc3NOYW1lPVwidHh0LWgzXCI+Q29udmVydGVkIHRvIGV4cHJlc3Npb25zPC9oMz5cbiAgICAgICAgICAgICAgICAgICAge2Vycm9yIHx8IDxkaXYgY2xhc3NOYW1lPVwicHJlXCI+e2RpZmZPdXRwdXR9PC9kaXY+fVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PilcbiAgICB9XG5cbiAgICBvbkVkaXQoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBldmVudC50YXJnZXQudmFsdWU7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe2lucHV0U3R5bGU6IG5ld1ZhbHVlfSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBtaWdyYXRlKHN0eWxlKSB7XG4gICAgY29uc3QgbWlncmF0ZWQgPSBjbG9uZShzdHlsZSk7XG4gICAgbWlncmF0ZWQubGF5ZXJzID0gc3R5bGUubGF5ZXJzLm1hcCgobGF5ZXIpID0+IHtcbiAgICAgICAgY29uc3QgbWlncmF0ZWRMYXllciA9IGNsb25lKGxheWVyKTtcbiAgICAgICAgaWYgKGxheWVyLnBhaW50KSB7XG4gICAgICAgICAgICBtaWdyYXRlZExheWVyLnBhaW50ID0gbWlncmF0ZVByb3BlcnRpZXMobGF5ZXIsICdwYWludCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXllci5sYXlvdXQpIHtcbiAgICAgICAgICAgIG1pZ3JhdGVkTGF5ZXIubGF5b3V0ID0gbWlncmF0ZVByb3BlcnRpZXMobGF5ZXIsICdsYXlvdXQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWlncmF0ZWRMYXllcjtcbiAgICB9KVxuICAgIHJldHVybiBtaWdyYXRlZDtcbn1cblxuZnVuY3Rpb24gbWlncmF0ZVByb3BlcnRpZXMobGF5ZXIsIHR5cGUpIHtcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gY2xvbmUobGF5ZXJbdHlwZV0pO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24ocHJvcGVydGllc1trZXldKSkge1xuICAgICAgICAgICAgY29uc3QgcHJvcGVydHlTcGVjID0gc3BlY1tgJHt0eXBlfV8ke2xheWVyLnR5cGV9YF1ba2V5XTtcbiAgICAgICAgICAgIHByb3BlcnRpZXNba2V5XSA9IGNvbnZlcnRGdW5jdGlvbihwcm9wZXJ0aWVzW2tleV0sIHByb3BlcnR5U3BlYylcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcGVydGllcztcbn1cblxuZnVuY3Rpb24gY2xvbmUoc3JjKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHNyYylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNaWdyYXRpb25Ub29sO1xuIiwiLypcbiAqIENvcHlyaWdodCAoQykgMjAwOCBBcHBsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiAqIGFyZSBtZXQ6XG4gKiAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAqICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBBUFBMRSBJTkMuIGBgQVMgSVMnJyBBTkQgQU5ZXG4gKiBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSXG4gKiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgQVBQTEUgSU5DLiBPUlxuICogQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsXG4gKiBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXG4gKiBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAqIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUllcbiAqIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICogKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4gKiBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICpcbiAqIFBvcnRlZCBmcm9tIFdlYmtpdFxuICogaHR0cDovL3N2bi53ZWJraXQub3JnL3JlcG9zaXRvcnkvd2Via2l0L3RydW5rL1NvdXJjZS9XZWJDb3JlL3BsYXRmb3JtL2dyYXBoaWNzL1VuaXRCZXppZXIuaFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gVW5pdEJlemllcjtcblxuZnVuY3Rpb24gVW5pdEJlemllcihwMXgsIHAxeSwgcDJ4LCBwMnkpIHtcbiAgICAvLyBDYWxjdWxhdGUgdGhlIHBvbHlub21pYWwgY29lZmZpY2llbnRzLCBpbXBsaWNpdCBmaXJzdCBhbmQgbGFzdCBjb250cm9sIHBvaW50cyBhcmUgKDAsMCkgYW5kICgxLDEpLlxuICAgIHRoaXMuY3ggPSAzLjAgKiBwMXg7XG4gICAgdGhpcy5ieCA9IDMuMCAqIChwMnggLSBwMXgpIC0gdGhpcy5jeDtcbiAgICB0aGlzLmF4ID0gMS4wIC0gdGhpcy5jeCAtIHRoaXMuYng7XG5cbiAgICB0aGlzLmN5ID0gMy4wICogcDF5O1xuICAgIHRoaXMuYnkgPSAzLjAgKiAocDJ5IC0gcDF5KSAtIHRoaXMuY3k7XG4gICAgdGhpcy5heSA9IDEuMCAtIHRoaXMuY3kgLSB0aGlzLmJ5O1xuXG4gICAgdGhpcy5wMXggPSBwMXg7XG4gICAgdGhpcy5wMXkgPSBwMnk7XG4gICAgdGhpcy5wMnggPSBwMng7XG4gICAgdGhpcy5wMnkgPSBwMnk7XG59XG5cblVuaXRCZXppZXIucHJvdG90eXBlLnNhbXBsZUN1cnZlWCA9IGZ1bmN0aW9uKHQpIHtcbiAgICAvLyBgYXggdF4zICsgYnggdF4yICsgY3ggdCcgZXhwYW5kZWQgdXNpbmcgSG9ybmVyJ3MgcnVsZS5cbiAgICByZXR1cm4gKCh0aGlzLmF4ICogdCArIHRoaXMuYngpICogdCArIHRoaXMuY3gpICogdDtcbn07XG5cblVuaXRCZXppZXIucHJvdG90eXBlLnNhbXBsZUN1cnZlWSA9IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gKCh0aGlzLmF5ICogdCArIHRoaXMuYnkpICogdCArIHRoaXMuY3kpICogdDtcbn07XG5cblVuaXRCZXppZXIucHJvdG90eXBlLnNhbXBsZUN1cnZlRGVyaXZhdGl2ZVggPSBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuICgzLjAgKiB0aGlzLmF4ICogdCArIDIuMCAqIHRoaXMuYngpICogdCArIHRoaXMuY3g7XG59O1xuXG5Vbml0QmV6aWVyLnByb3RvdHlwZS5zb2x2ZUN1cnZlWCA9IGZ1bmN0aW9uKHgsIGVwc2lsb24pIHtcbiAgICBpZiAodHlwZW9mIGVwc2lsb24gPT09ICd1bmRlZmluZWQnKSBlcHNpbG9uID0gMWUtNjtcblxuICAgIHZhciB0MCwgdDEsIHQyLCB4MiwgaTtcblxuICAgIC8vIEZpcnN0IHRyeSBhIGZldyBpdGVyYXRpb25zIG9mIE5ld3RvbidzIG1ldGhvZCAtLSBub3JtYWxseSB2ZXJ5IGZhc3QuXG4gICAgZm9yICh0MiA9IHgsIGkgPSAwOyBpIDwgODsgaSsrKSB7XG5cbiAgICAgICAgeDIgPSB0aGlzLnNhbXBsZUN1cnZlWCh0MikgLSB4O1xuICAgICAgICBpZiAoTWF0aC5hYnMoeDIpIDwgZXBzaWxvbikgcmV0dXJuIHQyO1xuXG4gICAgICAgIHZhciBkMiA9IHRoaXMuc2FtcGxlQ3VydmVEZXJpdmF0aXZlWCh0Mik7XG4gICAgICAgIGlmIChNYXRoLmFicyhkMikgPCAxZS02KSBicmVhaztcblxuICAgICAgICB0MiA9IHQyIC0geDIgLyBkMjtcbiAgICB9XG5cbiAgICAvLyBGYWxsIGJhY2sgdG8gdGhlIGJpc2VjdGlvbiBtZXRob2QgZm9yIHJlbGlhYmlsaXR5LlxuICAgIHQwID0gMC4wO1xuICAgIHQxID0gMS4wO1xuICAgIHQyID0geDtcblxuICAgIGlmICh0MiA8IHQwKSByZXR1cm4gdDA7XG4gICAgaWYgKHQyID4gdDEpIHJldHVybiB0MTtcblxuICAgIHdoaWxlICh0MCA8IHQxKSB7XG5cbiAgICAgICAgeDIgPSB0aGlzLnNhbXBsZUN1cnZlWCh0Mik7XG4gICAgICAgIGlmIChNYXRoLmFicyh4MiAtIHgpIDwgZXBzaWxvbikgcmV0dXJuIHQyO1xuXG4gICAgICAgIGlmICh4ID4geDIpIHtcbiAgICAgICAgICAgIHQwID0gdDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0MSA9IHQyO1xuICAgICAgICB9XG5cbiAgICAgICAgdDIgPSAodDEgLSB0MCkgKiAwLjUgKyB0MDtcbiAgICB9XG5cbiAgICAvLyBGYWlsdXJlLlxuICAgIHJldHVybiB0Mjtcbn07XG5cblVuaXRCZXppZXIucHJvdG90eXBlLnNvbHZlID0gZnVuY3Rpb24oeCwgZXBzaWxvbikge1xuICAgIHJldHVybiB0aGlzLnNhbXBsZUN1cnZlWSh0aGlzLnNvbHZlQ3VydmVYKHgsIGVwc2lsb24pKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIGNvbXBhcmUgYW5kIGlzQnVmZmVyIHRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvYmxvYi82ODBlOWU1ZTQ4OGYyMmFhYzI3NTk5YTU3ZGM4NDRhNjMxNTkyOGRkL2luZGV4LmpzXG4vLyBvcmlnaW5hbCBub3RpY2U6XG5cbi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIHggPSBhLmxlbmd0aDtcbiAgdmFyIHkgPSBiLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXTtcbiAgICAgIHkgPSBiW2ldO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGlmICh5IDwgeCkge1xuICAgIHJldHVybiAxO1xuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gaXNCdWZmZXIoYikge1xuICBpZiAoZ2xvYmFsLkJ1ZmZlciAmJiB0eXBlb2YgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyKGIpO1xuICB9XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpO1xufVxuXG4vLyBiYXNlZCBvbiBub2RlIGFzc2VydCwgb3JpZ2luYWwgbm90aWNlOlxuXG4vLyBodHRwOi8vd2lraS5jb21tb25qcy5vcmcvd2lraS9Vbml0X1Rlc3RpbmcvMS4wXG4vL1xuLy8gVEhJUyBJUyBOT1QgVEVTVEVEIE5PUiBMSUtFTFkgVE8gV09SSyBPVVRTSURFIFY4IVxuLy9cbi8vIE9yaWdpbmFsbHkgZnJvbSBuYXJ3aGFsLmpzIChodHRwOi8vbmFyd2hhbGpzLm9yZylcbi8vIENvcHlyaWdodCAoYykgMjAwOSBUaG9tYXMgUm9iaW5zb24gPDI4MG5vcnRoLmNvbT5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSAnU29mdHdhcmUnKSwgdG9cbi8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4vLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Jcbi8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgJ0FTIElTJywgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4vLyBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4vLyBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsLycpO1xudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcFNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGZ1bmN0aW9uc0hhdmVOYW1lcyA9IChmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmb28oKSB7fS5uYW1lID09PSAnZm9vJztcbn0oKSk7XG5mdW5jdGlvbiBwVG9TdHJpbmcgKG9iaikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG59XG5mdW5jdGlvbiBpc1ZpZXcoYXJyYnVmKSB7XG4gIGlmIChpc0J1ZmZlcihhcnJidWYpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgZ2xvYmFsLkFycmF5QnVmZmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyhhcnJidWYpO1xuICB9XG4gIGlmICghYXJyYnVmKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChhcnJidWYgaW5zdGFuY2VvZiBEYXRhVmlldykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChhcnJidWYuYnVmZmVyICYmIGFycmJ1Zi5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbi8vIDEuIFRoZSBhc3NlcnQgbW9kdWxlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0aGF0IHRocm93XG4vLyBBc3NlcnRpb25FcnJvcidzIHdoZW4gcGFydGljdWxhciBjb25kaXRpb25zIGFyZSBub3QgbWV0LiBUaGVcbi8vIGFzc2VydCBtb2R1bGUgbXVzdCBjb25mb3JtIHRvIHRoZSBmb2xsb3dpbmcgaW50ZXJmYWNlLlxuXG52YXIgYXNzZXJ0ID0gbW9kdWxlLmV4cG9ydHMgPSBvaztcblxuLy8gMi4gVGhlIEFzc2VydGlvbkVycm9yIGlzIGRlZmluZWQgaW4gYXNzZXJ0LlxuLy8gbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7IG1lc3NhZ2U6IG1lc3NhZ2UsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiBhY3R1YWwsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkIH0pXG5cbnZhciByZWdleCA9IC9cXHMqZnVuY3Rpb25cXHMrKFteXFwoXFxzXSopXFxzKi87XG4vLyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL2Z1bmN0aW9uLnByb3RvdHlwZS5uYW1lL2Jsb2IvYWRlZWVlYzhiZmNjNjA2OGIxODdkN2Q5ZmIzZDViYjFkM2EzMDg5OS9pbXBsZW1lbnRhdGlvbi5qc1xuZnVuY3Rpb24gZ2V0TmFtZShmdW5jKSB7XG4gIGlmICghdXRpbC5pc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChmdW5jdGlvbnNIYXZlTmFtZXMpIHtcbiAgICByZXR1cm4gZnVuYy5uYW1lO1xuICB9XG4gIHZhciBzdHIgPSBmdW5jLnRvU3RyaW5nKCk7XG4gIHZhciBtYXRjaCA9IHN0ci5tYXRjaChyZWdleCk7XG4gIHJldHVybiBtYXRjaCAmJiBtYXRjaFsxXTtcbn1cbmFzc2VydC5Bc3NlcnRpb25FcnJvciA9IGZ1bmN0aW9uIEFzc2VydGlvbkVycm9yKG9wdGlvbnMpIHtcbiAgdGhpcy5uYW1lID0gJ0Fzc2VydGlvbkVycm9yJztcbiAgdGhpcy5hY3R1YWwgPSBvcHRpb25zLmFjdHVhbDtcbiAgdGhpcy5leHBlY3RlZCA9IG9wdGlvbnMuZXhwZWN0ZWQ7XG4gIHRoaXMub3BlcmF0b3IgPSBvcHRpb25zLm9wZXJhdG9yO1xuICBpZiAob3B0aW9ucy5tZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlO1xuICAgIHRoaXMuZ2VuZXJhdGVkTWVzc2FnZSA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubWVzc2FnZSA9IGdldE1lc3NhZ2UodGhpcyk7XG4gICAgdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gdHJ1ZTtcbiAgfVxuICB2YXIgc3RhY2tTdGFydEZ1bmN0aW9uID0gb3B0aW9ucy5zdGFja1N0YXJ0RnVuY3Rpb24gfHwgZmFpbDtcbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgc3RhY2tTdGFydEZ1bmN0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBub24gdjggYnJvd3NlcnMgc28gd2UgY2FuIGhhdmUgYSBzdGFja3RyYWNlXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcigpO1xuICAgIGlmIChlcnIuc3RhY2spIHtcbiAgICAgIHZhciBvdXQgPSBlcnIuc3RhY2s7XG5cbiAgICAgIC8vIHRyeSB0byBzdHJpcCB1c2VsZXNzIGZyYW1lc1xuICAgICAgdmFyIGZuX25hbWUgPSBnZXROYW1lKHN0YWNrU3RhcnRGdW5jdGlvbik7XG4gICAgICB2YXIgaWR4ID0gb3V0LmluZGV4T2YoJ1xcbicgKyBmbl9uYW1lKTtcbiAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAvLyBvbmNlIHdlIGhhdmUgbG9jYXRlZCB0aGUgZnVuY3Rpb24gZnJhbWVcbiAgICAgICAgLy8gd2UgbmVlZCB0byBzdHJpcCBvdXQgZXZlcnl0aGluZyBiZWZvcmUgaXQgKGFuZCBpdHMgbGluZSlcbiAgICAgICAgdmFyIG5leHRfbGluZSA9IG91dC5pbmRleE9mKCdcXG4nLCBpZHggKyAxKTtcbiAgICAgICAgb3V0ID0gb3V0LnN1YnN0cmluZyhuZXh0X2xpbmUgKyAxKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGFjayA9IG91dDtcbiAgICB9XG4gIH1cbn07XG5cbi8vIGFzc2VydC5Bc3NlcnRpb25FcnJvciBpbnN0YW5jZW9mIEVycm9yXG51dGlsLmluaGVyaXRzKGFzc2VydC5Bc3NlcnRpb25FcnJvciwgRXJyb3IpO1xuXG5mdW5jdGlvbiB0cnVuY2F0ZShzLCBuKSB7XG4gIGlmICh0eXBlb2YgcyA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcy5sZW5ndGggPCBuID8gcyA6IHMuc2xpY2UoMCwgbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cbn1cbmZ1bmN0aW9uIGluc3BlY3Qoc29tZXRoaW5nKSB7XG4gIGlmIChmdW5jdGlvbnNIYXZlTmFtZXMgfHwgIXV0aWwuaXNGdW5jdGlvbihzb21ldGhpbmcpKSB7XG4gICAgcmV0dXJuIHV0aWwuaW5zcGVjdChzb21ldGhpbmcpO1xuICB9XG4gIHZhciByYXduYW1lID0gZ2V0TmFtZShzb21ldGhpbmcpO1xuICB2YXIgbmFtZSA9IHJhd25hbWUgPyAnOiAnICsgcmF3bmFtZSA6ICcnO1xuICByZXR1cm4gJ1tGdW5jdGlvbicgKyAgbmFtZSArICddJztcbn1cbmZ1bmN0aW9uIGdldE1lc3NhZ2Uoc2VsZikge1xuICByZXR1cm4gdHJ1bmNhdGUoaW5zcGVjdChzZWxmLmFjdHVhbCksIDEyOCkgKyAnICcgK1xuICAgICAgICAgc2VsZi5vcGVyYXRvciArICcgJyArXG4gICAgICAgICB0cnVuY2F0ZShpbnNwZWN0KHNlbGYuZXhwZWN0ZWQpLCAxMjgpO1xufVxuXG4vLyBBdCBwcmVzZW50IG9ubHkgdGhlIHRocmVlIGtleXMgbWVudGlvbmVkIGFib3ZlIGFyZSB1c2VkIGFuZFxuLy8gdW5kZXJzdG9vZCBieSB0aGUgc3BlYy4gSW1wbGVtZW50YXRpb25zIG9yIHN1YiBtb2R1bGVzIGNhbiBwYXNzXG4vLyBvdGhlciBrZXlzIHRvIHRoZSBBc3NlcnRpb25FcnJvcidzIGNvbnN0cnVjdG9yIC0gdGhleSB3aWxsIGJlXG4vLyBpZ25vcmVkLlxuXG4vLyAzLiBBbGwgb2YgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgbXVzdCB0aHJvdyBhbiBBc3NlcnRpb25FcnJvclxuLy8gd2hlbiBhIGNvcnJlc3BvbmRpbmcgY29uZGl0aW9uIGlzIG5vdCBtZXQsIHdpdGggYSBtZXNzYWdlIHRoYXRcbi8vIG1heSBiZSB1bmRlZmluZWQgaWYgbm90IHByb3ZpZGVkLiAgQWxsIGFzc2VydGlvbiBtZXRob2RzIHByb3ZpZGVcbi8vIGJvdGggdGhlIGFjdHVhbCBhbmQgZXhwZWN0ZWQgdmFsdWVzIHRvIHRoZSBhc3NlcnRpb24gZXJyb3IgZm9yXG4vLyBkaXNwbGF5IHB1cnBvc2VzLlxuXG5mdW5jdGlvbiBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yLCBzdGFja1N0YXJ0RnVuY3Rpb24pIHtcbiAgdGhyb3cgbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7XG4gICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgb3BlcmF0b3I6IG9wZXJhdG9yLFxuICAgIHN0YWNrU3RhcnRGdW5jdGlvbjogc3RhY2tTdGFydEZ1bmN0aW9uXG4gIH0pO1xufVxuXG4vLyBFWFRFTlNJT04hIGFsbG93cyBmb3Igd2VsbCBiZWhhdmVkIGVycm9ycyBkZWZpbmVkIGVsc2V3aGVyZS5cbmFzc2VydC5mYWlsID0gZmFpbDtcblxuLy8gNC4gUHVyZSBhc3NlcnRpb24gdGVzdHMgd2hldGhlciBhIHZhbHVlIGlzIHRydXRoeSwgYXMgZGV0ZXJtaW5lZFxuLy8gYnkgISFndWFyZC5cbi8vIGFzc2VydC5vayhndWFyZCwgbWVzc2FnZV9vcHQpO1xuLy8gVGhpcyBzdGF0ZW1lbnQgaXMgZXF1aXZhbGVudCB0byBhc3NlcnQuZXF1YWwodHJ1ZSwgISFndWFyZCxcbi8vIG1lc3NhZ2Vfb3B0KTsuIFRvIHRlc3Qgc3RyaWN0bHkgZm9yIHRoZSB2YWx1ZSB0cnVlLCB1c2Vcbi8vIGFzc2VydC5zdHJpY3RFcXVhbCh0cnVlLCBndWFyZCwgbWVzc2FnZV9vcHQpOy5cblxuZnVuY3Rpb24gb2sodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKCF2YWx1ZSkgZmFpbCh2YWx1ZSwgdHJ1ZSwgbWVzc2FnZSwgJz09JywgYXNzZXJ0Lm9rKTtcbn1cbmFzc2VydC5vayA9IG9rO1xuXG4vLyA1LiBUaGUgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHNoYWxsb3csIGNvZXJjaXZlIGVxdWFsaXR5IHdpdGhcbi8vID09LlxuLy8gYXNzZXJ0LmVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9IGV4cGVjdGVkKSBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5lcXVhbCk7XG59O1xuXG4vLyA2LiBUaGUgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igd2hldGhlciB0d28gb2JqZWN0cyBhcmUgbm90IGVxdWFsXG4vLyB3aXRoICE9IGFzc2VydC5ub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RFcXVhbCA9IGZ1bmN0aW9uIG5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9JywgYXNzZXJ0Lm5vdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gNy4gVGhlIGVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBhIGRlZXAgZXF1YWxpdHkgcmVsYXRpb24uXG4vLyBhc3NlcnQuZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmRlZXBFcXVhbCA9IGZ1bmN0aW9uIGRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmICghX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBmYWxzZSkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdkZWVwRXF1YWwnLCBhc3NlcnQuZGVlcEVxdWFsKTtcbiAgfVxufTtcblxuYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIGRlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmICghX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCB0cnVlKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ2RlZXBTdHJpY3RFcXVhbCcsIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIHN0cmljdCwgbWVtb3MpIHtcbiAgLy8gNy4xLiBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoaXNCdWZmZXIoYWN0dWFsKSAmJiBpc0J1ZmZlcihleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gY29tcGFyZShhY3R1YWwsIGV4cGVjdGVkKSA9PT0gMDtcblxuICAvLyA3LjIuIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIERhdGUgb2JqZWN0LCB0aGUgYWN0dWFsIHZhbHVlIGlzXG4gIC8vIGVxdWl2YWxlbnQgaWYgaXQgaXMgYWxzbyBhIERhdGUgb2JqZWN0IHRoYXQgcmVmZXJzIHRvIHRoZSBzYW1lIHRpbWUuXG4gIH0gZWxzZSBpZiAodXRpbC5pc0RhdGUoYWN0dWFsKSAmJiB1dGlsLmlzRGF0ZShleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsLmdldFRpbWUoKSA9PT0gZXhwZWN0ZWQuZ2V0VGltZSgpO1xuXG4gIC8vIDcuMyBJZiB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMgYSBSZWdFeHAgb2JqZWN0LCB0aGUgYWN0dWFsIHZhbHVlIGlzXG4gIC8vIGVxdWl2YWxlbnQgaWYgaXQgaXMgYWxzbyBhIFJlZ0V4cCBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzb3VyY2UgYW5kXG4gIC8vIHByb3BlcnRpZXMgKGBnbG9iYWxgLCBgbXVsdGlsaW5lYCwgYGxhc3RJbmRleGAsIGBpZ25vcmVDYXNlYCkuXG4gIH0gZWxzZSBpZiAodXRpbC5pc1JlZ0V4cChhY3R1YWwpICYmIHV0aWwuaXNSZWdFeHAoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5zb3VyY2UgPT09IGV4cGVjdGVkLnNvdXJjZSAmJlxuICAgICAgICAgICBhY3R1YWwuZ2xvYmFsID09PSBleHBlY3RlZC5nbG9iYWwgJiZcbiAgICAgICAgICAgYWN0dWFsLm11bHRpbGluZSA9PT0gZXhwZWN0ZWQubXVsdGlsaW5lICYmXG4gICAgICAgICAgIGFjdHVhbC5sYXN0SW5kZXggPT09IGV4cGVjdGVkLmxhc3RJbmRleCAmJlxuICAgICAgICAgICBhY3R1YWwuaWdub3JlQ2FzZSA9PT0gZXhwZWN0ZWQuaWdub3JlQ2FzZTtcblxuICAvLyA3LjQuIE90aGVyIHBhaXJzIHRoYXQgZG8gbm90IGJvdGggcGFzcyB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcsXG4gIC8vIGVxdWl2YWxlbmNlIGlzIGRldGVybWluZWQgYnkgPT0uXG4gIH0gZWxzZSBpZiAoKGFjdHVhbCA9PT0gbnVsbCB8fCB0eXBlb2YgYWN0dWFsICE9PSAnb2JqZWN0JykgJiZcbiAgICAgICAgICAgICAoZXhwZWN0ZWQgPT09IG51bGwgfHwgdHlwZW9mIGV4cGVjdGVkICE9PSAnb2JqZWN0JykpIHtcbiAgICByZXR1cm4gc3RyaWN0ID8gYWN0dWFsID09PSBleHBlY3RlZCA6IGFjdHVhbCA9PSBleHBlY3RlZDtcblxuICAvLyBJZiBib3RoIHZhbHVlcyBhcmUgaW5zdGFuY2VzIG9mIHR5cGVkIGFycmF5cywgd3JhcCB0aGVpciB1bmRlcmx5aW5nXG4gIC8vIEFycmF5QnVmZmVycyBpbiBhIEJ1ZmZlciBlYWNoIHRvIGluY3JlYXNlIHBlcmZvcm1hbmNlXG4gIC8vIFRoaXMgb3B0aW1pemF0aW9uIHJlcXVpcmVzIHRoZSBhcnJheXMgdG8gaGF2ZSB0aGUgc2FtZSB0eXBlIGFzIGNoZWNrZWQgYnlcbiAgLy8gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyAoYWthIHBUb1N0cmluZykuIE5ldmVyIHBlcmZvcm0gYmluYXJ5XG4gIC8vIGNvbXBhcmlzb25zIGZvciBGbG9hdCpBcnJheXMsIHRob3VnaCwgc2luY2UgZS5nLiArMCA9PT0gLTAgYnV0IHRoZWlyXG4gIC8vIGJpdCBwYXR0ZXJucyBhcmUgbm90IGlkZW50aWNhbC5cbiAgfSBlbHNlIGlmIChpc1ZpZXcoYWN0dWFsKSAmJiBpc1ZpZXcoZXhwZWN0ZWQpICYmXG4gICAgICAgICAgICAgcFRvU3RyaW5nKGFjdHVhbCkgPT09IHBUb1N0cmluZyhleHBlY3RlZCkgJiZcbiAgICAgICAgICAgICAhKGFjdHVhbCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSB8fFxuICAgICAgICAgICAgICAgYWN0dWFsIGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5KSkge1xuICAgIHJldHVybiBjb21wYXJlKG5ldyBVaW50OEFycmF5KGFjdHVhbC5idWZmZXIpLFxuICAgICAgICAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KGV4cGVjdGVkLmJ1ZmZlcikpID09PSAwO1xuXG4gIC8vIDcuNSBGb3IgYWxsIG90aGVyIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5IG9iamVjdHMsIGVxdWl2YWxlbmNlIGlzXG4gIC8vIGRldGVybWluZWQgYnkgaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChhcyB2ZXJpZmllZFxuICAvLyB3aXRoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCksIHRoZSBzYW1lIHNldCBvZiBrZXlzXG4gIC8vIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLCBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnlcbiAgLy8gY29ycmVzcG9uZGluZyBrZXksIGFuZCBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuIE5vdGU6IHRoaXNcbiAgLy8gYWNjb3VudHMgZm9yIGJvdGggbmFtZWQgYW5kIGluZGV4ZWQgcHJvcGVydGllcyBvbiBBcnJheXMuXG4gIH0gZWxzZSBpZiAoaXNCdWZmZXIoYWN0dWFsKSAhPT0gaXNCdWZmZXIoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIG1lbW9zID0gbWVtb3MgfHwge2FjdHVhbDogW10sIGV4cGVjdGVkOiBbXX07XG5cbiAgICB2YXIgYWN0dWFsSW5kZXggPSBtZW1vcy5hY3R1YWwuaW5kZXhPZihhY3R1YWwpO1xuICAgIGlmIChhY3R1YWxJbmRleCAhPT0gLTEpIHtcbiAgICAgIGlmIChhY3R1YWxJbmRleCA9PT0gbWVtb3MuZXhwZWN0ZWQuaW5kZXhPZihleHBlY3RlZCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbWVtb3MuYWN0dWFsLnB1c2goYWN0dWFsKTtcbiAgICBtZW1vcy5leHBlY3RlZC5wdXNoKGV4cGVjdGVkKTtcblxuICAgIHJldHVybiBvYmpFcXVpdihhY3R1YWwsIGV4cGVjdGVkLCBzdHJpY3QsIG1lbW9zKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0FyZ3VtZW50cyhvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiLCBzdHJpY3QsIGFjdHVhbFZpc2l0ZWRPYmplY3RzKSB7XG4gIGlmIChhID09PSBudWxsIHx8IGEgPT09IHVuZGVmaW5lZCB8fCBiID09PSBudWxsIHx8IGIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vIGlmIG9uZSBpcyBhIHByaW1pdGl2ZSwgdGhlIG90aGVyIG11c3QgYmUgc2FtZVxuICBpZiAodXRpbC5pc1ByaW1pdGl2ZShhKSB8fCB1dGlsLmlzUHJpbWl0aXZlKGIpKVxuICAgIHJldHVybiBhID09PSBiO1xuICBpZiAoc3RyaWN0ICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihhKSAhPT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGIpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgdmFyIGFJc0FyZ3MgPSBpc0FyZ3VtZW50cyhhKTtcbiAgdmFyIGJJc0FyZ3MgPSBpc0FyZ3VtZW50cyhiKTtcbiAgaWYgKChhSXNBcmdzICYmICFiSXNBcmdzKSB8fCAoIWFJc0FyZ3MgJiYgYklzQXJncykpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoYUlzQXJncykge1xuICAgIGEgPSBwU2xpY2UuY2FsbChhKTtcbiAgICBiID0gcFNsaWNlLmNhbGwoYik7XG4gICAgcmV0dXJuIF9kZWVwRXF1YWwoYSwgYiwgc3RyaWN0KTtcbiAgfVxuICB2YXIga2EgPSBvYmplY3RLZXlzKGEpO1xuICB2YXIga2IgPSBvYmplY3RLZXlzKGIpO1xuICB2YXIga2V5LCBpO1xuICAvLyBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGtleXMgaW5jb3Jwb3JhdGVzXG4gIC8vIGhhc093blByb3BlcnR5KVxuICBpZiAoa2EubGVuZ3RoICE9PSBrYi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvL3RoZSBzYW1lIHNldCBvZiBrZXlzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLFxuICBrYS5zb3J0KCk7XG4gIGtiLnNvcnQoKTtcbiAgLy9+fn5jaGVhcCBrZXkgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChrYVtpXSAhPT0ga2JbaV0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy9lcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXksIGFuZFxuICAvL35+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBrZXkgPSBrYVtpXTtcbiAgICBpZiAoIV9kZWVwRXF1YWwoYVtrZXldLCBiW2tleV0sIHN0cmljdCwgYWN0dWFsVmlzaXRlZE9iamVjdHMpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyA4LiBUaGUgbm9uLWVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBmb3IgYW55IGRlZXAgaW5lcXVhbGl0eS5cbi8vIGFzc2VydC5ub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90RGVlcEVxdWFsID0gZnVuY3Rpb24gbm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgZmFsc2UpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnbm90RGVlcEVxdWFsJywgYXNzZXJ0Lm5vdERlZXBFcXVhbCk7XG4gIH1cbn07XG5cbmFzc2VydC5ub3REZWVwU3RyaWN0RXF1YWwgPSBub3REZWVwU3RyaWN0RXF1YWw7XG5mdW5jdGlvbiBub3REZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCB0cnVlKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ25vdERlZXBTdHJpY3RFcXVhbCcsIG5vdERlZXBTdHJpY3RFcXVhbCk7XG4gIH1cbn1cblxuXG4vLyA5LiBUaGUgc3RyaWN0IGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzdHJpY3QgZXF1YWxpdHksIGFzIGRldGVybWluZWQgYnkgPT09LlxuLy8gYXNzZXJ0LnN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LnN0cmljdEVxdWFsID0gZnVuY3Rpb24gc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJz09PScsIGFzc2VydC5zdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDEwLiBUaGUgc3RyaWN0IG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHN0cmljdCBpbmVxdWFsaXR5LCBhc1xuLy8gZGV0ZXJtaW5lZCBieSAhPT0uICBhc3NlcnQubm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90U3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT09JywgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkge1xuICBpZiAoIWFjdHVhbCB8fCAhZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGV4cGVjdGVkKSA9PSAnW29iamVjdCBSZWdFeHBdJykge1xuICAgIHJldHVybiBleHBlY3RlZC50ZXN0KGFjdHVhbCk7XG4gIH1cblxuICB0cnkge1xuICAgIGlmIChhY3R1YWwgaW5zdGFuY2VvZiBleHBlY3RlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gSWdub3JlLiAgVGhlIGluc3RhbmNlb2YgY2hlY2sgZG9lc24ndCB3b3JrIGZvciBhcnJvdyBmdW5jdGlvbnMuXG4gIH1cblxuICBpZiAoRXJyb3IuaXNQcm90b3R5cGVPZihleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gZXhwZWN0ZWQuY2FsbCh7fSwgYWN0dWFsKSA9PT0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gX3RyeUJsb2NrKGJsb2NrKSB7XG4gIHZhciBlcnJvcjtcbiAgdHJ5IHtcbiAgICBibG9jaygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyb3IgPSBlO1xuICB9XG4gIHJldHVybiBlcnJvcjtcbn1cblxuZnVuY3Rpb24gX3Rocm93cyhzaG91bGRUaHJvdywgYmxvY2ssIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIHZhciBhY3R1YWw7XG5cbiAgaWYgKHR5cGVvZiBibG9jayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYmxvY2tcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgbWVzc2FnZSA9IGV4cGVjdGVkO1xuICAgIGV4cGVjdGVkID0gbnVsbDtcbiAgfVxuXG4gIGFjdHVhbCA9IF90cnlCbG9jayhibG9jayk7XG5cbiAgbWVzc2FnZSA9IChleHBlY3RlZCAmJiBleHBlY3RlZC5uYW1lID8gJyAoJyArIGV4cGVjdGVkLm5hbWUgKyAnKS4nIDogJy4nKSArXG4gICAgICAgICAgICAobWVzc2FnZSA/ICcgJyArIG1lc3NhZ2UgOiAnLicpO1xuXG4gIGlmIChzaG91bGRUaHJvdyAmJiAhYWN0dWFsKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCAnTWlzc2luZyBleHBlY3RlZCBleGNlcHRpb24nICsgbWVzc2FnZSk7XG4gIH1cblxuICB2YXIgdXNlclByb3ZpZGVkTWVzc2FnZSA9IHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJztcbiAgdmFyIGlzVW53YW50ZWRFeGNlcHRpb24gPSAhc2hvdWxkVGhyb3cgJiYgdXRpbC5pc0Vycm9yKGFjdHVhbCk7XG4gIHZhciBpc1VuZXhwZWN0ZWRFeGNlcHRpb24gPSAhc2hvdWxkVGhyb3cgJiYgYWN0dWFsICYmICFleHBlY3RlZDtcblxuICBpZiAoKGlzVW53YW50ZWRFeGNlcHRpb24gJiZcbiAgICAgIHVzZXJQcm92aWRlZE1lc3NhZ2UgJiZcbiAgICAgIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpKSB8fFxuICAgICAgaXNVbmV4cGVjdGVkRXhjZXB0aW9uKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCAnR290IHVud2FudGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIGlmICgoc2hvdWxkVGhyb3cgJiYgYWN0dWFsICYmIGV4cGVjdGVkICYmXG4gICAgICAhZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHx8ICghc2hvdWxkVGhyb3cgJiYgYWN0dWFsKSkge1xuICAgIHRocm93IGFjdHVhbDtcbiAgfVxufVxuXG4vLyAxMS4gRXhwZWN0ZWQgdG8gdGhyb3cgYW4gZXJyb3I6XG4vLyBhc3NlcnQudGhyb3dzKGJsb2NrLCBFcnJvcl9vcHQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LnRocm93cyA9IGZ1bmN0aW9uKGJsb2NrLCAvKm9wdGlvbmFsKi9lcnJvciwgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzKHRydWUsIGJsb2NrLCBlcnJvciwgbWVzc2FnZSk7XG59O1xuXG4vLyBFWFRFTlNJT04hIFRoaXMgaXMgYW5ub3lpbmcgdG8gd3JpdGUgb3V0c2lkZSB0aGlzIG1vZHVsZS5cbmFzc2VydC5kb2VzTm90VGhyb3cgPSBmdW5jdGlvbihibG9jaywgLypvcHRpb25hbCovZXJyb3IsIC8qb3B0aW9uYWwqL21lc3NhZ2UpIHtcbiAgX3Rocm93cyhmYWxzZSwgYmxvY2ssIGVycm9yLCBtZXNzYWdlKTtcbn07XG5cbmFzc2VydC5pZkVycm9yID0gZnVuY3Rpb24oZXJyKSB7IGlmIChlcnIpIHRocm93IGVycjsgfTtcblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoaGFzT3duLmNhbGwob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn07XG4iLCIiLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxudmFyIEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcbmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0XG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGVcbiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWBcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcbiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xuICApXG59XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkP1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYnVmXG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG5mdW5jdGlvbiBmcm9tICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmIChpc0FycmF5QnVmZmVyKHZhbHVlKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBOb3RlOiBDaGFuZ2UgcHJvdG90eXBlICphZnRlciogQnVmZmVyLmZyb20gaXMgZGVmaW5lZCB0byB3b3JrYXJvdW5kIENocm9tZSBidWc6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzE0OFxuQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSBidWYud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIGJ1ZiA9IGJ1Zi5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICBidWZbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyIChhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIHZhciBidWZcbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIGJ1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAob2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuKVxuXG4gICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBidWZcbiAgICB9XG5cbiAgICBvYmouY29weShidWYsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gYnVmXG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKGlzQXJyYXlCdWZmZXJWaWV3KG9iaikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IEtfTUFYX0xFTkdUSGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsgS19NQVhfTEVOR1RILnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyID09PSB0cnVlXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmIChpc0FycmF5QnVmZmVyVmlldyhzdHJpbmcpIHx8IGlzQXJyYXlCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAobnVtYmVySXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPj4+IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyAoYnl0ZXNbaSArIDFdICogMjU2KSlcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZylcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG4vLyBBcnJheUJ1ZmZlcnMgZnJvbSBhbm90aGVyIGNvbnRleHQgKGkuZS4gYW4gaWZyYW1lKSBkbyBub3QgcGFzcyB0aGUgYGluc3RhbmNlb2ZgIGNoZWNrXG4vLyBidXQgdGhleSBzaG91bGQgYmUgdHJlYXRlZCBhcyB2YWxpZC4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTY2XG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyIChvYmopIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8XG4gICAgKG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSAnQXJyYXlCdWZmZXInICYmXG4gICAgICB0eXBlb2Ygb2JqLmJ5dGVMZW5ndGggPT09ICdudW1iZXInKVxufVxuXG4vLyBOb2RlIDAuMTAgc3VwcG9ydHMgYEFycmF5QnVmZmVyYCBidXQgbGFja3MgYEFycmF5QnVmZmVyLmlzVmlld2BcbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3IChvYmopIHtcbiAgcmV0dXJuICh0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nKSAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcob2JqKVxufVxuXG5mdW5jdGlvbiBudW1iZXJJc05hTiAob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gcGxhY2VIb2xkZXJzQ291bnQgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcbiAgLy8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuICAvLyByZXByZXNlbnQgb25lIGJ5dGVcbiAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG4gIC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2VcbiAgcmV0dXJuIGI2NFtsZW4gLSAyXSA9PT0gJz0nID8gMiA6IGI2NFtsZW4gLSAxXSA9PT0gJz0nID8gMSA6IDBcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuICByZXR1cm4gKGI2NC5sZW5ndGggKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNDb3VudChiNjQpXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIGksIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcbiAgcGxhY2VIb2xkZXJzID0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxuXG4gIGFyciA9IG5ldyBBcnIoKGxlbiAqIDMgLyA0KSAtIHBsYWNlSG9sZGVycylcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gbGVuIC0gNCA6IGxlblxuXG4gIHZhciBMID0gMFxuXG4gIGZvciAoaSA9IDA7IGkgPCBsOyBpICs9IDQpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICsgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSlcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIG91dHB1dCA9ICcnXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAyXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9ICc9PSdcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgKHVpbnQ4W2xlbiAtIDFdKVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDEwXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz0nXG4gIH1cblxuICBwYXJ0cy5wdXNoKG91dHB1dClcblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiIsIi8vIChjKSBEZWFuIE1jTmFtZWUgPGRlYW5AZ21haWwuY29tPiwgMjAxMi5cbi8vXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZGVhbm0vY3NzLWNvbG9yLXBhcnNlci1qc1xuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvXG4vLyBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxuLy8gcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yXG4vLyBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4vLyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTXG4vLyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtY29sb3IvXG52YXIga0NTU0NvbG9yVGFibGUgPSB7XG4gIFwidHJhbnNwYXJlbnRcIjogWzAsMCwwLDBdLCBcImFsaWNlYmx1ZVwiOiBbMjQwLDI0OCwyNTUsMV0sXG4gIFwiYW50aXF1ZXdoaXRlXCI6IFsyNTAsMjM1LDIxNSwxXSwgXCJhcXVhXCI6IFswLDI1NSwyNTUsMV0sXG4gIFwiYXF1YW1hcmluZVwiOiBbMTI3LDI1NSwyMTIsMV0sIFwiYXp1cmVcIjogWzI0MCwyNTUsMjU1LDFdLFxuICBcImJlaWdlXCI6IFsyNDUsMjQ1LDIyMCwxXSwgXCJiaXNxdWVcIjogWzI1NSwyMjgsMTk2LDFdLFxuICBcImJsYWNrXCI6IFswLDAsMCwxXSwgXCJibGFuY2hlZGFsbW9uZFwiOiBbMjU1LDIzNSwyMDUsMV0sXG4gIFwiYmx1ZVwiOiBbMCwwLDI1NSwxXSwgXCJibHVldmlvbGV0XCI6IFsxMzgsNDMsMjI2LDFdLFxuICBcImJyb3duXCI6IFsxNjUsNDIsNDIsMV0sIFwiYnVybHl3b29kXCI6IFsyMjIsMTg0LDEzNSwxXSxcbiAgXCJjYWRldGJsdWVcIjogWzk1LDE1OCwxNjAsMV0sIFwiY2hhcnRyZXVzZVwiOiBbMTI3LDI1NSwwLDFdLFxuICBcImNob2NvbGF0ZVwiOiBbMjEwLDEwNSwzMCwxXSwgXCJjb3JhbFwiOiBbMjU1LDEyNyw4MCwxXSxcbiAgXCJjb3JuZmxvd2VyYmx1ZVwiOiBbMTAwLDE0OSwyMzcsMV0sIFwiY29ybnNpbGtcIjogWzI1NSwyNDgsMjIwLDFdLFxuICBcImNyaW1zb25cIjogWzIyMCwyMCw2MCwxXSwgXCJjeWFuXCI6IFswLDI1NSwyNTUsMV0sXG4gIFwiZGFya2JsdWVcIjogWzAsMCwxMzksMV0sIFwiZGFya2N5YW5cIjogWzAsMTM5LDEzOSwxXSxcbiAgXCJkYXJrZ29sZGVucm9kXCI6IFsxODQsMTM0LDExLDFdLCBcImRhcmtncmF5XCI6IFsxNjksMTY5LDE2OSwxXSxcbiAgXCJkYXJrZ3JlZW5cIjogWzAsMTAwLDAsMV0sIFwiZGFya2dyZXlcIjogWzE2OSwxNjksMTY5LDFdLFxuICBcImRhcmtraGFraVwiOiBbMTg5LDE4MywxMDcsMV0sIFwiZGFya21hZ2VudGFcIjogWzEzOSwwLDEzOSwxXSxcbiAgXCJkYXJrb2xpdmVncmVlblwiOiBbODUsMTA3LDQ3LDFdLCBcImRhcmtvcmFuZ2VcIjogWzI1NSwxNDAsMCwxXSxcbiAgXCJkYXJrb3JjaGlkXCI6IFsxNTMsNTAsMjA0LDFdLCBcImRhcmtyZWRcIjogWzEzOSwwLDAsMV0sXG4gIFwiZGFya3NhbG1vblwiOiBbMjMzLDE1MCwxMjIsMV0sIFwiZGFya3NlYWdyZWVuXCI6IFsxNDMsMTg4LDE0MywxXSxcbiAgXCJkYXJrc2xhdGVibHVlXCI6IFs3Miw2MSwxMzksMV0sIFwiZGFya3NsYXRlZ3JheVwiOiBbNDcsNzksNzksMV0sXG4gIFwiZGFya3NsYXRlZ3JleVwiOiBbNDcsNzksNzksMV0sIFwiZGFya3R1cnF1b2lzZVwiOiBbMCwyMDYsMjA5LDFdLFxuICBcImRhcmt2aW9sZXRcIjogWzE0OCwwLDIxMSwxXSwgXCJkZWVwcGlua1wiOiBbMjU1LDIwLDE0NywxXSxcbiAgXCJkZWVwc2t5Ymx1ZVwiOiBbMCwxOTEsMjU1LDFdLCBcImRpbWdyYXlcIjogWzEwNSwxMDUsMTA1LDFdLFxuICBcImRpbWdyZXlcIjogWzEwNSwxMDUsMTA1LDFdLCBcImRvZGdlcmJsdWVcIjogWzMwLDE0NCwyNTUsMV0sXG4gIFwiZmlyZWJyaWNrXCI6IFsxNzgsMzQsMzQsMV0sIFwiZmxvcmFsd2hpdGVcIjogWzI1NSwyNTAsMjQwLDFdLFxuICBcImZvcmVzdGdyZWVuXCI6IFszNCwxMzksMzQsMV0sIFwiZnVjaHNpYVwiOiBbMjU1LDAsMjU1LDFdLFxuICBcImdhaW5zYm9yb1wiOiBbMjIwLDIyMCwyMjAsMV0sIFwiZ2hvc3R3aGl0ZVwiOiBbMjQ4LDI0OCwyNTUsMV0sXG4gIFwiZ29sZFwiOiBbMjU1LDIxNSwwLDFdLCBcImdvbGRlbnJvZFwiOiBbMjE4LDE2NSwzMiwxXSxcbiAgXCJncmF5XCI6IFsxMjgsMTI4LDEyOCwxXSwgXCJncmVlblwiOiBbMCwxMjgsMCwxXSxcbiAgXCJncmVlbnllbGxvd1wiOiBbMTczLDI1NSw0NywxXSwgXCJncmV5XCI6IFsxMjgsMTI4LDEyOCwxXSxcbiAgXCJob25leWRld1wiOiBbMjQwLDI1NSwyNDAsMV0sIFwiaG90cGlua1wiOiBbMjU1LDEwNSwxODAsMV0sXG4gIFwiaW5kaWFucmVkXCI6IFsyMDUsOTIsOTIsMV0sIFwiaW5kaWdvXCI6IFs3NSwwLDEzMCwxXSxcbiAgXCJpdm9yeVwiOiBbMjU1LDI1NSwyNDAsMV0sIFwia2hha2lcIjogWzI0MCwyMzAsMTQwLDFdLFxuICBcImxhdmVuZGVyXCI6IFsyMzAsMjMwLDI1MCwxXSwgXCJsYXZlbmRlcmJsdXNoXCI6IFsyNTUsMjQwLDI0NSwxXSxcbiAgXCJsYXduZ3JlZW5cIjogWzEyNCwyNTIsMCwxXSwgXCJsZW1vbmNoaWZmb25cIjogWzI1NSwyNTAsMjA1LDFdLFxuICBcImxpZ2h0Ymx1ZVwiOiBbMTczLDIxNiwyMzAsMV0sIFwibGlnaHRjb3JhbFwiOiBbMjQwLDEyOCwxMjgsMV0sXG4gIFwibGlnaHRjeWFuXCI6IFsyMjQsMjU1LDI1NSwxXSwgXCJsaWdodGdvbGRlbnJvZHllbGxvd1wiOiBbMjUwLDI1MCwyMTAsMV0sXG4gIFwibGlnaHRncmF5XCI6IFsyMTEsMjExLDIxMSwxXSwgXCJsaWdodGdyZWVuXCI6IFsxNDQsMjM4LDE0NCwxXSxcbiAgXCJsaWdodGdyZXlcIjogWzIxMSwyMTEsMjExLDFdLCBcImxpZ2h0cGlua1wiOiBbMjU1LDE4MiwxOTMsMV0sXG4gIFwibGlnaHRzYWxtb25cIjogWzI1NSwxNjAsMTIyLDFdLCBcImxpZ2h0c2VhZ3JlZW5cIjogWzMyLDE3OCwxNzAsMV0sXG4gIFwibGlnaHRza3libHVlXCI6IFsxMzUsMjA2LDI1MCwxXSwgXCJsaWdodHNsYXRlZ3JheVwiOiBbMTE5LDEzNiwxNTMsMV0sXG4gIFwibGlnaHRzbGF0ZWdyZXlcIjogWzExOSwxMzYsMTUzLDFdLCBcImxpZ2h0c3RlZWxibHVlXCI6IFsxNzYsMTk2LDIyMiwxXSxcbiAgXCJsaWdodHllbGxvd1wiOiBbMjU1LDI1NSwyMjQsMV0sIFwibGltZVwiOiBbMCwyNTUsMCwxXSxcbiAgXCJsaW1lZ3JlZW5cIjogWzUwLDIwNSw1MCwxXSwgXCJsaW5lblwiOiBbMjUwLDI0MCwyMzAsMV0sXG4gIFwibWFnZW50YVwiOiBbMjU1LDAsMjU1LDFdLCBcIm1hcm9vblwiOiBbMTI4LDAsMCwxXSxcbiAgXCJtZWRpdW1hcXVhbWFyaW5lXCI6IFsxMDIsMjA1LDE3MCwxXSwgXCJtZWRpdW1ibHVlXCI6IFswLDAsMjA1LDFdLFxuICBcIm1lZGl1bW9yY2hpZFwiOiBbMTg2LDg1LDIxMSwxXSwgXCJtZWRpdW1wdXJwbGVcIjogWzE0NywxMTIsMjE5LDFdLFxuICBcIm1lZGl1bXNlYWdyZWVuXCI6IFs2MCwxNzksMTEzLDFdLCBcIm1lZGl1bXNsYXRlYmx1ZVwiOiBbMTIzLDEwNCwyMzgsMV0sXG4gIFwibWVkaXVtc3ByaW5nZ3JlZW5cIjogWzAsMjUwLDE1NCwxXSwgXCJtZWRpdW10dXJxdW9pc2VcIjogWzcyLDIwOSwyMDQsMV0sXG4gIFwibWVkaXVtdmlvbGV0cmVkXCI6IFsxOTksMjEsMTMzLDFdLCBcIm1pZG5pZ2h0Ymx1ZVwiOiBbMjUsMjUsMTEyLDFdLFxuICBcIm1pbnRjcmVhbVwiOiBbMjQ1LDI1NSwyNTAsMV0sIFwibWlzdHlyb3NlXCI6IFsyNTUsMjI4LDIyNSwxXSxcbiAgXCJtb2NjYXNpblwiOiBbMjU1LDIyOCwxODEsMV0sIFwibmF2YWpvd2hpdGVcIjogWzI1NSwyMjIsMTczLDFdLFxuICBcIm5hdnlcIjogWzAsMCwxMjgsMV0sIFwib2xkbGFjZVwiOiBbMjUzLDI0NSwyMzAsMV0sXG4gIFwib2xpdmVcIjogWzEyOCwxMjgsMCwxXSwgXCJvbGl2ZWRyYWJcIjogWzEwNywxNDIsMzUsMV0sXG4gIFwib3JhbmdlXCI6IFsyNTUsMTY1LDAsMV0sIFwib3JhbmdlcmVkXCI6IFsyNTUsNjksMCwxXSxcbiAgXCJvcmNoaWRcIjogWzIxOCwxMTIsMjE0LDFdLCBcInBhbGVnb2xkZW5yb2RcIjogWzIzOCwyMzIsMTcwLDFdLFxuICBcInBhbGVncmVlblwiOiBbMTUyLDI1MSwxNTIsMV0sIFwicGFsZXR1cnF1b2lzZVwiOiBbMTc1LDIzOCwyMzgsMV0sXG4gIFwicGFsZXZpb2xldHJlZFwiOiBbMjE5LDExMiwxNDcsMV0sIFwicGFwYXlhd2hpcFwiOiBbMjU1LDIzOSwyMTMsMV0sXG4gIFwicGVhY2hwdWZmXCI6IFsyNTUsMjE4LDE4NSwxXSwgXCJwZXJ1XCI6IFsyMDUsMTMzLDYzLDFdLFxuICBcInBpbmtcIjogWzI1NSwxOTIsMjAzLDFdLCBcInBsdW1cIjogWzIyMSwxNjAsMjIxLDFdLFxuICBcInBvd2RlcmJsdWVcIjogWzE3NiwyMjQsMjMwLDFdLCBcInB1cnBsZVwiOiBbMTI4LDAsMTI4LDFdLFxuICBcInJlYmVjY2FwdXJwbGVcIjogWzEwMiw1MSwxNTMsMV0sXG4gIFwicmVkXCI6IFsyNTUsMCwwLDFdLCBcInJvc3licm93blwiOiBbMTg4LDE0MywxNDMsMV0sXG4gIFwicm95YWxibHVlXCI6IFs2NSwxMDUsMjI1LDFdLCBcInNhZGRsZWJyb3duXCI6IFsxMzksNjksMTksMV0sXG4gIFwic2FsbW9uXCI6IFsyNTAsMTI4LDExNCwxXSwgXCJzYW5keWJyb3duXCI6IFsyNDQsMTY0LDk2LDFdLFxuICBcInNlYWdyZWVuXCI6IFs0NiwxMzksODcsMV0sIFwic2Vhc2hlbGxcIjogWzI1NSwyNDUsMjM4LDFdLFxuICBcInNpZW5uYVwiOiBbMTYwLDgyLDQ1LDFdLCBcInNpbHZlclwiOiBbMTkyLDE5MiwxOTIsMV0sXG4gIFwic2t5Ymx1ZVwiOiBbMTM1LDIwNiwyMzUsMV0sIFwic2xhdGVibHVlXCI6IFsxMDYsOTAsMjA1LDFdLFxuICBcInNsYXRlZ3JheVwiOiBbMTEyLDEyOCwxNDQsMV0sIFwic2xhdGVncmV5XCI6IFsxMTIsMTI4LDE0NCwxXSxcbiAgXCJzbm93XCI6IFsyNTUsMjUwLDI1MCwxXSwgXCJzcHJpbmdncmVlblwiOiBbMCwyNTUsMTI3LDFdLFxuICBcInN0ZWVsYmx1ZVwiOiBbNzAsMTMwLDE4MCwxXSwgXCJ0YW5cIjogWzIxMCwxODAsMTQwLDFdLFxuICBcInRlYWxcIjogWzAsMTI4LDEyOCwxXSwgXCJ0aGlzdGxlXCI6IFsyMTYsMTkxLDIxNiwxXSxcbiAgXCJ0b21hdG9cIjogWzI1NSw5OSw3MSwxXSwgXCJ0dXJxdW9pc2VcIjogWzY0LDIyNCwyMDgsMV0sXG4gIFwidmlvbGV0XCI6IFsyMzgsMTMwLDIzOCwxXSwgXCJ3aGVhdFwiOiBbMjQ1LDIyMiwxNzksMV0sXG4gIFwid2hpdGVcIjogWzI1NSwyNTUsMjU1LDFdLCBcIndoaXRlc21va2VcIjogWzI0NSwyNDUsMjQ1LDFdLFxuICBcInllbGxvd1wiOiBbMjU1LDI1NSwwLDFdLCBcInllbGxvd2dyZWVuXCI6IFsxNTQsMjA1LDUwLDFdfVxuXG5mdW5jdGlvbiBjbGFtcF9jc3NfYnl0ZShpKSB7ICAvLyBDbGFtcCB0byBpbnRlZ2VyIDAgLi4gMjU1LlxuICBpID0gTWF0aC5yb3VuZChpKTsgIC8vIFNlZW1zIHRvIGJlIHdoYXQgQ2hyb21lIGRvZXMgKHZzIHRydW5jYXRpb24pLlxuICByZXR1cm4gaSA8IDAgPyAwIDogaSA+IDI1NSA/IDI1NSA6IGk7XG59XG5cbmZ1bmN0aW9uIGNsYW1wX2Nzc19mbG9hdChmKSB7ICAvLyBDbGFtcCB0byBmbG9hdCAwLjAgLi4gMS4wLlxuICByZXR1cm4gZiA8IDAgPyAwIDogZiA+IDEgPyAxIDogZjtcbn1cblxuZnVuY3Rpb24gcGFyc2VfY3NzX2ludChzdHIpIHsgIC8vIGludCBvciBwZXJjZW50YWdlLlxuICBpZiAoc3RyW3N0ci5sZW5ndGggLSAxXSA9PT0gJyUnKVxuICAgIHJldHVybiBjbGFtcF9jc3NfYnl0ZShwYXJzZUZsb2F0KHN0cikgLyAxMDAgKiAyNTUpO1xuICByZXR1cm4gY2xhbXBfY3NzX2J5dGUocGFyc2VJbnQoc3RyKSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlX2Nzc19mbG9hdChzdHIpIHsgIC8vIGZsb2F0IG9yIHBlcmNlbnRhZ2UuXG4gIGlmIChzdHJbc3RyLmxlbmd0aCAtIDFdID09PSAnJScpXG4gICAgcmV0dXJuIGNsYW1wX2Nzc19mbG9hdChwYXJzZUZsb2F0KHN0cikgLyAxMDApO1xuICByZXR1cm4gY2xhbXBfY3NzX2Zsb2F0KHBhcnNlRmxvYXQoc3RyKSk7XG59XG5cbmZ1bmN0aW9uIGNzc19odWVfdG9fcmdiKG0xLCBtMiwgaCkge1xuICBpZiAoaCA8IDApIGggKz0gMTtcbiAgZWxzZSBpZiAoaCA+IDEpIGggLT0gMTtcblxuICBpZiAoaCAqIDYgPCAxKSByZXR1cm4gbTEgKyAobTIgLSBtMSkgKiBoICogNjtcbiAgaWYgKGggKiAyIDwgMSkgcmV0dXJuIG0yO1xuICBpZiAoaCAqIDMgPCAyKSByZXR1cm4gbTEgKyAobTIgLSBtMSkgKiAoMi8zIC0gaCkgKiA2O1xuICByZXR1cm4gbTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ1NTQ29sb3IoY3NzX3N0cikge1xuICAvLyBSZW1vdmUgYWxsIHdoaXRlc3BhY2UsIG5vdCBjb21wbGlhbnQsIGJ1dCBzaG91bGQganVzdCBiZSBtb3JlIGFjY2VwdGluZy5cbiAgdmFyIHN0ciA9IGNzc19zdHIucmVwbGFjZSgvIC9nLCAnJykudG9Mb3dlckNhc2UoKTtcblxuICAvLyBDb2xvciBrZXl3b3JkcyAoYW5kIHRyYW5zcGFyZW50KSBsb29rdXAuXG4gIGlmIChzdHIgaW4ga0NTU0NvbG9yVGFibGUpIHJldHVybiBrQ1NTQ29sb3JUYWJsZVtzdHJdLnNsaWNlKCk7ICAvLyBkdXAuXG5cbiAgLy8gI2FiYyBhbmQgI2FiYzEyMyBzeW50YXguXG4gIGlmIChzdHJbMF0gPT09ICcjJykge1xuICAgIGlmIChzdHIubGVuZ3RoID09PSA0KSB7XG4gICAgICB2YXIgaXYgPSBwYXJzZUludChzdHIuc3Vic3RyKDEpLCAxNik7ICAvLyBUT0RPKGRlYW5tKTogU3RyaWN0ZXIgcGFyc2luZy5cbiAgICAgIGlmICghKGl2ID49IDAgJiYgaXYgPD0gMHhmZmYpKSByZXR1cm4gbnVsbDsgIC8vIENvdmVycyBOYU4uXG4gICAgICByZXR1cm4gWygoaXYgJiAweGYwMCkgPj4gNCkgfCAoKGl2ICYgMHhmMDApID4+IDgpLFxuICAgICAgICAgICAgICAoaXYgJiAweGYwKSB8ICgoaXYgJiAweGYwKSA+PiA0KSxcbiAgICAgICAgICAgICAgKGl2ICYgMHhmKSB8ICgoaXYgJiAweGYpIDw8IDQpLFxuICAgICAgICAgICAgICAxXTtcbiAgICB9IGVsc2UgaWYgKHN0ci5sZW5ndGggPT09IDcpIHtcbiAgICAgIHZhciBpdiA9IHBhcnNlSW50KHN0ci5zdWJzdHIoMSksIDE2KTsgIC8vIFRPRE8oZGVhbm0pOiBTdHJpY3RlciBwYXJzaW5nLlxuICAgICAgaWYgKCEoaXYgPj0gMCAmJiBpdiA8PSAweGZmZmZmZikpIHJldHVybiBudWxsOyAgLy8gQ292ZXJzIE5hTi5cbiAgICAgIHJldHVybiBbKGl2ICYgMHhmZjAwMDApID4+IDE2LFxuICAgICAgICAgICAgICAoaXYgJiAweGZmMDApID4+IDgsXG4gICAgICAgICAgICAgIGl2ICYgMHhmZixcbiAgICAgICAgICAgICAgMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgb3AgPSBzdHIuaW5kZXhPZignKCcpLCBlcCA9IHN0ci5pbmRleE9mKCcpJyk7XG4gIGlmIChvcCAhPT0gLTEgJiYgZXAgKyAxID09PSBzdHIubGVuZ3RoKSB7XG4gICAgdmFyIGZuYW1lID0gc3RyLnN1YnN0cigwLCBvcCk7XG4gICAgdmFyIHBhcmFtcyA9IHN0ci5zdWJzdHIob3ArMSwgZXAtKG9wKzEpKS5zcGxpdCgnLCcpO1xuICAgIHZhciBhbHBoYSA9IDE7ICAvLyBUbyBhbGxvdyBjYXNlIGZhbGx0aHJvdWdoLlxuICAgIHN3aXRjaCAoZm5hbWUpIHtcbiAgICAgIGNhc2UgJ3JnYmEnOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gNCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGFscGhhID0gcGFyc2VfY3NzX2Zsb2F0KHBhcmFtcy5wb3AoKSk7XG4gICAgICAgIC8vIEZhbGwgdGhyb3VnaC5cbiAgICAgIGNhc2UgJ3JnYic6XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSAzKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIFtwYXJzZV9jc3NfaW50KHBhcmFtc1swXSksXG4gICAgICAgICAgICAgICAgcGFyc2VfY3NzX2ludChwYXJhbXNbMV0pLFxuICAgICAgICAgICAgICAgIHBhcnNlX2Nzc19pbnQocGFyYW1zWzJdKSxcbiAgICAgICAgICAgICAgICBhbHBoYV07XG4gICAgICBjYXNlICdoc2xhJzpcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDQpIHJldHVybiBudWxsO1xuICAgICAgICBhbHBoYSA9IHBhcnNlX2Nzc19mbG9hdChwYXJhbXMucG9wKCkpO1xuICAgICAgICAvLyBGYWxsIHRocm91Z2guXG4gICAgICBjYXNlICdoc2wnOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gMykgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBoID0gKCgocGFyc2VGbG9hdChwYXJhbXNbMF0pICUgMzYwKSArIDM2MCkgJSAzNjApIC8gMzYwOyAgLy8gMCAuLiAxXG4gICAgICAgIC8vIE5PVEUoZGVhbm0pOiBBY2NvcmRpbmcgdG8gdGhlIENTUyBzcGVjIHMvbCBzaG91bGQgb25seSBiZVxuICAgICAgICAvLyBwZXJjZW50YWdlcywgYnV0IHdlIGRvbid0IGJvdGhlciBhbmQgbGV0IGZsb2F0IG9yIHBlcmNlbnRhZ2UuXG4gICAgICAgIHZhciBzID0gcGFyc2VfY3NzX2Zsb2F0KHBhcmFtc1sxXSk7XG4gICAgICAgIHZhciBsID0gcGFyc2VfY3NzX2Zsb2F0KHBhcmFtc1syXSk7XG4gICAgICAgIHZhciBtMiA9IGwgPD0gMC41ID8gbCAqIChzICsgMSkgOiBsICsgcyAtIGwgKiBzO1xuICAgICAgICB2YXIgbTEgPSBsICogMiAtIG0yO1xuICAgICAgICByZXR1cm4gW2NsYW1wX2Nzc19ieXRlKGNzc19odWVfdG9fcmdiKG0xLCBtMiwgaCsxLzMpICogMjU1KSxcbiAgICAgICAgICAgICAgICBjbGFtcF9jc3NfYnl0ZShjc3NfaHVlX3RvX3JnYihtMSwgbTIsIGgpICogMjU1KSxcbiAgICAgICAgICAgICAgICBjbGFtcF9jc3NfYnl0ZShjc3NfaHVlX3RvX3JnYihtMSwgbTIsIGgtMS8zKSAqIDI1NSksXG4gICAgICAgICAgICAgICAgYWxwaGFdO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnRyeSB7IGV4cG9ydHMucGFyc2VDU1NDb2xvciA9IHBhcnNlQ1NTQ29sb3IgfSBjYXRjaChlKSB7IH1cbiIsImV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0Q2hhbmdlc1RvWE1MKGNoYW5nZXMpIHtcbiAgbGV0IHJldCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgY2hhbmdlID0gY2hhbmdlc1tpXTtcbiAgICBpZiAoY2hhbmdlLmFkZGVkKSB7XG4gICAgICByZXQucHVzaCgnPGlucz4nKTtcbiAgICB9IGVsc2UgaWYgKGNoYW5nZS5yZW1vdmVkKSB7XG4gICAgICByZXQucHVzaCgnPGRlbD4nKTtcbiAgICB9XG5cbiAgICByZXQucHVzaChlc2NhcGVIVE1MKGNoYW5nZS52YWx1ZSkpO1xuXG4gICAgaWYgKGNoYW5nZS5hZGRlZCkge1xuICAgICAgcmV0LnB1c2goJzwvaW5zPicpO1xuICAgIH0gZWxzZSBpZiAoY2hhbmdlLnJlbW92ZWQpIHtcbiAgICAgIHJldC5wdXNoKCc8L2RlbD4nKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldC5qb2luKCcnKTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlSFRNTChzKSB7XG4gIGxldCBuID0gcztcbiAgbiA9IG4ucmVwbGFjZSgvJi9nLCAnJmFtcDsnKTtcbiAgbiA9IG4ucmVwbGFjZSgvPC9nLCAnJmx0OycpO1xuICBuID0gbi5yZXBsYWNlKC8+L2csICcmZ3Q7Jyk7XG4gIG4gPSBuLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKTtcblxuICByZXR1cm4gbjtcbn1cbiIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwiLy8gQ29weXJpZ2h0IDIwMTQsIDIwMTYgU2ltb24gTHlkZWxsXG4vLyBYMTEgKOKAnE1JVOKAnSkgTGljZW5zZWQuIChTZWUgTElDRU5TRS4pXG5cbmZ1bmN0aW9uIHN0cmluZ2lmeSAob2JqLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIHZhciBpbmRlbnQgPSBKU09OLnN0cmluZ2lmeShbMV0sIG51bGwsIGdldChvcHRpb25zLCAnaW5kZW50JywgMikpLnNsaWNlKDIsIC0zKVxuICB2YXIgbWF4TGVuZ3RoID0gKGluZGVudCA9PT0gJycgPyBJbmZpbml0eSA6IGdldChvcHRpb25zLCAnbWF4TGVuZ3RoJywgODApKVxuXG4gIHJldHVybiAoZnVuY3Rpb24gX3N0cmluZ2lmeSAob2JqLCBjdXJyZW50SW5kZW50LCByZXNlcnZlZCkge1xuICAgIGlmIChvYmogJiYgdHlwZW9mIG9iai50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9iaiA9IG9iai50b0pTT04oKVxuICAgIH1cblxuICAgIHZhciBzdHJpbmcgPSBKU09OLnN0cmluZ2lmeShvYmopXG5cbiAgICBpZiAoc3RyaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBzdHJpbmdcbiAgICB9XG5cbiAgICB2YXIgbGVuZ3RoID0gbWF4TGVuZ3RoIC0gY3VycmVudEluZGVudC5sZW5ndGggLSByZXNlcnZlZFxuXG4gICAgaWYgKHN0cmluZy5sZW5ndGggPD0gbGVuZ3RoKSB7XG4gICAgICB2YXIgcHJldHRpZmllZCA9IHByZXR0aWZ5KHN0cmluZylcbiAgICAgIGlmIChwcmV0dGlmaWVkLmxlbmd0aCA8PSBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHByZXR0aWZpZWRcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsKSB7XG4gICAgICB2YXIgbmV4dEluZGVudCA9IGN1cnJlbnRJbmRlbnQgKyBpbmRlbnRcbiAgICAgIHZhciBpdGVtcyA9IFtdXG4gICAgICB2YXIgZGVsaW1pdGVyc1xuICAgICAgdmFyIGNvbW1hID0gZnVuY3Rpb24gKGFycmF5LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gKGluZGV4ID09PSBhcnJheS5sZW5ndGggLSAxID8gMCA6IDEpXG4gICAgICB9XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IG9iai5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKFxuICAgICAgICAgICAgX3N0cmluZ2lmeShvYmpbaW5kZXhdLCBuZXh0SW5kZW50LCBjb21tYShvYmosIGluZGV4KSkgfHwgJ251bGwnXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIGRlbGltaXRlcnMgPSAnW10nXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSwgaW5kZXgsIGFycmF5KSB7XG4gICAgICAgICAgdmFyIGtleVBhcnQgPSBKU09OLnN0cmluZ2lmeShrZXkpICsgJzogJ1xuICAgICAgICAgIHZhciB2YWx1ZSA9IF9zdHJpbmdpZnkob2JqW2tleV0sIG5leHRJbmRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlQYXJ0Lmxlbmd0aCArIGNvbW1hKGFycmF5LCBpbmRleCkpXG4gICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goa2V5UGFydCArIHZhbHVlKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgZGVsaW1pdGVycyA9ICd7fSdcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBkZWxpbWl0ZXJzWzBdLFxuICAgICAgICAgIGluZGVudCArIGl0ZW1zLmpvaW4oJyxcXG4nICsgbmV4dEluZGVudCksXG4gICAgICAgICAgZGVsaW1pdGVyc1sxXVxuICAgICAgICBdLmpvaW4oJ1xcbicgKyBjdXJyZW50SW5kZW50KVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmdcbiAgfShvYmosICcnLCAwKSlcbn1cblxuLy8gTm90ZTogVGhpcyByZWdleCBtYXRjaGVzIGV2ZW4gaW52YWxpZCBKU09OIHN0cmluZ3MsIGJ1dCBzaW5jZSB3ZeKAmXJlXG4vLyB3b3JraW5nIG9uIHRoZSBvdXRwdXQgb2YgYEpTT04uc3RyaW5naWZ5YCB3ZSBrbm93IHRoYXQgb25seSB2YWxpZCBzdHJpbmdzXG4vLyBhcmUgcHJlc2VudCAodW5sZXNzIHRoZSB1c2VyIHN1cHBsaWVkIGEgd2VpcmQgYG9wdGlvbnMuaW5kZW50YCBidXQgaW5cbi8vIHRoYXQgY2FzZSB3ZSBkb27igJl0IGNhcmUgc2luY2UgdGhlIG91dHB1dCB3b3VsZCBiZSBpbnZhbGlkIGFueXdheSkuXG52YXIgc3RyaW5nT3JDaGFyID0gLyhcIig/OlteXFxcXFwiXXxcXFxcLikqXCIpfFs6LF0vZ1xuXG5mdW5jdGlvbiBwcmV0dGlmeSAoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShzdHJpbmdPckNoYXIsIGZ1bmN0aW9uIChtYXRjaCwgc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZyA/IG1hdGNoIDogbWF0Y2ggKyAnICdcbiAgfSlcbn1cblxuZnVuY3Rpb24gZ2V0IChvcHRpb25zLCBuYW1lLCBkZWZhdWx0VmFsdWUpIHtcbiAgcmV0dXJuIChuYW1lIGluIG9wdGlvbnMgPyBvcHRpb25zW25hbWVdIDogZGVmYXVsdFZhbHVlKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cmluZ2lmeVxuIiwiLyogcGFyc2VyIGdlbmVyYXRlZCBieSBqaXNvbiAwLjQuMTUgKi9cbi8qXG4gIFJldHVybnMgYSBQYXJzZXIgb2JqZWN0IG9mIHRoZSBmb2xsb3dpbmcgc3RydWN0dXJlOlxuXG4gIFBhcnNlcjoge1xuICAgIHl5OiB7fVxuICB9XG5cbiAgUGFyc2VyLnByb3RvdHlwZToge1xuICAgIHl5OiB7fSxcbiAgICB0cmFjZTogZnVuY3Rpb24oKSxcbiAgICBzeW1ib2xzXzoge2Fzc29jaWF0aXZlIGxpc3Q6IG5hbWUgPT0+IG51bWJlcn0sXG4gICAgdGVybWluYWxzXzoge2Fzc29jaWF0aXZlIGxpc3Q6IG51bWJlciA9PT4gbmFtZX0sXG4gICAgcHJvZHVjdGlvbnNfOiBbLi4uXSxcbiAgICBwZXJmb3JtQWN0aW9uOiBmdW5jdGlvbiBhbm9ueW1vdXMoeXl0ZXh0LCB5eWxlbmcsIHl5bGluZW5vLCB5eSwgeXlzdGF0ZSwgJCQsIF8kKSxcbiAgICB0YWJsZTogWy4uLl0sXG4gICAgZGVmYXVsdEFjdGlvbnM6IHsuLi59LFxuICAgIHBhcnNlRXJyb3I6IGZ1bmN0aW9uKHN0ciwgaGFzaCksXG4gICAgcGFyc2U6IGZ1bmN0aW9uKGlucHV0KSxcblxuICAgIGxleGVyOiB7XG4gICAgICAgIEVPRjogMSxcbiAgICAgICAgcGFyc2VFcnJvcjogZnVuY3Rpb24oc3RyLCBoYXNoKSxcbiAgICAgICAgc2V0SW5wdXQ6IGZ1bmN0aW9uKGlucHV0KSxcbiAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uKCksXG4gICAgICAgIHVucHV0OiBmdW5jdGlvbihzdHIpLFxuICAgICAgICBtb3JlOiBmdW5jdGlvbigpLFxuICAgICAgICBsZXNzOiBmdW5jdGlvbihuKSxcbiAgICAgICAgcGFzdElucHV0OiBmdW5jdGlvbigpLFxuICAgICAgICB1cGNvbWluZ0lucHV0OiBmdW5jdGlvbigpLFxuICAgICAgICBzaG93UG9zaXRpb246IGZ1bmN0aW9uKCksXG4gICAgICAgIHRlc3RfbWF0Y2g6IGZ1bmN0aW9uKHJlZ2V4X21hdGNoX2FycmF5LCBydWxlX2luZGV4KSxcbiAgICAgICAgbmV4dDogZnVuY3Rpb24oKSxcbiAgICAgICAgbGV4OiBmdW5jdGlvbigpLFxuICAgICAgICBiZWdpbjogZnVuY3Rpb24oY29uZGl0aW9uKSxcbiAgICAgICAgcG9wU3RhdGU6IGZ1bmN0aW9uKCksXG4gICAgICAgIF9jdXJyZW50UnVsZXM6IGZ1bmN0aW9uKCksXG4gICAgICAgIHRvcFN0YXRlOiBmdW5jdGlvbigpLFxuICAgICAgICBwdXNoU3RhdGU6IGZ1bmN0aW9uKGNvbmRpdGlvbiksXG5cbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgcmFuZ2VzOiBib29sZWFuICAgICAgICAgICAob3B0aW9uYWw6IHRydWUgPT0+IHRva2VuIGxvY2F0aW9uIGluZm8gd2lsbCBpbmNsdWRlIGEgLnJhbmdlW10gbWVtYmVyKVxuICAgICAgICAgICAgZmxleDogYm9vbGVhbiAgICAgICAgICAgICAob3B0aW9uYWw6IHRydWUgPT0+IGZsZXgtbGlrZSBsZXhpbmcgYmVoYXZpb3VyIHdoZXJlIHRoZSBydWxlcyBhcmUgdGVzdGVkIGV4aGF1c3RpdmVseSB0byBmaW5kIHRoZSBsb25nZXN0IG1hdGNoKVxuICAgICAgICAgICAgYmFja3RyYWNrX2xleGVyOiBib29sZWFuICAob3B0aW9uYWw6IHRydWUgPT0+IGxleGVyIHJlZ2V4ZXMgYXJlIHRlc3RlZCBpbiBvcmRlciBhbmQgZm9yIGVhY2ggbWF0Y2hpbmcgcmVnZXggdGhlIGFjdGlvbiBjb2RlIGlzIGludm9rZWQ7IHRoZSBsZXhlciB0ZXJtaW5hdGVzIHRoZSBzY2FuIHdoZW4gYSB0b2tlbiBpcyByZXR1cm5lZCBieSB0aGUgYWN0aW9uIGNvZGUpXG4gICAgICAgIH0sXG5cbiAgICAgICAgcGVyZm9ybUFjdGlvbjogZnVuY3Rpb24oeXksIHl5XywgJGF2b2lkaW5nX25hbWVfY29sbGlzaW9ucywgWVlfU1RBUlQpLFxuICAgICAgICBydWxlczogWy4uLl0sXG4gICAgICAgIGNvbmRpdGlvbnM6IHthc3NvY2lhdGl2ZSBsaXN0OiBuYW1lID09PiBzZXR9LFxuICAgIH1cbiAgfVxuXG5cbiAgdG9rZW4gbG9jYXRpb24gaW5mbyAoQCQsIF8kLCBldGMuKToge1xuICAgIGZpcnN0X2xpbmU6IG4sXG4gICAgbGFzdF9saW5lOiBuLFxuICAgIGZpcnN0X2NvbHVtbjogbixcbiAgICBsYXN0X2NvbHVtbjogbixcbiAgICByYW5nZTogW3N0YXJ0X251bWJlciwgZW5kX251bWJlcl0gICAgICAgKHdoZXJlIHRoZSBudW1iZXJzIGFyZSBpbmRleGVzIGludG8gdGhlIGlucHV0IHN0cmluZywgcmVndWxhciB6ZXJvLWJhc2VkKVxuICB9XG5cblxuICB0aGUgcGFyc2VFcnJvciBmdW5jdGlvbiByZWNlaXZlcyBhICdoYXNoJyBvYmplY3Qgd2l0aCB0aGVzZSBtZW1iZXJzIGZvciBsZXhlciBhbmQgcGFyc2VyIGVycm9yczoge1xuICAgIHRleHQ6ICAgICAgICAobWF0Y2hlZCB0ZXh0KVxuICAgIHRva2VuOiAgICAgICAodGhlIHByb2R1Y2VkIHRlcm1pbmFsIHRva2VuLCBpZiBhbnkpXG4gICAgbGluZTogICAgICAgICh5eWxpbmVubylcbiAgfVxuICB3aGlsZSBwYXJzZXIgKGdyYW1tYXIpIGVycm9ycyB3aWxsIGFsc28gcHJvdmlkZSB0aGVzZSBtZW1iZXJzLCBpLmUuIHBhcnNlciBlcnJvcnMgZGVsaXZlciBhIHN1cGVyc2V0IG9mIGF0dHJpYnV0ZXM6IHtcbiAgICBsb2M6ICAgICAgICAgKHl5bGxvYylcbiAgICBleHBlY3RlZDogICAgKHN0cmluZyBkZXNjcmliaW5nIHRoZSBzZXQgb2YgZXhwZWN0ZWQgdG9rZW5zKVxuICAgIHJlY292ZXJhYmxlOiAoYm9vbGVhbjogVFJVRSB3aGVuIHRoZSBwYXJzZXIgaGFzIGEgZXJyb3IgcmVjb3ZlcnkgcnVsZSBhdmFpbGFibGUgZm9yIHRoaXMgcGFydGljdWxhciBlcnJvcilcbiAgfVxuKi9cbnZhciBwYXJzZXIgPSAoZnVuY3Rpb24oKXtcbnZhciBvPWZ1bmN0aW9uKGssdixvLGwpe2ZvcihvPW98fHt9LGw9ay5sZW5ndGg7bC0tO29ba1tsXV09dik7cmV0dXJuIG99LCRWMD1bMSwxMl0sJFYxPVsxLDEzXSwkVjI9WzEsOV0sJFYzPVsxLDEwXSwkVjQ9WzEsMTFdLCRWNT1bMSwxNF0sJFY2PVsxLDE1XSwkVjc9WzE0LDE4LDIyLDI0XSwkVjg9WzE4LDIyXSwkVjk9WzIyLDI0XTtcbnZhciBwYXJzZXIgPSB7dHJhY2U6IGZ1bmN0aW9uIHRyYWNlKCkgeyB9LFxueXk6IHt9LFxuc3ltYm9sc186IHtcImVycm9yXCI6MixcIkpTT05TdHJpbmdcIjozLFwiU1RSSU5HXCI6NCxcIkpTT05OdW1iZXJcIjo1LFwiTlVNQkVSXCI6NixcIkpTT05OdWxsTGl0ZXJhbFwiOjcsXCJOVUxMXCI6OCxcIkpTT05Cb29sZWFuTGl0ZXJhbFwiOjksXCJUUlVFXCI6MTAsXCJGQUxTRVwiOjExLFwiSlNPTlRleHRcIjoxMixcIkpTT05WYWx1ZVwiOjEzLFwiRU9GXCI6MTQsXCJKU09OT2JqZWN0XCI6MTUsXCJKU09OQXJyYXlcIjoxNixcIntcIjoxNyxcIn1cIjoxOCxcIkpTT05NZW1iZXJMaXN0XCI6MTksXCJKU09OTWVtYmVyXCI6MjAsXCI6XCI6MjEsXCIsXCI6MjIsXCJbXCI6MjMsXCJdXCI6MjQsXCJKU09ORWxlbWVudExpc3RcIjoyNSxcIiRhY2NlcHRcIjowLFwiJGVuZFwiOjF9LFxudGVybWluYWxzXzogezI6XCJlcnJvclwiLDQ6XCJTVFJJTkdcIiw2OlwiTlVNQkVSXCIsODpcIk5VTExcIiwxMDpcIlRSVUVcIiwxMTpcIkZBTFNFXCIsMTQ6XCJFT0ZcIiwxNzpcIntcIiwxODpcIn1cIiwyMTpcIjpcIiwyMjpcIixcIiwyMzpcIltcIiwyNDpcIl1cIn0sXG5wcm9kdWN0aW9uc186IFswLFszLDFdLFs1LDFdLFs3LDFdLFs5LDFdLFs5LDFdLFsxMiwyXSxbMTMsMV0sWzEzLDFdLFsxMywxXSxbMTMsMV0sWzEzLDFdLFsxMywxXSxbMTUsMl0sWzE1LDNdLFsyMCwzXSxbMTksMV0sWzE5LDNdLFsxNiwyXSxbMTYsM10sWzI1LDFdLFsyNSwzXV0sXG5wZXJmb3JtQWN0aW9uOiBmdW5jdGlvbiBhbm9ueW1vdXMoeXl0ZXh0LCB5eWxlbmcsIHl5bGluZW5vLCB5eSwgeXlzdGF0ZSAvKiBhY3Rpb25bMV0gKi8sICQkIC8qIHZzdGFjayAqLywgXyQgLyogbHN0YWNrICovKSB7XG4vKiB0aGlzID09IHl5dmFsICovXG5cbnZhciAkMCA9ICQkLmxlbmd0aCAtIDE7XG5zd2l0Y2ggKHl5c3RhdGUpIHtcbmNhc2UgMTpcbiAvLyByZXBsYWNlIGVzY2FwZWQgY2hhcmFjdGVycyB3aXRoIGFjdHVhbCBjaGFyYWN0ZXJcbiAgICAgICAgICB0aGlzLiQgPSBuZXcgU3RyaW5nKHl5dGV4dC5yZXBsYWNlKC9cXFxcKFxcXFx8XCIpL2csIFwiJFwiK1wiMVwiKVxuICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxuL2csJ1xcbicpXG4gICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXHIvZywnXFxyJylcbiAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcdC9nLCdcXHQnKVxuICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFx2L2csJ1xcdicpXG4gICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXGYvZywnXFxmJylcbiAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcYi9nLCdcXGInKSk7XG4gICAgICAgICAgdGhpcy4kLl9fbGluZV9fID0gIHRoaXMuXyQuZmlyc3RfbGluZTtcbiAgICAgICAgXG5icmVhaztcbmNhc2UgMjpcblxuICAgICAgICAgICAgdGhpcy4kID0gbmV3IE51bWJlcih5eXRleHQpO1xuICAgICAgICAgICAgdGhpcy4kLl9fbGluZV9fID0gIHRoaXMuXyQuZmlyc3RfbGluZTtcbiAgICAgICAgXG5icmVhaztcbmNhc2UgMzpcblxuICAgICAgICAgICAgdGhpcy4kID0gbnVsbDtcbiAgICAgICAgXG5icmVhaztcbmNhc2UgNDpcblxuICAgICAgICAgICAgdGhpcy4kID0gbmV3IEJvb2xlYW4odHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLiQuX19saW5lX18gPSB0aGlzLl8kLmZpcnN0X2xpbmU7XG4gICAgICAgIFxuYnJlYWs7XG5jYXNlIDU6XG5cbiAgICAgICAgICAgIHRoaXMuJCA9IG5ldyBCb29sZWFuKGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuJC5fX2xpbmVfXyA9IHRoaXMuXyQuZmlyc3RfbGluZTtcbiAgICAgICAgXG5icmVhaztcbmNhc2UgNjpcbnJldHVybiB0aGlzLiQgPSAkJFskMC0xXTtcbmJyZWFrO1xuY2FzZSAxMzpcbnRoaXMuJCA9IHt9OyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy4kLCAnX19saW5lX18nLCB7XG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5fJC5maXJzdF9saW5lLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgfSlcbmJyZWFrO1xuY2FzZSAxNDogY2FzZSAxOTpcbnRoaXMuJCA9ICQkWyQwLTFdOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy4kLCAnX19saW5lX18nLCB7XG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5fJC5maXJzdF9saW5lLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgfSlcbmJyZWFrO1xuY2FzZSAxNTpcbnRoaXMuJCA9IFskJFskMC0yXSwgJCRbJDBdXTtcbmJyZWFrO1xuY2FzZSAxNjpcbnRoaXMuJCA9IHt9OyB0aGlzLiRbJCRbJDBdWzBdXSA9ICQkWyQwXVsxXTtcbmJyZWFrO1xuY2FzZSAxNzpcbnRoaXMuJCA9ICQkWyQwLTJdOyAkJFskMC0yXVskJFskMF1bMF1dID0gJCRbJDBdWzFdO1xuYnJlYWs7XG5jYXNlIDE4OlxudGhpcy4kID0gW107IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLiQsICdfX2xpbmVfXycsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLl8kLmZpcnN0X2xpbmUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICB9KVxuYnJlYWs7XG5jYXNlIDIwOlxudGhpcy4kID0gWyQkWyQwXV07XG5icmVhaztcbmNhc2UgMjE6XG50aGlzLiQgPSAkJFskMC0yXTsgJCRbJDAtMl0ucHVzaCgkJFskMF0pO1xuYnJlYWs7XG59XG59LFxudGFibGU6IFt7Mzo1LDQ6JFYwLDU6Niw2OiRWMSw3OjMsODokVjIsOTo0LDEwOiRWMywxMTokVjQsMTI6MSwxMzoyLDE1OjcsMTY6OCwxNzokVjUsMjM6JFY2fSx7MTpbM119LHsxNDpbMSwxNl19LG8oJFY3LFsyLDddKSxvKCRWNyxbMiw4XSksbygkVjcsWzIsOV0pLG8oJFY3LFsyLDEwXSksbygkVjcsWzIsMTFdKSxvKCRWNyxbMiwxMl0pLG8oJFY3LFsyLDNdKSxvKCRWNyxbMiw0XSksbygkVjcsWzIsNV0pLG8oWzE0LDE4LDIxLDIyLDI0XSxbMiwxXSksbygkVjcsWzIsMl0pLHszOjIwLDQ6JFYwLDE4OlsxLDE3XSwxOToxOCwyMDoxOX0sezM6NSw0OiRWMCw1OjYsNjokVjEsNzozLDg6JFYyLDk6NCwxMDokVjMsMTE6JFY0LDEzOjIzLDE1OjcsMTY6OCwxNzokVjUsMjM6JFY2LDI0OlsxLDIxXSwyNToyMn0sezE6WzIsNl19LG8oJFY3LFsyLDEzXSksezE4OlsxLDI0XSwyMjpbMSwyNV19LG8oJFY4LFsyLDE2XSksezIxOlsxLDI2XX0sbygkVjcsWzIsMThdKSx7MjI6WzEsMjhdLDI0OlsxLDI3XX0sbygkVjksWzIsMjBdKSxvKCRWNyxbMiwxNF0pLHszOjIwLDQ6JFYwLDIwOjI5fSx7Mzo1LDQ6JFYwLDU6Niw2OiRWMSw3OjMsODokVjIsOTo0LDEwOiRWMywxMTokVjQsMTM6MzAsMTU6NywxNjo4LDE3OiRWNSwyMzokVjZ9LG8oJFY3LFsyLDE5XSksezM6NSw0OiRWMCw1OjYsNjokVjEsNzozLDg6JFYyLDk6NCwxMDokVjMsMTE6JFY0LDEzOjMxLDE1OjcsMTY6OCwxNzokVjUsMjM6JFY2fSxvKCRWOCxbMiwxN10pLG8oJFY4LFsyLDE1XSksbygkVjksWzIsMjFdKV0sXG5kZWZhdWx0QWN0aW9uczogezE2OlsyLDZdfSxcbnBhcnNlRXJyb3I6IGZ1bmN0aW9uIHBhcnNlRXJyb3Ioc3RyLCBoYXNoKSB7XG4gICAgaWYgKGhhc2gucmVjb3ZlcmFibGUpIHtcbiAgICAgICAgdGhpcy50cmFjZShzdHIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihzdHIpO1xuICAgIH1cbn0sXG5wYXJzZTogZnVuY3Rpb24gcGFyc2UoaW5wdXQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsIHN0YWNrID0gWzBdLCB0c3RhY2sgPSBbXSwgdnN0YWNrID0gW251bGxdLCBsc3RhY2sgPSBbXSwgdGFibGUgPSB0aGlzLnRhYmxlLCB5eXRleHQgPSAnJywgeXlsaW5lbm8gPSAwLCB5eWxlbmcgPSAwLCByZWNvdmVyaW5nID0gMCwgVEVSUk9SID0gMiwgRU9GID0gMTtcbiAgICB2YXIgYXJncyA9IGxzdGFjay5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgdmFyIGxleGVyID0gT2JqZWN0LmNyZWF0ZSh0aGlzLmxleGVyKTtcbiAgICB2YXIgc2hhcmVkU3RhdGUgPSB7IHl5OiB7fSB9O1xuICAgIGZvciAodmFyIGsgaW4gdGhpcy55eSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMueXksIGspKSB7XG4gICAgICAgICAgICBzaGFyZWRTdGF0ZS55eVtrXSA9IHRoaXMueXlba107XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV4ZXIuc2V0SW5wdXQoaW5wdXQsIHNoYXJlZFN0YXRlLnl5KTtcbiAgICBzaGFyZWRTdGF0ZS55eS5sZXhlciA9IGxleGVyO1xuICAgIHNoYXJlZFN0YXRlLnl5LnBhcnNlciA9IHRoaXM7XG4gICAgaWYgKHR5cGVvZiBsZXhlci55eWxsb2MgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbGV4ZXIueXlsbG9jID0ge307XG4gICAgfVxuICAgIHZhciB5eWxvYyA9IGxleGVyLnl5bGxvYztcbiAgICBsc3RhY2sucHVzaCh5eWxvYyk7XG4gICAgdmFyIHJhbmdlcyA9IGxleGVyLm9wdGlvbnMgJiYgbGV4ZXIub3B0aW9ucy5yYW5nZXM7XG4gICAgaWYgKHR5cGVvZiBzaGFyZWRTdGF0ZS55eS5wYXJzZUVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucGFyc2VFcnJvciA9IHNoYXJlZFN0YXRlLnl5LnBhcnNlRXJyb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXJzZUVycm9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLnBhcnNlRXJyb3I7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcFN0YWNrKG4pIHtcbiAgICAgICAgc3RhY2subGVuZ3RoID0gc3RhY2subGVuZ3RoIC0gMiAqIG47XG4gICAgICAgIHZzdGFjay5sZW5ndGggPSB2c3RhY2subGVuZ3RoIC0gbjtcbiAgICAgICAgbHN0YWNrLmxlbmd0aCA9IGxzdGFjay5sZW5ndGggLSBuO1xuICAgIH1cbiAgICBfdG9rZW5fc3RhY2s6XG4gICAgICAgIGZ1bmN0aW9uIGxleCgpIHtcbiAgICAgICAgICAgIHZhciB0b2tlbjtcbiAgICAgICAgICAgIHRva2VuID0gbGV4ZXIubGV4KCkgfHwgRU9GO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHNlbGYuc3ltYm9sc19bdG9rZW5dIHx8IHRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9XG4gICAgdmFyIHN5bWJvbCwgcHJlRXJyb3JTeW1ib2wsIHN0YXRlLCBhY3Rpb24sIGEsIHIsIHl5dmFsID0ge30sIHAsIGxlbiwgbmV3U3RhdGUsIGV4cGVjdGVkO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHN0YXRlID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICh0aGlzLmRlZmF1bHRBY3Rpb25zW3N0YXRlXSkge1xuICAgICAgICAgICAgYWN0aW9uID0gdGhpcy5kZWZhdWx0QWN0aW9uc1tzdGF0ZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3ltYm9sID09PSBudWxsIHx8IHR5cGVvZiBzeW1ib2wgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBsZXgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFjdGlvbiA9IHRhYmxlW3N0YXRlXSAmJiB0YWJsZVtzdGF0ZV1bc3ltYm9sXTtcbiAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ3VuZGVmaW5lZCcgfHwgIWFjdGlvbi5sZW5ndGggfHwgIWFjdGlvblswXSkge1xuICAgICAgICAgICAgICAgIHZhciBlcnJTdHIgPSAnJztcbiAgICAgICAgICAgICAgICBleHBlY3RlZCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAocCBpbiB0YWJsZVtzdGF0ZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudGVybWluYWxzX1twXSAmJiBwID4gVEVSUk9SKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZC5wdXNoKCdcXCcnICsgdGhpcy50ZXJtaW5hbHNfW3BdICsgJ1xcJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsZXhlci5zaG93UG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyU3RyID0gJ1BhcnNlIGVycm9yIG9uIGxpbmUgJyArICh5eWxpbmVubyArIDEpICsgJzpcXG4nICsgbGV4ZXIuc2hvd1Bvc2l0aW9uKCkgKyAnXFxuRXhwZWN0aW5nICcgKyBleHBlY3RlZC5qb2luKCcsICcpICsgJywgZ290IFxcJycgKyAodGhpcy50ZXJtaW5hbHNfW3N5bWJvbF0gfHwgc3ltYm9sKSArICdcXCcnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVyclN0ciA9ICdQYXJzZSBlcnJvciBvbiBsaW5lICcgKyAoeXlsaW5lbm8gKyAxKSArICc6IFVuZXhwZWN0ZWQgJyArIChzeW1ib2wgPT0gRU9GID8gJ2VuZCBvZiBpbnB1dCcgOiAnXFwnJyArICh0aGlzLnRlcm1pbmFsc19bc3ltYm9sXSB8fCBzeW1ib2wpICsgJ1xcJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlRXJyb3IoZXJyU3RyLCB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGxleGVyLm1hdGNoLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbjogdGhpcy50ZXJtaW5hbHNfW3N5bWJvbF0gfHwgc3ltYm9sLFxuICAgICAgICAgICAgICAgICAgICBsaW5lOiBsZXhlci55eWxpbmVubyxcbiAgICAgICAgICAgICAgICAgICAgbG9jOiB5eWxvYyxcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGlmIChhY3Rpb25bMF0gaW5zdGFuY2VvZiBBcnJheSAmJiBhY3Rpb24ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJzZSBFcnJvcjogbXVsdGlwbGUgYWN0aW9ucyBwb3NzaWJsZSBhdCBzdGF0ZTogJyArIHN0YXRlICsgJywgdG9rZW46ICcgKyBzeW1ib2wpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoYWN0aW9uWzBdKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHN0YWNrLnB1c2goc3ltYm9sKTtcbiAgICAgICAgICAgIHZzdGFjay5wdXNoKGxleGVyLnl5dGV4dCk7XG4gICAgICAgICAgICBsc3RhY2sucHVzaChsZXhlci55eWxsb2MpO1xuICAgICAgICAgICAgc3RhY2sucHVzaChhY3Rpb25bMV0pO1xuICAgICAgICAgICAgc3ltYm9sID0gbnVsbDtcbiAgICAgICAgICAgIGlmICghcHJlRXJyb3JTeW1ib2wpIHtcbiAgICAgICAgICAgICAgICB5eWxlbmcgPSBsZXhlci55eWxlbmc7XG4gICAgICAgICAgICAgICAgeXl0ZXh0ID0gbGV4ZXIueXl0ZXh0O1xuICAgICAgICAgICAgICAgIHl5bGluZW5vID0gbGV4ZXIueXlsaW5lbm87XG4gICAgICAgICAgICAgICAgeXlsb2MgPSBsZXhlci55eWxsb2M7XG4gICAgICAgICAgICAgICAgaWYgKHJlY292ZXJpbmcgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY292ZXJpbmctLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN5bWJvbCA9IHByZUVycm9yU3ltYm9sO1xuICAgICAgICAgICAgICAgIHByZUVycm9yU3ltYm9sID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBsZW4gPSB0aGlzLnByb2R1Y3Rpb25zX1thY3Rpb25bMV1dWzFdO1xuICAgICAgICAgICAgeXl2YWwuJCA9IHZzdGFja1t2c3RhY2subGVuZ3RoIC0gbGVuXTtcbiAgICAgICAgICAgIHl5dmFsLl8kID0ge1xuICAgICAgICAgICAgICAgIGZpcnN0X2xpbmU6IGxzdGFja1tsc3RhY2subGVuZ3RoIC0gKGxlbiB8fCAxKV0uZmlyc3RfbGluZSxcbiAgICAgICAgICAgICAgICBsYXN0X2xpbmU6IGxzdGFja1tsc3RhY2subGVuZ3RoIC0gMV0ubGFzdF9saW5lLFxuICAgICAgICAgICAgICAgIGZpcnN0X2NvbHVtbjogbHN0YWNrW2xzdGFjay5sZW5ndGggLSAobGVuIHx8IDEpXS5maXJzdF9jb2x1bW4sXG4gICAgICAgICAgICAgICAgbGFzdF9jb2x1bW46IGxzdGFja1tsc3RhY2subGVuZ3RoIC0gMV0ubGFzdF9jb2x1bW5cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgeXl2YWwuXyQucmFuZ2UgPSBbXG4gICAgICAgICAgICAgICAgICAgIGxzdGFja1tsc3RhY2subGVuZ3RoIC0gKGxlbiB8fCAxKV0ucmFuZ2VbMF0sXG4gICAgICAgICAgICAgICAgICAgIGxzdGFja1tsc3RhY2subGVuZ3RoIC0gMV0ucmFuZ2VbMV1cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgciA9IHRoaXMucGVyZm9ybUFjdGlvbi5hcHBseSh5eXZhbCwgW1xuICAgICAgICAgICAgICAgIHl5dGV4dCxcbiAgICAgICAgICAgICAgICB5eWxlbmcsXG4gICAgICAgICAgICAgICAgeXlsaW5lbm8sXG4gICAgICAgICAgICAgICAgc2hhcmVkU3RhdGUueXksXG4gICAgICAgICAgICAgICAgYWN0aW9uWzFdLFxuICAgICAgICAgICAgICAgIHZzdGFjayxcbiAgICAgICAgICAgICAgICBsc3RhY2tcbiAgICAgICAgICAgIF0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICBzdGFjayA9IHN0YWNrLnNsaWNlKDAsIC0xICogbGVuICogMik7XG4gICAgICAgICAgICAgICAgdnN0YWNrID0gdnN0YWNrLnNsaWNlKDAsIC0xICogbGVuKTtcbiAgICAgICAgICAgICAgICBsc3RhY2sgPSBsc3RhY2suc2xpY2UoMCwgLTEgKiBsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhY2sucHVzaCh0aGlzLnByb2R1Y3Rpb25zX1thY3Rpb25bMV1dWzBdKTtcbiAgICAgICAgICAgIHZzdGFjay5wdXNoKHl5dmFsLiQpO1xuICAgICAgICAgICAgbHN0YWNrLnB1c2goeXl2YWwuXyQpO1xuICAgICAgICAgICAgbmV3U3RhdGUgPSB0YWJsZVtzdGFja1tzdGFjay5sZW5ndGggLSAyXV1bc3RhY2tbc3RhY2subGVuZ3RoIC0gMV1dO1xuICAgICAgICAgICAgc3RhY2sucHVzaChuZXdTdGF0ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59fTtcbi8qIGdlbmVyYXRlZCBieSBqaXNvbi1sZXggMC4zLjQgKi9cbnZhciBsZXhlciA9IChmdW5jdGlvbigpe1xudmFyIGxleGVyID0gKHtcblxuRU9GOjEsXG5cbnBhcnNlRXJyb3I6ZnVuY3Rpb24gcGFyc2VFcnJvcihzdHIsIGhhc2gpIHtcbiAgICAgICAgaWYgKHRoaXMueXkucGFyc2VyKSB7XG4gICAgICAgICAgICB0aGlzLnl5LnBhcnNlci5wYXJzZUVycm9yKHN0ciwgaGFzaCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioc3RyKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbi8vIHJlc2V0cyB0aGUgbGV4ZXIsIHNldHMgbmV3IGlucHV0XG5zZXRJbnB1dDpmdW5jdGlvbiAoaW5wdXQsIHl5KSB7XG4gICAgICAgIHRoaXMueXkgPSB5eSB8fCB0aGlzLnl5IHx8IHt9O1xuICAgICAgICB0aGlzLl9pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLl9tb3JlID0gdGhpcy5fYmFja3RyYWNrID0gdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMueXlsaW5lbm8gPSB0aGlzLnl5bGVuZyA9IDA7XG4gICAgICAgIHRoaXMueXl0ZXh0ID0gdGhpcy5tYXRjaGVkID0gdGhpcy5tYXRjaCA9ICcnO1xuICAgICAgICB0aGlzLmNvbmRpdGlvblN0YWNrID0gWydJTklUSUFMJ107XG4gICAgICAgIHRoaXMueXlsbG9jID0ge1xuICAgICAgICAgICAgZmlyc3RfbGluZTogMSxcbiAgICAgICAgICAgIGZpcnN0X2NvbHVtbjogMCxcbiAgICAgICAgICAgIGxhc3RfbGluZTogMSxcbiAgICAgICAgICAgIGxhc3RfY29sdW1uOiAwXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLnl5bGxvYy5yYW5nZSA9IFswLDBdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuLy8gY29uc3VtZXMgYW5kIHJldHVybnMgb25lIGNoYXIgZnJvbSB0aGUgaW5wdXRcbmlucHV0OmZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNoID0gdGhpcy5faW5wdXRbMF07XG4gICAgICAgIHRoaXMueXl0ZXh0ICs9IGNoO1xuICAgICAgICB0aGlzLnl5bGVuZysrO1xuICAgICAgICB0aGlzLm9mZnNldCsrO1xuICAgICAgICB0aGlzLm1hdGNoICs9IGNoO1xuICAgICAgICB0aGlzLm1hdGNoZWQgKz0gY2g7XG4gICAgICAgIHZhciBsaW5lcyA9IGNoLm1hdGNoKC8oPzpcXHJcXG4/fFxcbikuKi9nKTtcbiAgICAgICAgaWYgKGxpbmVzKSB7XG4gICAgICAgICAgICB0aGlzLnl5bGluZW5vKys7XG4gICAgICAgICAgICB0aGlzLnl5bGxvYy5sYXN0X2xpbmUrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMueXlsbG9jLmxhc3RfY29sdW1uKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMueXlsbG9jLnJhbmdlWzFdKys7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9pbnB1dCA9IHRoaXMuX2lucHV0LnNsaWNlKDEpO1xuICAgICAgICByZXR1cm4gY2g7XG4gICAgfSxcblxuLy8gdW5zaGlmdHMgb25lIGNoYXIgKG9yIGEgc3RyaW5nKSBpbnRvIHRoZSBpbnB1dFxudW5wdXQ6ZnVuY3Rpb24gKGNoKSB7XG4gICAgICAgIHZhciBsZW4gPSBjaC5sZW5ndGg7XG4gICAgICAgIHZhciBsaW5lcyA9IGNoLnNwbGl0KC8oPzpcXHJcXG4/fFxcbikvZyk7XG5cbiAgICAgICAgdGhpcy5faW5wdXQgPSBjaCArIHRoaXMuX2lucHV0O1xuICAgICAgICB0aGlzLnl5dGV4dCA9IHRoaXMueXl0ZXh0LnN1YnN0cigwLCB0aGlzLnl5dGV4dC5sZW5ndGggLSBsZW4pO1xuICAgICAgICAvL3RoaXMueXlsZW5nIC09IGxlbjtcbiAgICAgICAgdGhpcy5vZmZzZXQgLT0gbGVuO1xuICAgICAgICB2YXIgb2xkTGluZXMgPSB0aGlzLm1hdGNoLnNwbGl0KC8oPzpcXHJcXG4/fFxcbikvZyk7XG4gICAgICAgIHRoaXMubWF0Y2ggPSB0aGlzLm1hdGNoLnN1YnN0cigwLCB0aGlzLm1hdGNoLmxlbmd0aCAtIDEpO1xuICAgICAgICB0aGlzLm1hdGNoZWQgPSB0aGlzLm1hdGNoZWQuc3Vic3RyKDAsIHRoaXMubWF0Y2hlZC5sZW5ndGggLSAxKTtcblxuICAgICAgICBpZiAobGluZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgdGhpcy55eWxpbmVubyAtPSBsaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICB9XG4gICAgICAgIHZhciByID0gdGhpcy55eWxsb2MucmFuZ2U7XG5cbiAgICAgICAgdGhpcy55eWxsb2MgPSB7XG4gICAgICAgICAgICBmaXJzdF9saW5lOiB0aGlzLnl5bGxvYy5maXJzdF9saW5lLFxuICAgICAgICAgICAgbGFzdF9saW5lOiB0aGlzLnl5bGluZW5vICsgMSxcbiAgICAgICAgICAgIGZpcnN0X2NvbHVtbjogdGhpcy55eWxsb2MuZmlyc3RfY29sdW1uLFxuICAgICAgICAgICAgbGFzdF9jb2x1bW46IGxpbmVzID9cbiAgICAgICAgICAgICAgICAobGluZXMubGVuZ3RoID09PSBvbGRMaW5lcy5sZW5ndGggPyB0aGlzLnl5bGxvYy5maXJzdF9jb2x1bW4gOiAwKVxuICAgICAgICAgICAgICAgICArIG9sZExpbmVzW29sZExpbmVzLmxlbmd0aCAtIGxpbmVzLmxlbmd0aF0ubGVuZ3RoIC0gbGluZXNbMF0ubGVuZ3RoIDpcbiAgICAgICAgICAgICAgdGhpcy55eWxsb2MuZmlyc3RfY29sdW1uIC0gbGVuXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMueXlsbG9jLnJhbmdlID0gW3JbMF0sIHJbMF0gKyB0aGlzLnl5bGVuZyAtIGxlbl07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy55eWxlbmcgPSB0aGlzLnl5dGV4dC5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbi8vIFdoZW4gY2FsbGVkIGZyb20gYWN0aW9uLCBjYWNoZXMgbWF0Y2hlZCB0ZXh0IGFuZCBhcHBlbmRzIGl0IG9uIG5leHQgYWN0aW9uXG5tb3JlOmZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbW9yZSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbi8vIFdoZW4gY2FsbGVkIGZyb20gYWN0aW9uLCBzaWduYWxzIHRoZSBsZXhlciB0aGF0IHRoaXMgcnVsZSBmYWlscyB0byBtYXRjaCB0aGUgaW5wdXQsIHNvIHRoZSBuZXh0IG1hdGNoaW5nIHJ1bGUgKHJlZ2V4KSBzaG91bGQgYmUgdGVzdGVkIGluc3RlYWQuXG5yZWplY3Q6ZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJhY2t0cmFja19sZXhlcikge1xuICAgICAgICAgICAgdGhpcy5fYmFja3RyYWNrID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRXJyb3IoJ0xleGljYWwgZXJyb3Igb24gbGluZSAnICsgKHRoaXMueXlsaW5lbm8gKyAxKSArICcuIFlvdSBjYW4gb25seSBpbnZva2UgcmVqZWN0KCkgaW4gdGhlIGxleGVyIHdoZW4gdGhlIGxleGVyIGlzIG9mIHRoZSBiYWNrdHJhY2tpbmcgcGVyc3Vhc2lvbiAob3B0aW9ucy5iYWNrdHJhY2tfbGV4ZXIgPSB0cnVlKS5cXG4nICsgdGhpcy5zaG93UG9zaXRpb24oKSwge1xuICAgICAgICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgdG9rZW46IG51bGwsXG4gICAgICAgICAgICAgICAgbGluZTogdGhpcy55eWxpbmVub1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4vLyByZXRhaW4gZmlyc3QgbiBjaGFyYWN0ZXJzIG9mIHRoZSBtYXRjaFxubGVzczpmdW5jdGlvbiAobikge1xuICAgICAgICB0aGlzLnVucHV0KHRoaXMubWF0Y2guc2xpY2UobikpO1xuICAgIH0sXG5cbi8vIGRpc3BsYXlzIGFscmVhZHkgbWF0Y2hlZCBpbnB1dCwgaS5lLiBmb3IgZXJyb3IgbWVzc2FnZXNcbnBhc3RJbnB1dDpmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXN0ID0gdGhpcy5tYXRjaGVkLnN1YnN0cigwLCB0aGlzLm1hdGNoZWQubGVuZ3RoIC0gdGhpcy5tYXRjaC5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gKHBhc3QubGVuZ3RoID4gMjAgPyAnLi4uJzonJykgKyBwYXN0LnN1YnN0cigtMjApLnJlcGxhY2UoL1xcbi9nLCBcIlwiKTtcbiAgICB9LFxuXG4vLyBkaXNwbGF5cyB1cGNvbWluZyBpbnB1dCwgaS5lLiBmb3IgZXJyb3IgbWVzc2FnZXNcbnVwY29taW5nSW5wdXQ6ZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV4dCA9IHRoaXMubWF0Y2g7XG4gICAgICAgIGlmIChuZXh0Lmxlbmd0aCA8IDIwKSB7XG4gICAgICAgICAgICBuZXh0ICs9IHRoaXMuX2lucHV0LnN1YnN0cigwLCAyMC1uZXh0Lmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChuZXh0LnN1YnN0cigwLDIwKSArIChuZXh0Lmxlbmd0aCA+IDIwID8gJy4uLicgOiAnJykpLnJlcGxhY2UoL1xcbi9nLCBcIlwiKTtcbiAgICB9LFxuXG4vLyBkaXNwbGF5cyB0aGUgY2hhcmFjdGVyIHBvc2l0aW9uIHdoZXJlIHRoZSBsZXhpbmcgZXJyb3Igb2NjdXJyZWQsIGkuZS4gZm9yIGVycm9yIG1lc3NhZ2VzXG5zaG93UG9zaXRpb246ZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJlID0gdGhpcy5wYXN0SW5wdXQoKTtcbiAgICAgICAgdmFyIGMgPSBuZXcgQXJyYXkocHJlLmxlbmd0aCArIDEpLmpvaW4oXCItXCIpO1xuICAgICAgICByZXR1cm4gcHJlICsgdGhpcy51cGNvbWluZ0lucHV0KCkgKyBcIlxcblwiICsgYyArIFwiXlwiO1xuICAgIH0sXG5cbi8vIHRlc3QgdGhlIGxleGVkIHRva2VuOiByZXR1cm4gRkFMU0Ugd2hlbiBub3QgYSBtYXRjaCwgb3RoZXJ3aXNlIHJldHVybiB0b2tlblxudGVzdF9tYXRjaDpmdW5jdGlvbiAobWF0Y2gsIGluZGV4ZWRfcnVsZSkge1xuICAgICAgICB2YXIgdG9rZW4sXG4gICAgICAgICAgICBsaW5lcyxcbiAgICAgICAgICAgIGJhY2t1cDtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJhY2t0cmFja19sZXhlcikge1xuICAgICAgICAgICAgLy8gc2F2ZSBjb250ZXh0XG4gICAgICAgICAgICBiYWNrdXAgPSB7XG4gICAgICAgICAgICAgICAgeXlsaW5lbm86IHRoaXMueXlsaW5lbm8sXG4gICAgICAgICAgICAgICAgeXlsbG9jOiB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0X2xpbmU6IHRoaXMueXlsbG9jLmZpcnN0X2xpbmUsXG4gICAgICAgICAgICAgICAgICAgIGxhc3RfbGluZTogdGhpcy5sYXN0X2xpbmUsXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0X2NvbHVtbjogdGhpcy55eWxsb2MuZmlyc3RfY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICBsYXN0X2NvbHVtbjogdGhpcy55eWxsb2MubGFzdF9jb2x1bW5cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHl5dGV4dDogdGhpcy55eXRleHQsXG4gICAgICAgICAgICAgICAgbWF0Y2g6IHRoaXMubWF0Y2gsXG4gICAgICAgICAgICAgICAgbWF0Y2hlczogdGhpcy5tYXRjaGVzLFxuICAgICAgICAgICAgICAgIG1hdGNoZWQ6IHRoaXMubWF0Y2hlZCxcbiAgICAgICAgICAgICAgICB5eWxlbmc6IHRoaXMueXlsZW5nLFxuICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgX21vcmU6IHRoaXMuX21vcmUsXG4gICAgICAgICAgICAgICAgX2lucHV0OiB0aGlzLl9pbnB1dCxcbiAgICAgICAgICAgICAgICB5eTogdGhpcy55eSxcbiAgICAgICAgICAgICAgICBjb25kaXRpb25TdGFjazogdGhpcy5jb25kaXRpb25TdGFjay5zbGljZSgwKSxcbiAgICAgICAgICAgICAgICBkb25lOiB0aGlzLmRvbmVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykge1xuICAgICAgICAgICAgICAgIGJhY2t1cC55eWxsb2MucmFuZ2UgPSB0aGlzLnl5bGxvYy5yYW5nZS5zbGljZSgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxpbmVzID0gbWF0Y2hbMF0ubWF0Y2goLyg/Olxcclxcbj98XFxuKS4qL2cpO1xuICAgICAgICBpZiAobGluZXMpIHtcbiAgICAgICAgICAgIHRoaXMueXlsaW5lbm8gKz0gbGluZXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueXlsbG9jID0ge1xuICAgICAgICAgICAgZmlyc3RfbGluZTogdGhpcy55eWxsb2MubGFzdF9saW5lLFxuICAgICAgICAgICAgbGFzdF9saW5lOiB0aGlzLnl5bGluZW5vICsgMSxcbiAgICAgICAgICAgIGZpcnN0X2NvbHVtbjogdGhpcy55eWxsb2MubGFzdF9jb2x1bW4sXG4gICAgICAgICAgICBsYXN0X2NvbHVtbjogbGluZXMgP1xuICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLmxlbmd0aCAtIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLm1hdGNoKC9cXHI/XFxuPy8pWzBdLmxlbmd0aCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy55eWxsb2MubGFzdF9jb2x1bW4gKyBtYXRjaFswXS5sZW5ndGhcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy55eXRleHQgKz0gbWF0Y2hbMF07XG4gICAgICAgIHRoaXMubWF0Y2ggKz0gbWF0Y2hbMF07XG4gICAgICAgIHRoaXMubWF0Y2hlcyA9IG1hdGNoO1xuICAgICAgICB0aGlzLnl5bGVuZyA9IHRoaXMueXl0ZXh0Lmxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMueXlsbG9jLnJhbmdlID0gW3RoaXMub2Zmc2V0LCB0aGlzLm9mZnNldCArPSB0aGlzLnl5bGVuZ107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbW9yZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9iYWNrdHJhY2sgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faW5wdXQgPSB0aGlzLl9pbnB1dC5zbGljZShtYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICB0aGlzLm1hdGNoZWQgKz0gbWF0Y2hbMF07XG4gICAgICAgIHRva2VuID0gdGhpcy5wZXJmb3JtQWN0aW9uLmNhbGwodGhpcywgdGhpcy55eSwgdGhpcywgaW5kZXhlZF9ydWxlLCB0aGlzLmNvbmRpdGlvblN0YWNrW3RoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMV0pO1xuICAgICAgICBpZiAodGhpcy5kb25lICYmIHRoaXMuX2lucHV0KSB7XG4gICAgICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9iYWNrdHJhY2spIHtcbiAgICAgICAgICAgIC8vIHJlY292ZXIgY29udGV4dFxuICAgICAgICAgICAgZm9yICh2YXIgayBpbiBiYWNrdXApIHtcbiAgICAgICAgICAgICAgICB0aGlzW2tdID0gYmFja3VwW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBydWxlIGFjdGlvbiBjYWxsZWQgcmVqZWN0KCkgaW1wbHlpbmcgdGhlIG5leHQgcnVsZSBzaG91bGQgYmUgdGVzdGVkIGluc3RlYWQuXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbi8vIHJldHVybiBuZXh0IG1hdGNoIGluIGlucHV0XG5uZXh0OmZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuRU9GO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faW5wdXQpIHtcbiAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG9rZW4sXG4gICAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICAgIHRlbXBNYXRjaCxcbiAgICAgICAgICAgIGluZGV4O1xuICAgICAgICBpZiAoIXRoaXMuX21vcmUpIHtcbiAgICAgICAgICAgIHRoaXMueXl0ZXh0ID0gJyc7XG4gICAgICAgICAgICB0aGlzLm1hdGNoID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJ1bGVzID0gdGhpcy5fY3VycmVudFJ1bGVzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRlbXBNYXRjaCA9IHRoaXMuX2lucHV0Lm1hdGNoKHRoaXMucnVsZXNbcnVsZXNbaV1dKTtcbiAgICAgICAgICAgIGlmICh0ZW1wTWF0Y2ggJiYgKCFtYXRjaCB8fCB0ZW1wTWF0Y2hbMF0ubGVuZ3RoID4gbWF0Y2hbMF0ubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIG1hdGNoID0gdGVtcE1hdGNoO1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJhY2t0cmFja19sZXhlcikge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudGVzdF9tYXRjaCh0ZW1wTWF0Y2gsIHJ1bGVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JhY2t0cmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBydWxlIGFjdGlvbiBjYWxsZWQgcmVqZWN0KCkgaW1wbHlpbmcgYSBydWxlIE1JU21hdGNoLlxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxzZTogdGhpcyBpcyBhIGxleGVyIHJ1bGUgd2hpY2ggY29uc3VtZXMgaW5wdXQgd2l0aG91dCBwcm9kdWNpbmcgYSB0b2tlbiAoZS5nLiB3aGl0ZXNwYWNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5vcHRpb25zLmZsZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRlc3RfbWF0Y2gobWF0Y2gsIHJ1bGVzW2luZGV4XSk7XG4gICAgICAgICAgICBpZiAodG9rZW4gIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZWxzZTogdGhpcyBpcyBhIGxleGVyIHJ1bGUgd2hpY2ggY29uc3VtZXMgaW5wdXQgd2l0aG91dCBwcm9kdWNpbmcgYSB0b2tlbiAoZS5nLiB3aGl0ZXNwYWNlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pbnB1dCA9PT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuRU9GO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFcnJvcignTGV4aWNhbCBlcnJvciBvbiBsaW5lICcgKyAodGhpcy55eWxpbmVubyArIDEpICsgJy4gVW5yZWNvZ25pemVkIHRleHQuXFxuJyArIHRoaXMuc2hvd1Bvc2l0aW9uKCksIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgICAgICAgIHRva2VuOiBudWxsLFxuICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMueXlsaW5lbm9cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuLy8gcmV0dXJuIG5leHQgbWF0Y2ggdGhhdCBoYXMgYSB0b2tlblxubGV4OmZ1bmN0aW9uIGxleCgpIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLm5leHQoKTtcbiAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGV4KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4vLyBhY3RpdmF0ZXMgYSBuZXcgbGV4ZXIgY29uZGl0aW9uIHN0YXRlIChwdXNoZXMgdGhlIG5ldyBsZXhlciBjb25kaXRpb24gc3RhdGUgb250byB0aGUgY29uZGl0aW9uIHN0YWNrKVxuYmVnaW46ZnVuY3Rpb24gYmVnaW4oY29uZGl0aW9uKSB7XG4gICAgICAgIHRoaXMuY29uZGl0aW9uU3RhY2sucHVzaChjb25kaXRpb24pO1xuICAgIH0sXG5cbi8vIHBvcCB0aGUgcHJldmlvdXNseSBhY3RpdmUgbGV4ZXIgY29uZGl0aW9uIHN0YXRlIG9mZiB0aGUgY29uZGl0aW9uIHN0YWNrXG5wb3BTdGF0ZTpmdW5jdGlvbiBwb3BTdGF0ZSgpIHtcbiAgICAgICAgdmFyIG4gPSB0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChuID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uU3RhY2sucG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFja1swXTtcbiAgICAgICAgfVxuICAgIH0sXG5cbi8vIHByb2R1Y2UgdGhlIGxleGVyIHJ1bGUgc2V0IHdoaWNoIGlzIGFjdGl2ZSBmb3IgdGhlIGN1cnJlbnRseSBhY3RpdmUgbGV4ZXIgY29uZGl0aW9uIHN0YXRlXG5fY3VycmVudFJ1bGVzOmZ1bmN0aW9uIF9jdXJyZW50UnVsZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAmJiB0aGlzLmNvbmRpdGlvblN0YWNrW3RoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvbnNbdGhpcy5jb25kaXRpb25TdGFja1t0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDFdXS5ydWxlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvbnNbXCJJTklUSUFMXCJdLnJ1bGVzO1xuICAgICAgICB9XG4gICAgfSxcblxuLy8gcmV0dXJuIHRoZSBjdXJyZW50bHkgYWN0aXZlIGxleGVyIGNvbmRpdGlvbiBzdGF0ZTsgd2hlbiBhbiBpbmRleCBhcmd1bWVudCBpcyBwcm92aWRlZCBpdCBwcm9kdWNlcyB0aGUgTi10aCBwcmV2aW91cyBjb25kaXRpb24gc3RhdGUsIGlmIGF2YWlsYWJsZVxudG9wU3RhdGU6ZnVuY3Rpb24gdG9wU3RhdGUobikge1xuICAgICAgICBuID0gdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxIC0gTWF0aC5hYnMobiB8fCAwKTtcbiAgICAgICAgaWYgKG4gPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uU3RhY2tbbl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJJTklUSUFMXCI7XG4gICAgICAgIH1cbiAgICB9LFxuXG4vLyBhbGlhcyBmb3IgYmVnaW4oY29uZGl0aW9uKVxucHVzaFN0YXRlOmZ1bmN0aW9uIHB1c2hTdGF0ZShjb25kaXRpb24pIHtcbiAgICAgICAgdGhpcy5iZWdpbihjb25kaXRpb24pO1xuICAgIH0sXG5cbi8vIHJldHVybiB0aGUgbnVtYmVyIG9mIHN0YXRlcyBjdXJyZW50bHkgb24gdGhlIHN0YWNrXG5zdGF0ZVN0YWNrU2l6ZTpmdW5jdGlvbiBzdGF0ZVN0YWNrU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoO1xuICAgIH0sXG5vcHRpb25zOiB7fSxcbnBlcmZvcm1BY3Rpb246IGZ1bmN0aW9uIGFub255bW91cyh5eSx5eV8sJGF2b2lkaW5nX25hbWVfY29sbGlzaW9ucyxZWV9TVEFSVCkge1xudmFyIFlZU1RBVEU9WVlfU1RBUlQ7XG5zd2l0Y2goJGF2b2lkaW5nX25hbWVfY29sbGlzaW9ucykge1xuY2FzZSAwOi8qIHNraXAgd2hpdGVzcGFjZSAqL1xuYnJlYWs7XG5jYXNlIDE6cmV0dXJuIDZcbmJyZWFrO1xuY2FzZSAyOnl5Xy55eXRleHQgPSB5eV8ueXl0ZXh0LnN1YnN0cigxLHl5Xy55eWxlbmctMik7IHJldHVybiA0XG5icmVhaztcbmNhc2UgMzpyZXR1cm4gMTdcbmJyZWFrO1xuY2FzZSA0OnJldHVybiAxOFxuYnJlYWs7XG5jYXNlIDU6cmV0dXJuIDIzXG5icmVhaztcbmNhc2UgNjpyZXR1cm4gMjRcbmJyZWFrO1xuY2FzZSA3OnJldHVybiAyMlxuYnJlYWs7XG5jYXNlIDg6cmV0dXJuIDIxXG5icmVhaztcbmNhc2UgOTpyZXR1cm4gMTBcbmJyZWFrO1xuY2FzZSAxMDpyZXR1cm4gMTFcbmJyZWFrO1xuY2FzZSAxMTpyZXR1cm4gOFxuYnJlYWs7XG5jYXNlIDEyOnJldHVybiAxNFxuYnJlYWs7XG5jYXNlIDEzOnJldHVybiAnSU5WQUxJRCdcbmJyZWFrO1xufVxufSxcbnJ1bGVzOiBbL14oPzpcXHMrKS8sL14oPzooLT8oWzAtOV18WzEtOV1bMC05XSspKShcXC5bMC05XSspPyhbZUVdWy0rXT9bMC05XSspP1xcYikvLC9eKD86XCIoPzpcXFxcW1xcXFxcImJmbnJ0L118XFxcXHVbYS1mQS1GMC05XXs0fXxbXlxcXFxcXDAtXFx4MDlcXHgwYS1cXHgxZlwiXSkqXCIpLywvXig/OlxceykvLC9eKD86XFx9KS8sL14oPzpcXFspLywvXig/OlxcXSkvLC9eKD86LCkvLC9eKD86OikvLC9eKD86dHJ1ZVxcYikvLC9eKD86ZmFsc2VcXGIpLywvXig/Om51bGxcXGIpLywvXig/OiQpLywvXig/Oi4pL10sXG5jb25kaXRpb25zOiB7XCJJTklUSUFMXCI6e1wicnVsZXNcIjpbMCwxLDIsMyw0LDUsNiw3LDgsOSwxMCwxMSwxMiwxM10sXCJpbmNsdXNpdmVcIjp0cnVlfX1cbn0pO1xucmV0dXJuIGxleGVyO1xufSkoKTtcbnBhcnNlci5sZXhlciA9IGxleGVyO1xuZnVuY3Rpb24gUGFyc2VyICgpIHtcbiAgdGhpcy55eSA9IHt9O1xufVxuUGFyc2VyLnByb3RvdHlwZSA9IHBhcnNlcjtwYXJzZXIuUGFyc2VyID0gUGFyc2VyO1xucmV0dXJuIG5ldyBQYXJzZXI7XG59KSgpO1xuXG5cbmlmICh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG5leHBvcnRzLnBhcnNlciA9IHBhcnNlcjtcbmV4cG9ydHMuUGFyc2VyID0gcGFyc2VyLlBhcnNlcjtcbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBwYXJzZXIucGFyc2UuYXBwbHkocGFyc2VyLCBhcmd1bWVudHMpOyB9O1xuZXhwb3J0cy5tYWluID0gZnVuY3Rpb24gY29tbW9uanNNYWluKGFyZ3MpIHtcbiAgICBpZiAoIWFyZ3NbMV0pIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1VzYWdlOiAnK2FyZ3NbMF0rJyBGSUxFJyk7XG4gICAgICAgIHByb2Nlc3MuZXhpdCgxKTtcbiAgICB9XG4gICAgdmFyIHNvdXJjZSA9IHJlcXVpcmUoJ2ZzJykucmVhZEZpbGVTeW5jKHJlcXVpcmUoJ3BhdGgnKS5ub3JtYWxpemUoYXJnc1sxXSksIFwidXRmOFwiKTtcbiAgICByZXR1cm4gZXhwb3J0cy5wYXJzZXIucGFyc2Uoc291cmNlKTtcbn07XG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgcmVxdWlyZS5tYWluID09PSBtb2R1bGUpIHtcbiAgZXhwb3J0cy5tYWluKHByb2Nlc3MuYXJndi5zbGljZSgxKSk7XG59XG59IiwiLyoqXG4gKiBsb2Rhc2ggMy4wLjcgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnbG9kYXNoLmlzYXJyYXknKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCdsb2Rhc2guaXN0eXBlZGFycmF5JyksXG4gICAga2V5cyA9IHJlcXVpcmUoJ2xvZGFzaC5rZXlzJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZSBbYHRvU3RyaW5nVGFnYF0oaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmpUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYHRoaXNgIGJpbmRpbmdcbiAqIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaW5nIHZhbHVlcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzTG9vc2VdIFNwZWNpZnkgcGVyZm9ybWluZyBwYXJ0aWFsIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQV0gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIG9iamVjdHMuXG4gKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tCXSBUcmFja3MgdHJhdmVyc2VkIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgY3VzdG9taXplciwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpIHtcbiAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdCh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gIH1cbiAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJhc2VJc0VxdWFsLCBjdXN0b21pemVyLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQik7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaW5nIG9iamVjdHMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0xvb3NlXSBTcGVjaWZ5IHBlcmZvcm1pbmcgcGFydGlhbCBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0E9W11dIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBvYmplY3RzLlxuICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQj1bXV0gVHJhY2tzIHRyYXZlcnNlZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpIHtcbiAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcbiAgICAgIG9ialRhZyA9IGFycmF5VGFnLFxuICAgICAgb3RoVGFnID0gYXJyYXlUYWc7XG5cbiAgaWYgKCFvYmpJc0Fycikge1xuICAgIG9ialRhZyA9IG9ialRvU3RyaW5nLmNhbGwob2JqZWN0KTtcbiAgICBpZiAob2JqVGFnID09IGFyZ3NUYWcpIHtcbiAgICAgIG9ialRhZyA9IG9iamVjdFRhZztcbiAgICB9IGVsc2UgaWYgKG9ialRhZyAhPSBvYmplY3RUYWcpIHtcbiAgICAgIG9iaklzQXJyID0gaXNUeXBlZEFycmF5KG9iamVjdCk7XG4gICAgfVxuICB9XG4gIGlmICghb3RoSXNBcnIpIHtcbiAgICBvdGhUYWcgPSBvYmpUb1N0cmluZy5jYWxsKG90aGVyKTtcbiAgICBpZiAob3RoVGFnID09IGFyZ3NUYWcpIHtcbiAgICAgIG90aFRhZyA9IG9iamVjdFRhZztcbiAgICB9IGVsc2UgaWYgKG90aFRhZyAhPSBvYmplY3RUYWcpIHtcbiAgICAgIG90aElzQXJyID0gaXNUeXBlZEFycmF5KG90aGVyKTtcbiAgICB9XG4gIH1cbiAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyxcbiAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyxcbiAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgaWYgKGlzU2FtZVRhZyAmJiAhKG9iaklzQXJyIHx8IG9iaklzT2JqKSkge1xuICAgIHJldHVybiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZyk7XG4gIH1cbiAgaWYgKCFpc0xvb3NlKSB7XG4gICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCwgb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyLCBjdXN0b21pemVyLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQik7XG4gICAgfVxuICB9XG4gIGlmICghaXNTYW1lVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgLy8gRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gZGV0ZWN0aW5nIGNpcmN1bGFyIHJlZmVyZW5jZXMgc2VlIGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jSk8uXG4gIHN0YWNrQSB8fCAoc3RhY2tBID0gW10pO1xuICBzdGFja0IgfHwgKHN0YWNrQiA9IFtdKTtcblxuICB2YXIgbGVuZ3RoID0gc3RhY2tBLmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKHN0YWNrQVtsZW5ndGhdID09IG9iamVjdCkge1xuICAgICAgcmV0dXJuIHN0YWNrQltsZW5ndGhdID09IG90aGVyO1xuICAgIH1cbiAgfVxuICAvLyBBZGQgYG9iamVjdGAgYW5kIGBvdGhlcmAgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICBzdGFja0EucHVzaChvYmplY3QpO1xuICBzdGFja0IucHVzaChvdGhlcik7XG5cbiAgdmFyIHJlc3VsdCA9IChvYmpJc0FyciA/IGVxdWFsQXJyYXlzIDogZXF1YWxPYmplY3RzKShvYmplY3QsIG90aGVyLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKTtcblxuICBzdGFja0EucG9wKCk7XG4gIHN0YWNrQi5wb3AoKTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmluZyBhcnJheXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0xvb3NlXSBTcGVjaWZ5IHBlcmZvcm1pbmcgcGFydGlhbCBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0FdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBvYmplY3RzLlxuICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQl0gVHJhY2tzIHRyYXZlcnNlZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFycmF5cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEFycmF5cyhhcnJheSwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc0xvb3NlICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF0sXG4gICAgICAgIHJlc3VsdCA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKGlzTG9vc2UgPyBvdGhWYWx1ZSA6IGFyclZhbHVlLCBpc0xvb3NlID8gYXJyVmFsdWUgOiBvdGhWYWx1ZSwgaW5kZXgpIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmIChpc0xvb3NlKSB7XG4gICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgY3VzdG9taXplciwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGN1c3RvbWl6ZXIsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcpIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgICAgLy8gQ29lcmNlIGRhdGVzIGFuZCBib29sZWFucyB0byBudW1iZXJzLCBkYXRlcyB0byBtaWxsaXNlY29uZHMgYW5kIGJvb2xlYW5zXG4gICAgICAvLyB0byBgMWAgb3IgYDBgIHRyZWF0aW5nIGludmFsaWQgZGF0ZXMgY29lcmNlZCB0byBgTmFOYCBhcyBub3QgZXF1YWwuXG4gICAgICByZXR1cm4gK29iamVjdCA9PSArb3RoZXI7XG5cbiAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcblxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgLy8gVHJlYXQgYE5hTmAgdnMuIGBOYU5gIGFzIGVxdWFsLlxuICAgICAgcmV0dXJuIChvYmplY3QgIT0gK29iamVjdClcbiAgICAgICAgPyBvdGhlciAhPSArb3RoZXJcbiAgICAgICAgOiBvYmplY3QgPT0gK290aGVyO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzIHByaW1pdGl2ZXMgYW5kIHN0cmluZ1xuICAgICAgLy8gb2JqZWN0cyBhcyBlcXVhbC4gU2VlIGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEwLjYuNCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmluZyB2YWx1ZXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0xvb3NlXSBTcGVjaWZ5IHBlcmZvcm1pbmcgcGFydGlhbCBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0FdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBvYmplY3RzLlxuICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQl0gVHJhY2tzIHRyYXZlcnNlZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpIHtcbiAgdmFyIG9ialByb3BzID0ga2V5cyhvYmplY3QpLFxuICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgb3RoUHJvcHMgPSBrZXlzKG90aGVyKSxcbiAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNMb29zZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICBpZiAoIShpc0xvb3NlID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgdmFyIHNraXBDdG9yID0gaXNMb29zZTtcbiAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XSxcbiAgICAgICAgcmVzdWx0ID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIoaXNMb29zZSA/IG90aFZhbHVlIDogb2JqVmFsdWUsIGlzTG9vc2U/IG9ialZhbHVlIDogb3RoVmFsdWUsIGtleSkgOiB1bmRlZmluZWQ7XG5cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZCA/IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGN1c3RvbWl6ZXIsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKSA6IHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICB9XG4gIGlmICghc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlIFtsYW5ndWFnZSB0eXBlXShodHRwczovL2VzNS5naXRodWIuaW8vI3g4KSBvZiBgT2JqZWN0YC5cbiAqIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoMSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAvLyBBdm9pZCBhIFY4IEpJVCBidWcgaW4gQ2hyb21lIDE5LTIwLlxuICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIyOTEgZm9yIG1vcmUgZGV0YWlscy5cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzRXF1YWw7XG4iLCIvKipcbiAqIGxvZGFzaCAzLjAuMSAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUNhbGxiYWNrYCB3aGljaCBvbmx5IHN1cHBvcnRzIGB0aGlzYCBiaW5kaW5nXG4gKiBhbmQgc3BlY2lmeWluZyB0aGUgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBwcm92aWRlIHRvIGBmdW5jYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYmluZC5cbiAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtudW1iZXJ9IFthcmdDb3VudF0gVGhlIG51bWJlciBvZiBhcmd1bWVudHMgdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNhbGxiYWNrLlxuICovXG5mdW5jdGlvbiBiaW5kQ2FsbGJhY2soZnVuYywgdGhpc0FyZywgYXJnQ291bnQpIHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gaWRlbnRpdHk7XG4gIH1cbiAgaWYgKHRoaXNBcmcgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBmdW5jO1xuICB9XG4gIHN3aXRjaCAoYXJnQ291bnQpIHtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCB2YWx1ZSk7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICB9O1xuICAgIGNhc2UgNDogcmV0dXJuIGZ1bmN0aW9uKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgfTtcbiAgICBjYXNlIDU6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIsIGtleSwgb2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgdmFsdWUsIG90aGVyLCBrZXksIG9iamVjdCwgc291cmNlKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IHByb3ZpZGVkIHRvIGl0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJyB9O1xuICpcbiAqIF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0O1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmluZENhbGxiYWNrO1xuIiwiLyoqXG4gKiBsb2Rhc2ggMy45LjEgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSA+IDUpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmblRvU3RyaW5nID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmpUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZm5Ub1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZywgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIHJldHVybiBpc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gb2xkZXIgdmVyc2lvbnMgb2YgQ2hyb21lIGFuZCBTYWZhcmkgd2hpY2ggcmV0dXJuICdmdW5jdGlvbicgZm9yIHJlZ2V4ZXNcbiAgLy8gYW5kIFNhZmFyaSA4IGVxdWl2YWxlbnRzIHdoaWNoIHJldHVybiAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXkgY29uc3RydWN0b3JzLlxuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IGZ1bmNUYWc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlIFtsYW5ndWFnZSB0eXBlXShodHRwczovL2VzNS5naXRodWIuaW8vI3g4KSBvZiBgT2JqZWN0YC5cbiAqIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoMSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAvLyBBdm9pZCBhIFY4IEpJVCBidWcgaW4gQ2hyb21lIDE5LTIwLlxuICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIyOTEgZm9yIG1vcmUgZGV0YWlscy5cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24uXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNOYXRpdmUoQXJyYXkucHJvdG90eXBlLnB1c2gpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNOYXRpdmUoXyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICByZXR1cm4gcmVJc05hdGl2ZS50ZXN0KGZuVG9TdHJpbmcuY2FsbCh2YWx1ZSkpO1xuICB9XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIHJlSXNIb3N0Q3Rvci50ZXN0KHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXROYXRpdmU7XG4iLCIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIC8vIFNhZmFyaSA4LjEgbWFrZXMgYGFyZ3VtZW50cy5jYWxsZWVgIGVudW1lcmFibGUgaW4gc3RyaWN0IG1vZGUuXG4gIHJldHVybiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgKCFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgfHwgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYXJnc1RhZyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAqIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOC05IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5IGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBpc09iamVjdCh2YWx1ZSkgPyBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FyZ3VtZW50cztcbiIsIi8qKlxuICogbG9kYXNoIDMuMC40IChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpID4gNSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZuVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZSBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9ialRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmblRvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UoL1tcXFxcXiQuKis/KClbXFxde318XS9nLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKiBOYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQXJyYXkgPSBnZXROYXRpdmUoQXJyYXksICdpc0FycmF5Jyk7XG5cbi8qKlxuICogVXNlZCBhcyB0aGUgW21heGltdW0gbGVuZ3RoXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1udW1iZXIubWF4X3NhZmVfaW50ZWdlcilcbiAqIG9mIGFuIGFycmF5LWxpa2UgdmFsdWUuXG4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIHJldHVybiBpc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIGJhc2VkIG9uIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBuYXRpdmVJc0FycmF5IHx8IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYXJyYXlUYWc7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBvbGRlciB2ZXJzaW9ucyBvZiBDaHJvbWUgYW5kIFNhZmFyaSB3aGljaCByZXR1cm4gJ2Z1bmN0aW9uJyBmb3IgcmVnZXhlc1xuICAvLyBhbmQgU2FmYXJpIDggZXF1aXZhbGVudHMgd2hpY2ggcmV0dXJuICdvYmplY3QnIGZvciB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvcnMuXG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gZnVuY1RhZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGUgW2xhbmd1YWdlIHR5cGVdKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDgpIG9mIGBPYmplY3RgLlxuICogKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdCgxKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIC8vIEF2b2lkIGEgVjggSklUIGJ1ZyBpbiBDaHJvbWUgMTktMjAuXG4gIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MSBmb3IgbW9yZSBkZXRhaWxzLlxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc05hdGl2ZShBcnJheS5wcm90b3R5cGUucHVzaCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc05hdGl2ZShfKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHJldHVybiByZUlzTmF0aXZlLnRlc3QoZm5Ub1N0cmluZy5jYWxsKHZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgcmVJc0hvc3RDdG9yLnRlc3QodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXk7XG4iLCIvKipcbiAqIGxvZGFzaCAzLjAuNCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xudmFyIGJhc2VJc0VxdWFsID0gcmVxdWlyZSgnbG9kYXNoLl9iYXNlaXNlcXVhbCcpLFxuICAgIGJpbmRDYWxsYmFjayA9IHJlcXVpcmUoJ2xvZGFzaC5fYmluZGNhbGxiYWNrJyk7XG5cbi8qKlxuICogUGVyZm9ybXMgYSBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZVxuICogZXF1aXZhbGVudC4gSWYgYGN1c3RvbWl6ZXJgIGlzIHByb3ZpZGVkIGl0IGlzIGludm9rZWQgdG8gY29tcGFyZSB2YWx1ZXMuXG4gKiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCBjb21wYXJpc29ucyBhcmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kXG4gKiBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG4gKiBhcmd1bWVudHM6ICh2YWx1ZSwgb3RoZXIgWywgaW5kZXh8a2V5XSkuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIGNvbXBhcmluZyBhcnJheXMsIGJvb2xlYW5zLCBgRGF0ZWAgb2JqZWN0cyxcbiAqIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsIGFuZCBzdHJpbmdzLiBPYmplY3RzIGFyZSBjb21wYXJlZCBieVxuICogdGhlaXIgb3duLCBub3QgaW5oZXJpdGVkLCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuIEZ1bmN0aW9ucyBhbmQgRE9NIG5vZGVzXG4gKiBhcmUgKipub3QqKiBzdXBwb3J0ZWQuIFByb3ZpZGUgYSBjdXN0b21pemVyIGZ1bmN0aW9uIHRvIGV4dGVuZCBzdXBwb3J0XG4gKiBmb3IgY29tcGFyaW5nIG90aGVyIHZhbHVlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGFsaWFzIGVxXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSB2YWx1ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY3VzdG9taXplcmAuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJyB9O1xuICogdmFyIG90aGVyID0geyAndXNlcic6ICdmcmVkJyB9O1xuICpcbiAqIG9iamVjdCA9PSBvdGhlcjtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0VxdWFsKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIC8vIHVzaW5nIGEgY3VzdG9taXplciBjYWxsYmFja1xuICogdmFyIGFycmF5ID0gWydoZWxsbycsICdnb29kYnllJ107XG4gKiB2YXIgb3RoZXIgPSBbJ2hpJywgJ2dvb2RieWUnXTtcbiAqXG4gKiBfLmlzRXF1YWwoYXJyYXksIG90aGVyLCBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAqICAgaWYgKF8uZXZlcnkoW3ZhbHVlLCBvdGhlcl0sIFJlZ0V4cC5wcm90b3R5cGUudGVzdCwgL15oKD86aXxlbGxvKSQvKSkge1xuICogICAgIHJldHVybiB0cnVlO1xuICogICB9XG4gKiB9KTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGN1c3RvbWl6ZXIsIHRoaXNBcmcpIHtcbiAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBiaW5kQ2FsbGJhY2soY3VzdG9taXplciwgdGhpc0FyZywgMykgOiB1bmRlZmluZWQ7XG4gIHZhciByZXN1bHQgPSBjdXN0b21pemVyID8gY3VzdG9taXplcih2YWx1ZSwgb3RoZXIpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBjdXN0b21pemVyKSA6ICEhcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRXF1YWw7XG4iLCIvKipcbiAqIGxvZGFzaCAzLjAuNiAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3Nbb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVHlwZWRBcnJheTtcbiIsIi8qKlxuICogbG9kYXNoIDMuMS4yIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG52YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnbG9kYXNoLl9nZXRuYXRpdmUnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJ2xvZGFzaC5pc2FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCdsb2Rhc2guaXNhcnJheScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXlxcZCskLztcblxuLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IGdldE5hdGl2ZShPYmplY3QsICdrZXlzJyk7XG5cbi8qKlxuICogVXNlZCBhcyB0aGUgW21heGltdW0gbGVuZ3RoXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1udW1iZXIubWF4X3NhZmVfaW50ZWdlcilcbiAqIG9mIGFuIGFycmF5LWxpa2UgdmFsdWUuXG4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IHZhbHVlIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gYXZvaWQgYSBbSklUIGJ1Z10oaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE0Mjc5MilcbiAqIHRoYXQgYWZmZWN0cyBTYWZhcmkgb24gYXQgbGVhc3QgaU9TIDguMS04LjMgQVJNNjQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBcImxlbmd0aFwiIHZhbHVlLlxuICovXG52YXIgZ2V0TGVuZ3RoID0gYmFzZVByb3BlcnR5KCdsZW5ndGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgoZ2V0TGVuZ3RoKHZhbHVlKSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhbHVlID0gKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCByZUlzVWludC50ZXN0KHZhbHVlKSkgPyArdmFsdWUgOiAtMTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIGJhc2VkIG9uIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQSBmYWxsYmFjayBpbXBsZW1lbnRhdGlvbiBvZiBgT2JqZWN0LmtleXNgIHdoaWNoIGNyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlXG4gKiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gc2hpbUtleXMob2JqZWN0KSB7XG4gIHZhciBwcm9wcyA9IGtleXNJbihvYmplY3QpLFxuICAgICAgcHJvcHNMZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICBsZW5ndGggPSBwcm9wc0xlbmd0aCAmJiBvYmplY3QubGVuZ3RoO1xuXG4gIHZhciBhbGxvd0luZGV4ZXMgPSAhIWxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmXG4gICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgcHJvcHNMZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgIGlmICgoYWxsb3dJbmRleGVzICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpKSB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGUgW2xhbmd1YWdlIHR5cGVdKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDgpIG9mIGBPYmplY3RgLlxuICogKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdCgxKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIC8vIEF2b2lkIGEgVjggSklUIGJ1ZyBpbiBDaHJvbWUgMTktMjAuXG4gIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MSBmb3IgbW9yZSBkZXRhaWxzLlxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xudmFyIGtleXMgPSAhbmF0aXZlS2V5cyA/IHNoaW1LZXlzIDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIHZhciBDdG9yID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3QuY29uc3RydWN0b3I7XG4gIGlmICgodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSA9PT0gb2JqZWN0KSB8fFxuICAgICAgKHR5cGVvZiBvYmplY3QgIT0gJ2Z1bmN0aW9uJyAmJiBpc0FycmF5TGlrZShvYmplY3QpKSkge1xuICAgIHJldHVybiBzaGltS2V5cyhvYmplY3QpO1xuICB9XG4gIHJldHVybiBpc09iamVjdChvYmplY3QpID8gbmF0aXZlS2V5cyhvYmplY3QpIDogW107XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICB9XG4gIHZhciBsZW5ndGggPSBvYmplY3QubGVuZ3RoO1xuICBsZW5ndGggPSAobGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpICYmIGxlbmd0aCkgfHwgMDtcblxuICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgIGluZGV4ID0gLTEsXG4gICAgICBpc1Byb3RvID0gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSA9PT0gb2JqZWN0LFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgIHNraXBJbmRleGVzID0gbGVuZ3RoID4gMDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSAoaW5kZXggKyAnJyk7XG4gIH1cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKHNraXBJbmRleGVzICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpKSAmJlxuICAgICAgICAhKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXM7XG4iLCJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgY29uc3Qgc3R5bGVJRHMgPSBbXTtcbiAgICBjb25zdCBzb3VyY2VJRHMgPSBbXTtcbiAgICBjb25zdCBjb21wb3NpdGVkU291cmNlTGF5ZXJzID0gW107XG5cbiAgICBmb3IgKGNvbnN0IGlkIGluIHN0eWxlLnNvdXJjZXMpIHtcbiAgICAgICAgY29uc3Qgc291cmNlID0gc3R5bGUuc291cmNlc1tpZF07XG5cbiAgICAgICAgaWYgKHNvdXJjZS50eXBlICE9PSBcInZlY3RvclwiKVxuICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgY29uc3QgbWF0Y2ggPSAvXm1hcGJveDpcXC9cXC8oLiopLy5leGVjKHNvdXJjZS51cmwpO1xuICAgICAgICBpZiAoIW1hdGNoKVxuICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgc3R5bGVJRHMucHVzaChpZCk7XG4gICAgICAgIHNvdXJjZUlEcy5wdXNoKG1hdGNoWzFdKTtcbiAgICB9XG5cbiAgICBpZiAoc3R5bGVJRHMubGVuZ3RoIDwgMilcbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuXG4gICAgc3R5bGVJRHMuZm9yRWFjaCgoaWQpID0+IHtcbiAgICAgICAgZGVsZXRlIHN0eWxlLnNvdXJjZXNbaWRdO1xuICAgIH0pO1xuXG4gICAgY29uc3QgY29tcG9zaXRlSUQgPSBzb3VyY2VJRHMuam9pbihcIixcIik7XG5cbiAgICBzdHlsZS5zb3VyY2VzW2NvbXBvc2l0ZUlEXSA9IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwidmVjdG9yXCIsXG4gICAgICAgIFwidXJsXCI6IGBtYXBib3g6Ly8ke2NvbXBvc2l0ZUlEfWBcbiAgICB9O1xuXG4gICAgc3R5bGUubGF5ZXJzLmZvckVhY2goKGxheWVyKSA9PiB7XG4gICAgICAgIGlmIChzdHlsZUlEcy5pbmRleE9mKGxheWVyLnNvdXJjZSkgPj0gMCkge1xuICAgICAgICAgICAgbGF5ZXIuc291cmNlID0gY29tcG9zaXRlSUQ7XG5cbiAgICAgICAgICAgIGlmICgnc291cmNlLWxheWVyJyBpbiBsYXllcikge1xuICAgICAgICAgICAgICAgIGlmIChjb21wb3NpdGVkU291cmNlTGF5ZXJzLmluZGV4T2YobGF5ZXJbJ3NvdXJjZS1sYXllciddKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29uZmxpY3Rpbmcgc291cmNlIGxheWVyIG5hbWVzJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9zaXRlZFNvdXJjZUxheWVycy5wdXNoKGxheWVyWydzb3VyY2UtbGF5ZXInXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc3R5bGU7XG59O1xuIiwiXG5jb25zdCBpc0VxdWFsID0gcmVxdWlyZSgnbG9kYXNoLmlzZXF1YWwnKTtcblxuY29uc3Qgb3BlcmF0aW9ucyA9IHtcblxuICAgIC8qXG4gICAgICogeyBjb21tYW5kOiAnc2V0U3R5bGUnLCBhcmdzOiBbc3R5bGVzaGVldF0gfVxuICAgICAqL1xuICAgIHNldFN0eWxlOiAnc2V0U3R5bGUnLFxuXG4gICAgLypcbiAgICAgKiB7IGNvbW1hbmQ6ICdhZGRMYXllcicsIGFyZ3M6IFtsYXllciwgJ2JlZm9yZUxheWVySWQnXSB9XG4gICAgICovXG4gICAgYWRkTGF5ZXI6ICdhZGRMYXllcicsXG5cbiAgICAvKlxuICAgICAqIHsgY29tbWFuZDogJ3JlbW92ZUxheWVyJywgYXJnczogWydsYXllcklkJ10gfVxuICAgICAqL1xuICAgIHJlbW92ZUxheWVyOiAncmVtb3ZlTGF5ZXInLFxuXG4gICAgLypcbiAgICAgKiB7IGNvbW1hbmQ6ICdzZXRQYWludFByb3BlcnR5JywgYXJnczogWydsYXllcklkJywgJ3Byb3AnLCB2YWx1ZV0gfVxuICAgICAqL1xuICAgIHNldFBhaW50UHJvcGVydHk6ICdzZXRQYWludFByb3BlcnR5JyxcblxuICAgIC8qXG4gICAgICogeyBjb21tYW5kOiAnc2V0TGF5b3V0UHJvcGVydHknLCBhcmdzOiBbJ2xheWVySWQnLCAncHJvcCcsIHZhbHVlXSB9XG4gICAgICovXG4gICAgc2V0TGF5b3V0UHJvcGVydHk6ICdzZXRMYXlvdXRQcm9wZXJ0eScsXG5cbiAgICAvKlxuICAgICAqIHsgY29tbWFuZDogJ3NldEZpbHRlcicsIGFyZ3M6IFsnbGF5ZXJJZCcsIGZpbHRlcl0gfVxuICAgICAqL1xuICAgIHNldEZpbHRlcjogJ3NldEZpbHRlcicsXG5cbiAgICAvKlxuICAgICAqIHsgY29tbWFuZDogJ2FkZFNvdXJjZScsIGFyZ3M6IFsnc291cmNlSWQnLCBzb3VyY2VdIH1cbiAgICAgKi9cbiAgICBhZGRTb3VyY2U6ICdhZGRTb3VyY2UnLFxuXG4gICAgLypcbiAgICAgKiB7IGNvbW1hbmQ6ICdyZW1vdmVTb3VyY2UnLCBhcmdzOiBbJ3NvdXJjZUlkJ10gfVxuICAgICAqL1xuICAgIHJlbW92ZVNvdXJjZTogJ3JlbW92ZVNvdXJjZScsXG5cbiAgICAvKlxuICAgICAqIHsgY29tbWFuZDogJ3NldEdlb0pTT05Tb3VyY2VEYXRhJywgYXJnczogWydzb3VyY2VJZCcsIGRhdGFdIH1cbiAgICAgKi9cbiAgICBzZXRHZW9KU09OU291cmNlRGF0YTogJ3NldEdlb0pTT05Tb3VyY2VEYXRhJyxcblxuICAgIC8qXG4gICAgICogeyBjb21tYW5kOiAnc2V0TGF5ZXJab29tUmFuZ2UnLCBhcmdzOiBbJ2xheWVySWQnLCAwLCAyMl0gfVxuICAgICAqL1xuICAgIHNldExheWVyWm9vbVJhbmdlOiAnc2V0TGF5ZXJab29tUmFuZ2UnLFxuXG4gICAgLypcbiAgICAgKiB7IGNvbW1hbmQ6ICdzZXRMYXllclByb3BlcnR5JywgYXJnczogWydsYXllcklkJywgJ3Byb3AnLCB2YWx1ZV0gfVxuICAgICAqL1xuICAgIHNldExheWVyUHJvcGVydHk6ICdzZXRMYXllclByb3BlcnR5JyxcblxuICAgIC8qXG4gICAgICogeyBjb21tYW5kOiAnc2V0Q2VudGVyJywgYXJnczogW1tsb24sIGxhdF1dIH1cbiAgICAgKi9cbiAgICBzZXRDZW50ZXI6ICdzZXRDZW50ZXInLFxuXG4gICAgLypcbiAgICAgKiB7IGNvbW1hbmQ6ICdzZXRab29tJywgYXJnczogW3pvb21dIH1cbiAgICAgKi9cbiAgICBzZXRab29tOiAnc2V0Wm9vbScsXG5cbiAgICAvKlxuICAgICAqIHsgY29tbWFuZDogJ3NldEJlYXJpbmcnLCBhcmdzOiBbYmVhcmluZ10gfVxuICAgICAqL1xuICAgIHNldEJlYXJpbmc6ICdzZXRCZWFyaW5nJyxcblxuICAgIC8qXG4gICAgICogeyBjb21tYW5kOiAnc2V0UGl0Y2gnLCBhcmdzOiBbcGl0Y2hdIH1cbiAgICAgKi9cbiAgICBzZXRQaXRjaDogJ3NldFBpdGNoJyxcblxuICAgIC8qXG4gICAgICogeyBjb21tYW5kOiAnc2V0U3ByaXRlJywgYXJnczogWydzcHJpdGVVcmwnXSB9XG4gICAgICovXG4gICAgc2V0U3ByaXRlOiAnc2V0U3ByaXRlJyxcblxuICAgIC8qXG4gICAgICogeyBjb21tYW5kOiAnc2V0R2x5cGhzJywgYXJnczogWydnbHlwaHNVcmwnXSB9XG4gICAgICovXG4gICAgc2V0R2x5cGhzOiAnc2V0R2x5cGhzJyxcblxuICAgIC8qXG4gICAgICogeyBjb21tYW5kOiAnc2V0VHJhbnNpdGlvbicsIGFyZ3M6IFt0cmFuc2l0aW9uXSB9XG4gICAgICovXG4gICAgc2V0VHJhbnNpdGlvbjogJ3NldFRyYW5zaXRpb24nLFxuXG4gICAgLypcbiAgICAgKiB7IGNvbW1hbmQ6ICdzZXRMaWdodGluZycsIGFyZ3M6IFtsaWdodFByb3BlcnRpZXNdIH1cbiAgICAgKi9cbiAgICBzZXRMaWdodDogJ3NldExpZ2h0J1xuXG59O1xuXG5cbmZ1bmN0aW9uIGRpZmZTb3VyY2VzKGJlZm9yZSwgYWZ0ZXIsIGNvbW1hbmRzLCBzb3VyY2VzUmVtb3ZlZCkge1xuICAgIGJlZm9yZSA9IGJlZm9yZSB8fCB7fTtcbiAgICBhZnRlciA9IGFmdGVyIHx8IHt9O1xuXG4gICAgbGV0IHNvdXJjZUlkO1xuXG4gICAgLy8gbG9vayBmb3Igc291cmNlcyB0byByZW1vdmVcbiAgICBmb3IgKHNvdXJjZUlkIGluIGJlZm9yZSkge1xuICAgICAgICBpZiAoIWJlZm9yZS5oYXNPd25Qcm9wZXJ0eShzb3VyY2VJZCkpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIWFmdGVyLmhhc093blByb3BlcnR5KHNvdXJjZUlkKSkge1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7IGNvbW1hbmQ6IG9wZXJhdGlvbnMucmVtb3ZlU291cmNlLCBhcmdzOiBbc291cmNlSWRdIH0pO1xuICAgICAgICAgICAgc291cmNlc1JlbW92ZWRbc291cmNlSWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGxvb2sgZm9yIHNvdXJjZXMgdG8gYWRkL3VwZGF0ZVxuICAgIGZvciAoc291cmNlSWQgaW4gYWZ0ZXIpIHtcbiAgICAgICAgaWYgKCFhZnRlci5oYXNPd25Qcm9wZXJ0eShzb3VyY2VJZCkpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIWJlZm9yZS5oYXNPd25Qcm9wZXJ0eShzb3VyY2VJZCkpIHtcbiAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goeyBjb21tYW5kOiBvcGVyYXRpb25zLmFkZFNvdXJjZSwgYXJnczogW3NvdXJjZUlkLCBhZnRlcltzb3VyY2VJZF1dIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKCFpc0VxdWFsKGJlZm9yZVtzb3VyY2VJZF0sIGFmdGVyW3NvdXJjZUlkXSkpIHtcbiAgICAgICAgICAgIGlmIChiZWZvcmVbc291cmNlSWRdLnR5cGUgPT09ICdnZW9qc29uJyAmJiBhZnRlcltzb3VyY2VJZF0udHlwZSA9PT0gJ2dlb2pzb24nKSB7XG4gICAgICAgICAgICAgICAgLy8gZ2VvanNvbiBzb3VyY2VzIHVzZSBzZXRHZW9KU09OU291cmNlRGF0YSBjb21tYW5kIHRvIHVwZGF0ZVxuICAgICAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goeyBjb21tYW5kOiBvcGVyYXRpb25zLnNldEdlb0pTT05Tb3VyY2VEYXRhLCBhcmdzOiBbc291cmNlSWQsIGFmdGVyW3NvdXJjZUlkXS5kYXRhXSB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbm8gdXBkYXRlIGNvbW1hbmQsIG11c3QgcmVtb3ZlIHRoZW4gYWRkXG4gICAgICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7IGNvbW1hbmQ6IG9wZXJhdGlvbnMucmVtb3ZlU291cmNlLCBhcmdzOiBbc291cmNlSWRdIH0pO1xuICAgICAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goeyBjb21tYW5kOiBvcGVyYXRpb25zLmFkZFNvdXJjZSwgYXJnczogW3NvdXJjZUlkLCBhZnRlcltzb3VyY2VJZF1dIH0pO1xuICAgICAgICAgICAgICAgIHNvdXJjZXNSZW1vdmVkW3NvdXJjZUlkXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRpZmZMYXllclByb3BlcnR5Q2hhbmdlcyhiZWZvcmUsIGFmdGVyLCBjb21tYW5kcywgbGF5ZXJJZCwga2xhc3MsIGNvbW1hbmQpIHtcbiAgICBiZWZvcmUgPSBiZWZvcmUgfHwge307XG4gICAgYWZ0ZXIgPSBhZnRlciB8fCB7fTtcblxuICAgIGxldCBwcm9wO1xuXG4gICAgZm9yIChwcm9wIGluIGJlZm9yZSkge1xuICAgICAgICBpZiAoIWJlZm9yZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgY29udGludWU7XG4gICAgICAgIGlmICghaXNFcXVhbChiZWZvcmVbcHJvcF0sIGFmdGVyW3Byb3BdKSkge1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7IGNvbW1hbmQ6IGNvbW1hbmQsIGFyZ3M6IFtsYXllcklkLCBwcm9wLCBhZnRlcltwcm9wXSwga2xhc3NdIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAocHJvcCBpbiBhZnRlcikge1xuICAgICAgICBpZiAoIWFmdGVyLmhhc093blByb3BlcnR5KHByb3ApIHx8IGJlZm9yZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgY29udGludWU7XG4gICAgICAgIGlmICghaXNFcXVhbChiZWZvcmVbcHJvcF0sIGFmdGVyW3Byb3BdKSkge1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7IGNvbW1hbmQ6IGNvbW1hbmQsIGFyZ3M6IFtsYXllcklkLCBwcm9wLCBhZnRlcltwcm9wXSwga2xhc3NdIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwbHVja0lkKGxheWVyKSB7XG4gICAgcmV0dXJuIGxheWVyLmlkO1xufVxuZnVuY3Rpb24gaW5kZXhCeUlkKGdyb3VwLCBsYXllcikge1xuICAgIGdyb3VwW2xheWVyLmlkXSA9IGxheWVyO1xuICAgIHJldHVybiBncm91cDtcbn1cblxuZnVuY3Rpb24gZGlmZkxheWVycyhiZWZvcmUsIGFmdGVyLCBjb21tYW5kcykge1xuICAgIGJlZm9yZSA9IGJlZm9yZSB8fCBbXTtcbiAgICBhZnRlciA9IGFmdGVyIHx8IFtdO1xuXG4gICAgLy8gb3JkZXIgb2YgbGF5ZXJzIGJ5IGlkXG4gICAgY29uc3QgYmVmb3JlT3JkZXIgPSBiZWZvcmUubWFwKHBsdWNrSWQpO1xuICAgIGNvbnN0IGFmdGVyT3JkZXIgPSBhZnRlci5tYXAocGx1Y2tJZCk7XG5cbiAgICAvLyBpbmRleCBvZiBsYXllciBieSBpZFxuICAgIGNvbnN0IGJlZm9yZUluZGV4ID0gYmVmb3JlLnJlZHVjZShpbmRleEJ5SWQsIHt9KTtcbiAgICBjb25zdCBhZnRlckluZGV4ID0gYWZ0ZXIucmVkdWNlKGluZGV4QnlJZCwge30pO1xuXG4gICAgLy8gdHJhY2sgb3JkZXIgb2YgbGF5ZXJzIGFzIGlmIHRoZXkgaGF2ZSBiZWVuIG11dGF0ZWRcbiAgICBjb25zdCB0cmFja2VyID0gYmVmb3JlT3JkZXIuc2xpY2UoKTtcblxuICAgIC8vIGxheWVycyB0aGF0IGhhdmUgYmVlbiBhZGRlZCBkbyBub3QgbmVlZCB0byBiZSBkaWZmZWRcbiAgICBjb25zdCBjbGVhbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICBsZXQgaSwgZCwgbGF5ZXJJZCwgYmVmb3JlTGF5ZXIsIGFmdGVyTGF5ZXIsIGluc2VydEJlZm9yZUxheWVySWQsIHByb3A7XG5cbiAgICAvLyByZW1vdmUgbGF5ZXJzXG4gICAgZm9yIChpID0gMCwgZCA9IDA7IGkgPCBiZWZvcmVPcmRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBsYXllcklkID0gYmVmb3JlT3JkZXJbaV07XG4gICAgICAgIGlmICghYWZ0ZXJJbmRleC5oYXNPd25Qcm9wZXJ0eShsYXllcklkKSkge1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7IGNvbW1hbmQ6IG9wZXJhdGlvbnMucmVtb3ZlTGF5ZXIsIGFyZ3M6IFtsYXllcklkXSB9KTtcbiAgICAgICAgICAgIHRyYWNrZXIuc3BsaWNlKHRyYWNrZXIuaW5kZXhPZihsYXllcklkLCBkKSwgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBsaW1pdCB3aGVyZSBpbiB0cmFja2VyIHdlIG5lZWQgdG8gbG9vayBmb3IgYSBtYXRjaFxuICAgICAgICAgICAgZCsrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRkL3Jlb3JkZXIgbGF5ZXJzXG4gICAgZm9yIChpID0gMCwgZCA9IDA7IGkgPCBhZnRlck9yZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIHdvcmsgYmFja3dhcmRzIGFzIGluc2VydCBpcyBiZWZvcmUgYW4gZXhpc3RpbmcgbGF5ZXJcbiAgICAgICAgbGF5ZXJJZCA9IGFmdGVyT3JkZXJbYWZ0ZXJPcmRlci5sZW5ndGggLSAxIC0gaV07XG5cbiAgICAgICAgaWYgKHRyYWNrZXJbdHJhY2tlci5sZW5ndGggLSAxIC0gaV0gPT09IGxheWVySWQpIGNvbnRpbnVlO1xuXG4gICAgICAgIGlmIChiZWZvcmVJbmRleC5oYXNPd25Qcm9wZXJ0eShsYXllcklkKSkge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBsYXllciBiZWZvcmUgd2UgaW5zZXJ0IGF0IHRoZSBjb3JyZWN0IHBvc2l0aW9uXG4gICAgICAgICAgICBjb21tYW5kcy5wdXNoKHsgY29tbWFuZDogb3BlcmF0aW9ucy5yZW1vdmVMYXllciwgYXJnczogW2xheWVySWRdIH0pO1xuICAgICAgICAgICAgdHJhY2tlci5zcGxpY2UodHJhY2tlci5sYXN0SW5kZXhPZihsYXllcklkLCB0cmFja2VyLmxlbmd0aCAtIGQpLCAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGxpbWl0IHdoZXJlIGluIHRyYWNrZXIgd2UgbmVlZCB0byBsb29rIGZvciBhIG1hdGNoXG4gICAgICAgICAgICBkKys7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgbGF5ZXIgYXQgY29ycmVjdCBwb3NpdGlvblxuICAgICAgICBpbnNlcnRCZWZvcmVMYXllcklkID0gdHJhY2tlclt0cmFja2VyLmxlbmd0aCAtIGldO1xuICAgICAgICBjb21tYW5kcy5wdXNoKHsgY29tbWFuZDogb3BlcmF0aW9ucy5hZGRMYXllciwgYXJnczogW2FmdGVySW5kZXhbbGF5ZXJJZF0sIGluc2VydEJlZm9yZUxheWVySWRdIH0pO1xuICAgICAgICB0cmFja2VyLnNwbGljZSh0cmFja2VyLmxlbmd0aCAtIGksIDAsIGxheWVySWQpO1xuICAgICAgICBjbGVhbltsYXllcklkXSA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGxheWVyc1xuICAgIGZvciAoaSA9IDA7IGkgPCBhZnRlck9yZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxheWVySWQgPSBhZnRlck9yZGVyW2ldO1xuICAgICAgICBiZWZvcmVMYXllciA9IGJlZm9yZUluZGV4W2xheWVySWRdO1xuICAgICAgICBhZnRlckxheWVyID0gYWZ0ZXJJbmRleFtsYXllcklkXTtcblxuICAgICAgICAvLyBubyBuZWVkIHRvIHVwZGF0ZSBpZiBwcmV2aW91c2x5IGFkZGVkIChuZXcgb3IgbW92ZWQpXG4gICAgICAgIGlmIChjbGVhbltsYXllcklkXSB8fCBpc0VxdWFsKGJlZm9yZUxheWVyLCBhZnRlckxheWVyKSkgY29udGludWU7XG5cbiAgICAgICAgLy8gSWYgc291cmNlLCBzb3VyY2UtbGF5ZXIsIG9yIHR5cGUgaGF2ZSBjaGFuZ2VzLCB0aGVuIHJlbW92ZSB0aGUgbGF5ZXJcbiAgICAgICAgLy8gYW5kIGFkZCBpdCBiYWNrICdmcm9tIHNjcmF0Y2gnLlxuICAgICAgICBpZiAoIWlzRXF1YWwoYmVmb3JlTGF5ZXIuc291cmNlLCBhZnRlckxheWVyLnNvdXJjZSkgfHwgIWlzRXF1YWwoYmVmb3JlTGF5ZXJbJ3NvdXJjZS1sYXllciddLCBhZnRlckxheWVyWydzb3VyY2UtbGF5ZXInXSkgfHwgIWlzRXF1YWwoYmVmb3JlTGF5ZXIudHlwZSwgYWZ0ZXJMYXllci50eXBlKSkge1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7IGNvbW1hbmQ6IG9wZXJhdGlvbnMucmVtb3ZlTGF5ZXIsIGFyZ3M6IFtsYXllcklkXSB9KTtcbiAgICAgICAgICAgIC8vIHdlIGFkZCB0aGUgbGF5ZXIgYmFjayBhdCB0aGUgc2FtZSBwb3NpdGlvbiBpdCB3YXMgYWxyZWFkeSBpbiwgc29cbiAgICAgICAgICAgIC8vIHRoZXJlJ3Mgbm8gbmVlZCB0byB1cGRhdGUgdGhlIGB0cmFja2VyYFxuICAgICAgICAgICAgaW5zZXJ0QmVmb3JlTGF5ZXJJZCA9IHRyYWNrZXJbdHJhY2tlci5sYXN0SW5kZXhPZihsYXllcklkKSArIDFdO1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7IGNvbW1hbmQ6IG9wZXJhdGlvbnMuYWRkTGF5ZXIsIGFyZ3M6IFthZnRlckxheWVyLCBpbnNlcnRCZWZvcmVMYXllcklkXSB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGF5b3V0LCBwYWludCwgZmlsdGVyLCBtaW56b29tLCBtYXh6b29tXG4gICAgICAgIGRpZmZMYXllclByb3BlcnR5Q2hhbmdlcyhiZWZvcmVMYXllci5sYXlvdXQsIGFmdGVyTGF5ZXIubGF5b3V0LCBjb21tYW5kcywgbGF5ZXJJZCwgbnVsbCwgb3BlcmF0aW9ucy5zZXRMYXlvdXRQcm9wZXJ0eSk7XG4gICAgICAgIGRpZmZMYXllclByb3BlcnR5Q2hhbmdlcyhiZWZvcmVMYXllci5wYWludCwgYWZ0ZXJMYXllci5wYWludCwgY29tbWFuZHMsIGxheWVySWQsIG51bGwsIG9wZXJhdGlvbnMuc2V0UGFpbnRQcm9wZXJ0eSk7XG4gICAgICAgIGlmICghaXNFcXVhbChiZWZvcmVMYXllci5maWx0ZXIsIGFmdGVyTGF5ZXIuZmlsdGVyKSkge1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7IGNvbW1hbmQ6IG9wZXJhdGlvbnMuc2V0RmlsdGVyLCBhcmdzOiBbbGF5ZXJJZCwgYWZ0ZXJMYXllci5maWx0ZXJdIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNFcXVhbChiZWZvcmVMYXllci5taW56b29tLCBhZnRlckxheWVyLm1pbnpvb20pIHx8ICFpc0VxdWFsKGJlZm9yZUxheWVyLm1heHpvb20sIGFmdGVyTGF5ZXIubWF4em9vbSkpIHtcbiAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goeyBjb21tYW5kOiBvcGVyYXRpb25zLnNldExheWVyWm9vbVJhbmdlLCBhcmdzOiBbbGF5ZXJJZCwgYWZ0ZXJMYXllci5taW56b29tLCBhZnRlckxheWVyLm1heHpvb21dIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGFuZGxlIGFsbCBvdGhlciBsYXllciBwcm9wcywgaW5jbHVkaW5nIHBhaW50LipcbiAgICAgICAgZm9yIChwcm9wIGluIGJlZm9yZUxheWVyKSB7XG4gICAgICAgICAgICBpZiAoIWJlZm9yZUxheWVyLmhhc093blByb3BlcnR5KHByb3ApKSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChwcm9wID09PSAnbGF5b3V0JyB8fCBwcm9wID09PSAncGFpbnQnIHx8IHByb3AgPT09ICdmaWx0ZXInIHx8XG4gICAgICAgICAgICAgICAgcHJvcCA9PT0gJ21ldGFkYXRhJyB8fCBwcm9wID09PSAnbWluem9vbScgfHwgcHJvcCA9PT0gJ21heHpvb20nKSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChwcm9wLmluZGV4T2YoJ3BhaW50LicpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZGlmZkxheWVyUHJvcGVydHlDaGFuZ2VzKGJlZm9yZUxheWVyW3Byb3BdLCBhZnRlckxheWVyW3Byb3BdLCBjb21tYW5kcywgbGF5ZXJJZCwgcHJvcC5zbGljZSg2KSwgb3BlcmF0aW9ucy5zZXRQYWludFByb3BlcnR5KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlzRXF1YWwoYmVmb3JlTGF5ZXJbcHJvcF0sIGFmdGVyTGF5ZXJbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7IGNvbW1hbmQ6IG9wZXJhdGlvbnMuc2V0TGF5ZXJQcm9wZXJ0eSwgYXJnczogW2xheWVySWQsIHByb3AsIGFmdGVyTGF5ZXJbcHJvcF1dIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAocHJvcCBpbiBhZnRlckxheWVyKSB7XG4gICAgICAgICAgICBpZiAoIWFmdGVyTGF5ZXIuaGFzT3duUHJvcGVydHkocHJvcCkgfHwgYmVmb3JlTGF5ZXIuaGFzT3duUHJvcGVydHkocHJvcCkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHByb3AgPT09ICdsYXlvdXQnIHx8IHByb3AgPT09ICdwYWludCcgfHwgcHJvcCA9PT0gJ2ZpbHRlcicgfHxcbiAgICAgICAgICAgICAgICBwcm9wID09PSAnbWV0YWRhdGEnIHx8IHByb3AgPT09ICdtaW56b29tJyB8fCBwcm9wID09PSAnbWF4em9vbScpIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHByb3AuaW5kZXhPZigncGFpbnQuJykgPT09IDApIHtcbiAgICAgICAgICAgICAgICBkaWZmTGF5ZXJQcm9wZXJ0eUNoYW5nZXMoYmVmb3JlTGF5ZXJbcHJvcF0sIGFmdGVyTGF5ZXJbcHJvcF0sIGNvbW1hbmRzLCBsYXllcklkLCBwcm9wLnNsaWNlKDYpLCBvcGVyYXRpb25zLnNldFBhaW50UHJvcGVydHkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghaXNFcXVhbChiZWZvcmVMYXllcltwcm9wXSwgYWZ0ZXJMYXllcltwcm9wXSkpIHtcbiAgICAgICAgICAgICAgICBjb21tYW5kcy5wdXNoKHsgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRMYXllclByb3BlcnR5LCBhcmdzOiBbbGF5ZXJJZCwgcHJvcCwgYWZ0ZXJMYXllcltwcm9wXV0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogRGlmZiB0d28gc3R5bGVzaGVldFxuICpcbiAqIENyZWF0ZXMgc2VtYW50aWNseSBhd2FyZSBkaWZmcyB0aGF0IGNhbiBlYXNpbHkgYmUgYXBwbGllZCBhdCBydW50aW1lLlxuICogT3BlcmF0aW9ucyBwcm9kdWNlZCBieSB0aGUgZGlmZiBjbG9zZWx5IHJlc2VtYmxlIHRoZSBtYXBib3gtZ2wtanMgQVBJLiBBbnlcbiAqIGVycm9yIGNyZWF0aW5nIHRoZSBkaWZmIHdpbGwgZmFsbCBiYWNrIHRvIHRoZSAnc2V0U3R5bGUnIG9wZXJhdGlvbi5cbiAqXG4gKiBFeGFtcGxlIGRpZmY6XG4gKiBbXG4gKiAgICAgeyBjb21tYW5kOiAnc2V0Q29uc3RhbnQnLCBhcmdzOiBbJ0B3YXRlcicsICcjMDAwMEZGJ10gfSxcbiAqICAgICB7IGNvbW1hbmQ6ICdzZXRQYWludFByb3BlcnR5JywgYXJnczogWydiYWNrZ3JvdW5kJywgJ2JhY2tncm91bmQtY29sb3InLCAnYmxhY2snXSB9XG4gKiBdXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gW2JlZm9yZV0gc3R5bGVzaGVldCB0byBjb21wYXJlIGZyb21cbiAqIEBwYXJhbSB7Kn0gYWZ0ZXIgc3R5bGVzaGVldCB0byBjb21wYXJlIHRvXG4gKiBAcmV0dXJucyBBcnJheSBsaXN0IG9mIGNoYW5nZXNcbiAqL1xuZnVuY3Rpb24gZGlmZlN0eWxlcyhiZWZvcmUsIGFmdGVyKSB7XG4gICAgaWYgKCFiZWZvcmUpIHJldHVybiBbeyBjb21tYW5kOiBvcGVyYXRpb25zLnNldFN0eWxlLCBhcmdzOiBbYWZ0ZXJdIH1dO1xuXG4gICAgbGV0IGNvbW1hbmRzID0gW107XG5cbiAgICB0cnkge1xuICAgICAgICAvLyBIYW5kbGUgY2hhbmdlcyB0byB0b3AtbGV2ZWwgcHJvcGVydGllc1xuICAgICAgICBpZiAoIWlzRXF1YWwoYmVmb3JlLnZlcnNpb24sIGFmdGVyLnZlcnNpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gW3sgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRTdHlsZSwgYXJnczogW2FmdGVyXSB9XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzRXF1YWwoYmVmb3JlLmNlbnRlciwgYWZ0ZXIuY2VudGVyKSkge1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7IGNvbW1hbmQ6IG9wZXJhdGlvbnMuc2V0Q2VudGVyLCBhcmdzOiBbYWZ0ZXIuY2VudGVyXSB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzRXF1YWwoYmVmb3JlLnpvb20sIGFmdGVyLnpvb20pKSB7XG4gICAgICAgICAgICBjb21tYW5kcy5wdXNoKHsgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRab29tLCBhcmdzOiBbYWZ0ZXIuem9vbV0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0VxdWFsKGJlZm9yZS5iZWFyaW5nLCBhZnRlci5iZWFyaW5nKSkge1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7IGNvbW1hbmQ6IG9wZXJhdGlvbnMuc2V0QmVhcmluZywgYXJnczogW2FmdGVyLmJlYXJpbmddIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNFcXVhbChiZWZvcmUucGl0Y2gsIGFmdGVyLnBpdGNoKSkge1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7IGNvbW1hbmQ6IG9wZXJhdGlvbnMuc2V0UGl0Y2gsIGFyZ3M6IFthZnRlci5waXRjaF0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0VxdWFsKGJlZm9yZS5zcHJpdGUsIGFmdGVyLnNwcml0ZSkpIHtcbiAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goeyBjb21tYW5kOiBvcGVyYXRpb25zLnNldFNwcml0ZSwgYXJnczogW2FmdGVyLnNwcml0ZV0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0VxdWFsKGJlZm9yZS5nbHlwaHMsIGFmdGVyLmdseXBocykpIHtcbiAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goeyBjb21tYW5kOiBvcGVyYXRpb25zLnNldEdseXBocywgYXJnczogW2FmdGVyLmdseXBoc10gfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0VxdWFsKGJlZm9yZS50cmFuc2l0aW9uLCBhZnRlci50cmFuc2l0aW9uKSkge1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7IGNvbW1hbmQ6IG9wZXJhdGlvbnMuc2V0VHJhbnNpdGlvbiwgYXJnczogW2FmdGVyLnRyYW5zaXRpb25dIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNFcXVhbChiZWZvcmUubGlnaHQsIGFmdGVyLmxpZ2h0KSkge1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7IGNvbW1hbmQ6IG9wZXJhdGlvbnMuc2V0TGlnaHQsIGFyZ3M6IFthZnRlci5saWdodF0gfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW5kbGUgY2hhbmdlcyB0byBgc291cmNlc2BcbiAgICAgICAgLy8gSWYgYSBzb3VyY2UgaXMgdG8gYmUgcmVtb3ZlZCwgd2UgYWxzby0tYmVmb3JlIHRoZSByZW1vdmVTb3VyY2VcbiAgICAgICAgLy8gY29tbWFuZC0tbmVlZCB0byByZW1vdmUgYWxsIHRoZSBzdHlsZSBsYXllcnMgdGhhdCBkZXBlbmQgb24gaXQuXG4gICAgICAgIGNvbnN0IHNvdXJjZXNSZW1vdmVkID0ge307XG5cbiAgICAgICAgLy8gRmlyc3QgY29sbGVjdCB0aGUge2FkZCxyZW1vdmV9U291cmNlIGNvbW1hbmRzXG4gICAgICAgIGNvbnN0IHJlbW92ZU9yQWRkU291cmNlQ29tbWFuZHMgPSBbXTtcbiAgICAgICAgZGlmZlNvdXJjZXMoYmVmb3JlLnNvdXJjZXMsIGFmdGVyLnNvdXJjZXMsIHJlbW92ZU9yQWRkU291cmNlQ29tbWFuZHMsIHNvdXJjZXNSZW1vdmVkKTtcblxuICAgICAgICAvLyBQdXNoIGEgcmVtb3ZlTGF5ZXIgY29tbWFuZCBmb3IgZWFjaCBzdHlsZSBsYXllciB0aGF0IGRlcGVuZHMgb24gYVxuICAgICAgICAvLyBzb3VyY2UgdGhhdCdzIGJlaW5nIHJlbW92ZWQuXG4gICAgICAgIC8vIEFsc28sIGV4Y2x1ZGUgYW55IHN1Y2ggbGF5ZXJzIHRoZW0gZnJvbSB0aGUgaW5wdXQgdG8gYGRpZmZMYXllcnNgXG4gICAgICAgIC8vIGJlbG93LCBzbyB0aGF0IGRpZmZMYXllcnMgcHJvZHVjZXMgdGhlIGFwcHJvcHJpYXRlIGBhZGRMYXllcnNgXG4gICAgICAgIC8vIGNvbW1hbmRcbiAgICAgICAgY29uc3QgYmVmb3JlTGF5ZXJzID0gW107XG4gICAgICAgIGlmIChiZWZvcmUubGF5ZXJzKSB7XG4gICAgICAgICAgICBiZWZvcmUubGF5ZXJzLmZvckVhY2goKGxheWVyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZXNSZW1vdmVkW2xheWVyLnNvdXJjZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7IGNvbW1hbmQ6IG9wZXJhdGlvbnMucmVtb3ZlTGF5ZXIsIGFyZ3M6IFtsYXllci5pZF0gfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlTGF5ZXJzLnB1c2gobGF5ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbW1hbmRzID0gY29tbWFuZHMuY29uY2F0KHJlbW92ZU9yQWRkU291cmNlQ29tbWFuZHMpO1xuXG4gICAgICAgIC8vIEhhbmRsZSBjaGFuZ2VzIHRvIGBsYXllcnNgXG4gICAgICAgIGRpZmZMYXllcnMoYmVmb3JlTGF5ZXJzLCBhZnRlci5sYXllcnMsIGNvbW1hbmRzKTtcblxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gZmFsbCBiYWNrIHRvIHNldFN0eWxlXG4gICAgICAgIGNvbnNvbGUud2FybignVW5hYmxlIHRvIGNvbXB1dGUgc3R5bGUgZGlmZjonLCBlKTtcbiAgICAgICAgY29tbWFuZHMgPSBbeyBjb21tYW5kOiBvcGVyYXRpb25zLnNldFN0eWxlLCBhcmdzOiBbYWZ0ZXJdIH1dO1xuICAgIH1cblxuICAgIHJldHVybiBjb21tYW5kcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkaWZmU3R5bGVzO1xubW9kdWxlLmV4cG9ydHMub3BlcmF0aW9ucyA9IG9wZXJhdGlvbnM7XG4iLCJcbmZ1bmN0aW9uIFBhcnNpbmdFcnJvcihlcnJvcikge1xuICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICB0aGlzLm1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xuICAgIGNvbnN0IG1hdGNoID0gZXJyb3IubWVzc2FnZS5tYXRjaCgvbGluZSAoXFxkKykvKTtcbiAgICB0aGlzLmxpbmUgPSBtYXRjaCA/IHBhcnNlSW50KG1hdGNoWzFdLCAxMCkgOiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnNpbmdFcnJvcjtcbiIsIlxuY29uc3QgZm9ybWF0ID0gcmVxdWlyZSgndXRpbCcpLmZvcm1hdDtcblxuZnVuY3Rpb24gVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsIC4uLmFyZ3MpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSAoa2V5ID8gYCR7a2V5fTogYCA6ICcnKSArIGZvcm1hdC5hcHBseShmb3JtYXQsIGFyZ3MpO1xuXG4gICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUuX19saW5lX18pIHtcbiAgICAgICAgdGhpcy5saW5lID0gdmFsdWUuX19saW5lX187XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFZhbGlkYXRpb25FcnJvcjtcbiIsIi8vICAgICAgXG5cbmNvbnN0IHsgdG9TdHJpbmcgfSA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcbmNvbnN0IFBhcnNpbmdDb250ZXh0ID0gcmVxdWlyZSgnLi9wYXJzaW5nX2NvbnRleHQnKTtcbmNvbnN0IEV2YWx1YXRpb25Db250ZXh0ID0gcmVxdWlyZSgnLi9ldmFsdWF0aW9uX2NvbnRleHQnKTtcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5cbmNsYXNzIENvbXBvdW5kRXhwcmVzc2lvbiAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcblxuICAgIGNvbnN0cnVjdG9yKGtleSAgICAgICAgLCBuYW1lICAgICAgICAsIHR5cGUgICAgICAsIGV2YWx1YXRlICAgICAgICAgICwgYXJncyAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuX2V2YWx1YXRlID0gZXZhbHVhdGU7XG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgfVxuXG4gICAgZXZhbHVhdGUoY3R4ICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXZhbHVhdGUoY3R4LCB0aGlzLmFyZ3MpO1xuICAgIH1cblxuICAgIGVhY2hDaGlsZChmbiAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgdGhpcy5hcmdzLmZvckVhY2goZm4pO1xuICAgIH1cblxuICAgIHN0YXRpYyBwYXJzZShhcmdzICAgICAgICAgICAgICAsIGNvbnRleHQgICAgICAgICAgICAgICAgKSAgICAgICAgICAgICAge1xuICAgICAgICBjb25zdCBvcCAgICAgICAgID0gKGFyZ3NbMF0gICAgICk7XG4gICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSBDb21wb3VuZEV4cHJlc3Npb24uZGVmaW5pdGlvbnNbb3BdO1xuICAgICAgICBpZiAoIWRlZmluaXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKGBVbmtub3duIGV4cHJlc3Npb24gXCIke29wfVwiLiBJZiB5b3Ugd2FudGVkIGEgbGl0ZXJhbCBhcnJheSwgdXNlIFtcImxpdGVyYWxcIiwgWy4uLl1dLmAsIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm93IGNoZWNrIGFyZ3VtZW50IHR5cGVzIGFnYWluc3QgZWFjaCBzaWduYXR1cmVcbiAgICAgICAgY29uc3QgdHlwZSA9IEFycmF5LmlzQXJyYXkoZGVmaW5pdGlvbikgP1xuICAgICAgICAgICAgZGVmaW5pdGlvblswXSA6IGRlZmluaXRpb24udHlwZTtcblxuICAgICAgICBjb25zdCBvdmVybG9hZHMgPSBBcnJheS5pc0FycmF5KGRlZmluaXRpb24pID9cbiAgICAgICAgICAgIFtbZGVmaW5pdGlvblsxXSwgZGVmaW5pdGlvblsyXV1dIDpcbiAgICAgICAgICAgIGRlZmluaXRpb24ub3ZlcmxvYWRzLmZpbHRlcihvdmVybG9hZCA9PiAoXG4gICAgICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkob3ZlcmxvYWRbMF1bMF0pIHx8IC8vIHZhcmFnc1xuICAgICAgICAgICAgICAgIG92ZXJsb2FkWzBdWzBdLmxlbmd0aCA9PT0gYXJncy5sZW5ndGggLSAxIC8vIGNvcnJlY3QgcGFyYW0gY291bnRcbiAgICAgICAgICAgICkpO1xuXG4gICAgICAgIC8vIEZpcnN0IHBhcnNlIGFsbCB0aGUgYXJnc1xuICAgICAgICBjb25zdCBwYXJzZWRBcmdzICAgICAgICAgICAgICAgICAgICA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGFyZyA9IGFyZ3NbaV07XG4gICAgICAgICAgICBsZXQgZXhwZWN0ZWQ7XG4gICAgICAgICAgICBpZiAob3ZlcmxvYWRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IG92ZXJsb2Fkc1swXVswXTtcbiAgICAgICAgICAgICAgICBleHBlY3RlZCA9IEFycmF5LmlzQXJyYXkocGFyYW1zKSA/XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtc1tpIC0gMV0gOlxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMudHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IGNvbnRleHQucGFyc2UoYXJnLCAxICsgcGFyc2VkQXJncy5sZW5ndGgsIGV4cGVjdGVkKTtcbiAgICAgICAgICAgIGlmICghcGFyc2VkKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHBhcnNlZEFyZ3MucHVzaChwYXJzZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHNpZ25hdHVyZUNvbnRleHQgICAgICAgICAgICAgICAgID0gKG51bGwgICAgICk7XG5cbiAgICAgICAgZm9yIChjb25zdCBbcGFyYW1zLCBldmFsdWF0ZV0gb2Ygb3ZlcmxvYWRzKSB7XG4gICAgICAgICAgICAvLyBVc2UgYSBmcmVzaCBjb250ZXh0IGZvciBlYWNoIGF0dGVtcHRlZCBzaWduYXR1cmUgc28gdGhhdCwgaWZcbiAgICAgICAgICAgIC8vIHdlIGV2ZW50dWFsbHkgc3VjY2VlZCwgd2UgaGF2ZW4ndCBwb2xsdXRlZCBgY29udGV4dC5lcnJvcnNgLlxuICAgICAgICAgICAgc2lnbmF0dXJlQ29udGV4dCA9IG5ldyBQYXJzaW5nQ29udGV4dChjb250ZXh0LmRlZmluaXRpb25zLCBjb250ZXh0LnBhdGgsIG51bGwsIGNvbnRleHQuc2NvcGUpO1xuXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbXMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IHBhcnNlZEFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZUNvbnRleHQuZXJyb3IoYEV4cGVjdGVkICR7cGFyYW1zLmxlbmd0aH0gYXJndW1lbnRzLCBidXQgZm91bmQgJHtwYXJzZWRBcmdzLmxlbmd0aH0gaW5zdGVhZC5gKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlZEFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBleHBlY3RlZCA9IEFycmF5LmlzQXJyYXkocGFyYW1zKSA/IHBhcmFtc1tpXSA6IHBhcmFtcy50eXBlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZyA9IHBhcnNlZEFyZ3NbaV07XG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlQ29udGV4dC5jb25jYXQoaSArIDEpLmNoZWNrU3VidHlwZShleHBlY3RlZCwgYXJnLnR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2lnbmF0dXJlQ29udGV4dC5lcnJvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wb3VuZEV4cHJlc3Npb24oY29udGV4dC5rZXksIG9wLCB0eXBlLCBldmFsdWF0ZSwgcGFyc2VkQXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhc3NlcnQoc2lnbmF0dXJlQ29udGV4dC5lcnJvcnMubGVuZ3RoID4gMCk7XG5cbiAgICAgICAgaWYgKG92ZXJsb2Fkcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZXJyb3JzLnB1c2guYXBwbHkoY29udGV4dC5lcnJvcnMsIHNpZ25hdHVyZUNvbnRleHQuZXJyb3JzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZXMgPSBvdmVybG9hZHNcbiAgICAgICAgICAgICAgICAubWFwKChbcGFyYW1zXSkgPT4gc3RyaW5naWZ5U2lnbmF0dXJlKHBhcmFtcykpXG4gICAgICAgICAgICAgICAgLmpvaW4oJyB8ICcpO1xuICAgICAgICAgICAgY29uc3QgYWN0dWFsVHlwZXMgPSBwYXJzZWRBcmdzXG4gICAgICAgICAgICAgICAgLm1hcChhcmcgPT4gdG9TdHJpbmcoYXJnLnR5cGUpKVxuICAgICAgICAgICAgICAgIC5qb2luKCcsICcpO1xuICAgICAgICAgICAgY29udGV4dC5lcnJvcihgRXhwZWN0ZWQgYXJndW1lbnRzIG9mIHR5cGUgJHtzaWduYXR1cmVzfSwgYnV0IGZvdW5kICgke2FjdHVhbFR5cGVzfSkgaW5zdGVhZC5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHN0YXRpYyByZWdpc3RlcihcbiAgICAgICAgZXhwcmVzc2lvbnMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsXG4gICAgICAgIGRlZmluaXRpb25zICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICApIHtcbiAgICAgICAgYXNzZXJ0KCFDb21wb3VuZEV4cHJlc3Npb24uZGVmaW5pdGlvbnMpO1xuICAgICAgICBDb21wb3VuZEV4cHJlc3Npb24uZGVmaW5pdGlvbnMgPSBkZWZpbml0aW9ucztcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGRlZmluaXRpb25zKSB7XG4gICAgICAgICAgICBleHByZXNzaW9uc1tuYW1lXSA9IENvbXBvdW5kRXhwcmVzc2lvbjtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gdmFyYXJncyh0eXBlICAgICAgKSAgICAgICAgICB7XG4gICAgcmV0dXJuIHsgdHlwZSB9O1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlTaWduYXR1cmUoc2lnbmF0dXJlICAgICAgICAgICApICAgICAgICAge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNpZ25hdHVyZSkpIHtcbiAgICAgICAgcmV0dXJuIGAoJHtzaWduYXR1cmUubWFwKHRvU3RyaW5nKS5qb2luKCcsICcpfSlgO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBgKCR7dG9TdHJpbmcoc2lnbmF0dXJlLnR5cGUpfS4uLilgO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgQ29tcG91bmRFeHByZXNzaW9uLFxuICAgIHZhcmFyZ3Ncbn07XG5cbiIsIi8vICAgICAgXG5cbmNvbnN0IHtcbiAgICB0b1N0cmluZyxcbiAgICBhcnJheSxcbiAgICBWYWx1ZVR5cGUsXG4gICAgU3RyaW5nVHlwZSxcbiAgICBOdW1iZXJUeXBlLFxuICAgIEJvb2xlYW5UeXBlLFxuICAgIGNoZWNrU3VidHlwZVxufSA9IHJlcXVpcmUoJy4uL3R5cGVzJyk7XG5cbmNvbnN0IHt0eXBlT2Z9ID0gcmVxdWlyZSgnLi4vdmFsdWVzJyk7XG5jb25zdCBSdW50aW1lRXJyb3IgPSByZXF1aXJlKCcuLi9ydW50aW1lX2Vycm9yJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcblxuY29uc3QgdHlwZXMgPSB7XG4gICAgc3RyaW5nOiBTdHJpbmdUeXBlLFxuICAgIG51bWJlcjogTnVtYmVyVHlwZSxcbiAgICBib29sZWFuOiBCb29sZWFuVHlwZVxufTtcblxuY2xhc3MgQXJyYXlBc3NlcnRpb24gICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgXG5cbiAgICBjb25zdHJ1Y3RvcihrZXkgICAgICAgICwgdHlwZSAgICAgICAgICAgLCBpbnB1dCAgICAgICAgICAgICkge1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgIH1cblxuICAgIHN0YXRpYyBwYXJzZShhcmdzICAgICAgICAgICAgICAsIGNvbnRleHQgICAgICAgICAgICAgICAgKSAgICAgICAgICAgICAge1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPCAyIHx8IGFyZ3MubGVuZ3RoID4gNClcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKGBFeHBlY3RlZCAxLCAyLCBvciAzIGFyZ3VtZW50cywgYnV0IGZvdW5kICR7YXJncy5sZW5ndGggLSAxfSBpbnN0ZWFkLmApO1xuXG4gICAgICAgIGxldCBpdGVtVHlwZTtcbiAgICAgICAgbGV0IE47XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBhcmdzWzFdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJyB8fCAhKHR5cGUgaW4gdHlwZXMpKVxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdUaGUgaXRlbSB0eXBlIGFyZ3VtZW50IG9mIFwiYXJyYXlcIiBtdXN0IGJlIG9uZSBvZiBzdHJpbmcsIG51bWJlciwgYm9vbGVhbicsIDEpO1xuICAgICAgICAgICAgaXRlbVR5cGUgPSB0eXBlc1t0eXBlXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW1UeXBlID0gVmFsdWVUeXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMykge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHR5cGVvZiBhcmdzWzJdICE9PSAnbnVtYmVyJyB8fFxuICAgICAgICAgICAgICAgIGFyZ3NbMl0gPCAwIHx8XG4gICAgICAgICAgICAgICAgYXJnc1syXSAhPT0gTWF0aC5mbG9vcihhcmdzWzJdKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ1RoZSBsZW5ndGggYXJndW1lbnQgdG8gXCJhcnJheVwiIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGxpdGVyYWwnLCAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE4gPSBhcmdzWzJdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdHlwZSA9IGFycmF5KGl0ZW1UeXBlLCBOKTtcblxuICAgICAgICBjb25zdCBpbnB1dCA9IGNvbnRleHQucGFyc2UoYXJnc1thcmdzLmxlbmd0aCAtIDFdLCBhcmdzLmxlbmd0aCAtIDEsIFZhbHVlVHlwZSk7XG4gICAgICAgIGlmICghaW5wdXQpIHJldHVybiBudWxsO1xuXG4gICAgICAgIHJldHVybiBuZXcgQXJyYXlBc3NlcnRpb24oY29udGV4dC5rZXksIHR5cGUsIGlucHV0KTtcbiAgICB9XG5cbiAgICBldmFsdWF0ZShjdHggICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5pbnB1dC5ldmFsdWF0ZShjdHgpO1xuICAgICAgICBjb25zdCBlcnJvciA9IGNoZWNrU3VidHlwZSh0aGlzLnR5cGUsIHR5cGVPZih2YWx1ZSkpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoYEV4cGVjdGVkIHZhbHVlIHRvIGJlIG9mIHR5cGUgJHt0b1N0cmluZyh0aGlzLnR5cGUpfSwgYnV0IGZvdW5kICR7dG9TdHJpbmcodHlwZU9mKHZhbHVlKSl9IGluc3RlYWQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGVhY2hDaGlsZChmbiAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgZm4odGhpcy5pbnB1dCk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5QXNzZXJ0aW9uO1xuIiwiLy8gICAgICBcblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5jb25zdCB7XG4gICAgT2JqZWN0VHlwZSxcbiAgICBWYWx1ZVR5cGUsXG4gICAgU3RyaW5nVHlwZSxcbiAgICBOdW1iZXJUeXBlLFxuICAgIEJvb2xlYW5UeXBlXG59ID0gcmVxdWlyZSgnLi4vdHlwZXMnKTtcblxuY29uc3QgUnVudGltZUVycm9yID0gcmVxdWlyZSgnLi4vcnVudGltZV9lcnJvcicpO1xuY29uc3Qge2NoZWNrU3VidHlwZSwgdG9TdHJpbmd9ID0gcmVxdWlyZSgnLi4vdHlwZXMnKTtcbmNvbnN0IHt0eXBlT2Z9ID0gcmVxdWlyZSgnLi4vdmFsdWVzJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5cbmNvbnN0IHR5cGVzID0ge1xuICAgIHN0cmluZzogU3RyaW5nVHlwZSxcbiAgICBudW1iZXI6IE51bWJlclR5cGUsXG4gICAgYm9vbGVhbjogQm9vbGVhblR5cGUsXG4gICAgb2JqZWN0OiBPYmplY3RUeXBlXG59O1xuXG5jbGFzcyBBc3NlcnRpb24gICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuXG4gICAgY29uc3RydWN0b3Ioa2V5ICAgICAgICAsIHR5cGUgICAgICAsIGFyZ3MgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgIH1cblxuICAgIHN0YXRpYyBwYXJzZShhcmdzICAgICAgICAgICAgICAsIGNvbnRleHQgICAgICAgICAgICAgICAgKSAgICAgICAgICAgICAge1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPCAyKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoYEV4cGVjdGVkIGF0IGxlYXN0IG9uZSBhcmd1bWVudC5gKTtcblxuICAgICAgICBjb25zdCBuYW1lICAgICAgICAgPSAoYXJnc1swXSAgICAgKTtcbiAgICAgICAgYXNzZXJ0KHR5cGVzW25hbWVdLCBuYW1lKTtcblxuICAgICAgICBjb25zdCB0eXBlID0gdHlwZXNbbmFtZV07XG5cbiAgICAgICAgY29uc3QgcGFyc2VkID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaW5wdXQgPSBjb250ZXh0LnBhcnNlKGFyZ3NbaV0sIGksIFZhbHVlVHlwZSk7XG4gICAgICAgICAgICBpZiAoIWlucHV0KSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHBhcnNlZC5wdXNoKGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgQXNzZXJ0aW9uKGNvbnRleHQua2V5LCB0eXBlLCBwYXJzZWQpO1xuICAgIH1cblxuICAgIGV2YWx1YXRlKGN0eCAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5hcmdzW2ldLmV2YWx1YXRlKGN0eCk7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IGNoZWNrU3VidHlwZSh0aGlzLnR5cGUsIHR5cGVPZih2YWx1ZSkpO1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gdGhpcy5hcmdzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKGBFeHBlY3RlZCB2YWx1ZSB0byBiZSBvZiB0eXBlICR7dG9TdHJpbmcodGhpcy50eXBlKX0sIGJ1dCBmb3VuZCAke3RvU3RyaW5nKHR5cGVPZih2YWx1ZSkpfSBpbnN0ZWFkLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYXNzZXJ0KGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZWFjaENoaWxkKGZuICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICB0aGlzLmFyZ3MuZm9yRWFjaChmbik7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEFzc2VydGlvbjtcbiIsIi8vICAgICAgXG5cbmNvbnN0IHtcbiAgICBhcnJheSxcbiAgICBWYWx1ZVR5cGUsXG4gICAgTnVtYmVyVHlwZVxufSA9IHJlcXVpcmUoJy4uL3R5cGVzJyk7XG5cbmNvbnN0IFJ1bnRpbWVFcnJvciA9IHJlcXVpcmUoJy4uL3J1bnRpbWVfZXJyb3InKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5cbmNsYXNzIEF0ICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICBcblxuICAgIGNvbnN0cnVjdG9yKGtleSAgICAgICAgLCB0eXBlICAgICAgLCBpbmRleCAgICAgICAgICAgICwgaW5wdXQgICAgICAgICAgICApIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgIH1cblxuICAgIHN0YXRpYyBwYXJzZShhcmdzICAgICAgICAgICAgICAsIGNvbnRleHQgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMylcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKGBFeHBlY3RlZCAyIGFyZ3VtZW50cywgYnV0IGZvdW5kICR7YXJncy5sZW5ndGggLSAxfSBpbnN0ZWFkLmApO1xuXG4gICAgICAgIGNvbnN0IGluZGV4ID0gY29udGV4dC5wYXJzZShhcmdzWzFdLCAxLCBOdW1iZXJUeXBlKTtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBjb250ZXh0LnBhcnNlKGFyZ3NbMl0sIDIsIGFycmF5KGNvbnRleHQuZXhwZWN0ZWRUeXBlIHx8IFZhbHVlVHlwZSkpO1xuXG4gICAgICAgIGlmICghaW5kZXggfHwgIWlucHV0KSByZXR1cm4gbnVsbDtcblxuICAgICAgICBjb25zdCB0ICAgICAgICAgICAgPSAoaW5wdXQudHlwZSAgICAgKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBdChjb250ZXh0LmtleSwgdC5pdGVtVHlwZSwgaW5kZXgsIGlucHV0KTtcbiAgICB9XG5cbiAgICBldmFsdWF0ZShjdHggICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gKCh0aGlzLmluZGV4LmV2YWx1YXRlKGN0eCkgICAgICkgICAgICAgICk7XG4gICAgICAgIGNvbnN0IGFycmF5ID0gKCh0aGlzLmlucHV0LmV2YWx1YXRlKGN0eCkgICAgICkgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSBhcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoYEFycmF5IGluZGV4IG91dCBvZiBib3VuZHM6ICR7aW5kZXh9ID4gJHthcnJheS5sZW5ndGh9LmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4ICE9PSBNYXRoLmZsb29yKGluZGV4KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcihgQXJyYXkgaW5kZXggbXVzdCBiZSBhbiBpbnRlZ2VyLCBidXQgZm91bmQgJHtpbmRleH0gaW5zdGVhZC5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhcnJheVtpbmRleF07XG4gICAgfVxuXG4gICAgZWFjaENoaWxkKGZuICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICBmbih0aGlzLmluZGV4KTtcbiAgICAgICAgZm4odGhpcy5pbnB1dCk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEF0O1xuIiwiLy8gICAgICBcblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5jb25zdCB7IEJvb2xlYW5UeXBlIH0gPSByZXF1aXJlKCcuLi90eXBlcycpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcblxuY2xhc3MgQ2FzZSAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgXG5cbiAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFxuXG4gICAgY29uc3RydWN0b3Ioa2V5ICAgICAgICAsIHR5cGUgICAgICAsIGJyYW5jaGVzICAgICAgICAgICwgb3RoZXJ3aXNlICAgICAgICAgICAgKSB7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmJyYW5jaGVzID0gYnJhbmNoZXM7XG4gICAgICAgIHRoaXMub3RoZXJ3aXNlID0gb3RoZXJ3aXNlO1xuICAgIH1cblxuICAgIHN0YXRpYyBwYXJzZShhcmdzICAgICAgICAgICAgICAsIGNvbnRleHQgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA8IDQpXG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihgRXhwZWN0ZWQgYXQgbGVhc3QgMyBhcmd1bWVudHMsIGJ1dCBmb3VuZCBvbmx5ICR7YXJncy5sZW5ndGggLSAxfS5gKTtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoICUgMiAhPT0gMClcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKGBFeHBlY3RlZCBhbiBvZGQgbnVtYmVyIG9mIGFyZ3VtZW50cy5gKTtcblxuICAgICAgICBsZXQgb3V0cHV0VHlwZSAgICAgICA7XG4gICAgICAgIGlmIChjb250ZXh0LmV4cGVjdGVkVHlwZSAmJiBjb250ZXh0LmV4cGVjdGVkVHlwZS5raW5kICE9PSAndmFsdWUnKSB7XG4gICAgICAgICAgICBvdXRwdXRUeXBlID0gY29udGV4dC5leHBlY3RlZFR5cGU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBicmFuY2hlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoIC0gMTsgaSArPSAyKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXN0ID0gY29udGV4dC5wYXJzZShhcmdzW2ldLCBpLCBCb29sZWFuVHlwZSk7XG4gICAgICAgICAgICBpZiAoIXRlc3QpIHJldHVybiBudWxsO1xuXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjb250ZXh0LnBhcnNlKGFyZ3NbaSArIDFdLCBpICsgMSwgb3V0cHV0VHlwZSk7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICAgIGJyYW5jaGVzLnB1c2goW3Rlc3QsIHJlc3VsdF0pO1xuXG4gICAgICAgICAgICBvdXRwdXRUeXBlID0gb3V0cHV0VHlwZSB8fCByZXN1bHQudHlwZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG90aGVyd2lzZSA9IGNvbnRleHQucGFyc2UoYXJnc1thcmdzLmxlbmd0aCAtIDFdLCBhcmdzLmxlbmd0aCAtIDEsIG91dHB1dFR5cGUpO1xuICAgICAgICBpZiAoIW90aGVyd2lzZSkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgYXNzZXJ0KG91dHB1dFR5cGUpO1xuICAgICAgICByZXR1cm4gbmV3IENhc2UoY29udGV4dC5rZXksIChvdXRwdXRUeXBlICAgICApLCBicmFuY2hlcywgb3RoZXJ3aXNlKTtcbiAgICB9XG5cbiAgICBldmFsdWF0ZShjdHggICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgIGZvciAoY29uc3QgW3Rlc3QsIGV4cHJlc3Npb25dIG9mIHRoaXMuYnJhbmNoZXMpIHtcbiAgICAgICAgICAgIGlmICh0ZXN0LmV2YWx1YXRlKGN0eCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwcmVzc2lvbi5ldmFsdWF0ZShjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm90aGVyd2lzZS5ldmFsdWF0ZShjdHgpO1xuICAgIH1cblxuICAgIGVhY2hDaGlsZChmbiAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgZm9yIChjb25zdCBbdGVzdCwgZXhwcmVzc2lvbl0gb2YgdGhpcy5icmFuY2hlcykge1xuICAgICAgICAgICAgZm4odGVzdCk7XG4gICAgICAgICAgICBmbihleHByZXNzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICBmbih0aGlzLm90aGVyd2lzZSk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENhc2U7XG4iLCIvLyAgICAgIFxuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcblxuY2xhc3MgQ29hbGVzY2UgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuXG4gICAgY29uc3RydWN0b3Ioa2V5ICAgICAgICAsIHR5cGUgICAgICAsIGFyZ3MgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgIH1cblxuICAgIHN0YXRpYyBwYXJzZShhcmdzICAgICAgICAgICAgICAsIGNvbnRleHQgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKFwiRXhwZWN0ZWN0ZWQgYXQgbGVhc3Qgb25lIGFyZ3VtZW50LlwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3V0cHV0VHlwZSAgICAgICA9IChudWxsICAgICApO1xuICAgICAgICBpZiAoY29udGV4dC5leHBlY3RlZFR5cGUgJiYgY29udGV4dC5leHBlY3RlZFR5cGUua2luZCAhPT0gJ3ZhbHVlJykge1xuICAgICAgICAgICAgb3V0cHV0VHlwZSA9IGNvbnRleHQuZXhwZWN0ZWRUeXBlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZEFyZ3MgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBhcmcgb2YgYXJncy5zbGljZSgxKSkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gY29udGV4dC5wYXJzZShhcmcsIDEgKyBwYXJzZWRBcmdzLmxlbmd0aCwgb3V0cHV0VHlwZSk7XG4gICAgICAgICAgICBpZiAoIXBhcnNlZCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBvdXRwdXRUeXBlID0gb3V0cHV0VHlwZSB8fCBwYXJzZWQudHlwZTtcbiAgICAgICAgICAgIHBhcnNlZEFyZ3MucHVzaChwYXJzZWQpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydChvdXRwdXRUeXBlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2FsZXNjZShjb250ZXh0LmtleSwgKG91dHB1dFR5cGUgICAgICksIHBhcnNlZEFyZ3MpO1xuICAgIH1cblxuICAgIGV2YWx1YXRlKGN0eCAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgYXJnIG9mIHRoaXMuYXJncykge1xuICAgICAgICAgICAgcmVzdWx0ID0gYXJnLmV2YWx1YXRlKGN0eCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGVhY2hDaGlsZChmbiAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgdGhpcy5hcmdzLmZvckVhY2goZm4pO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb2FsZXNjZTtcbiIsIi8vICAgICAgXG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuY29uc3Qge1xuICAgIENvbG9yVHlwZSxcbiAgICBWYWx1ZVR5cGUsXG4gICAgTnVtYmVyVHlwZSxcbn0gPSByZXF1aXJlKCcuLi90eXBlcycpO1xuXG5jb25zdCB7IENvbG9yLCB2YWxpZGF0ZVJHQkEsIHVud3JhcCB9ID0gcmVxdWlyZSgnLi4vdmFsdWVzJyk7XG5jb25zdCBSdW50aW1lRXJyb3IgPSByZXF1aXJlKCcuLi9ydW50aW1lX2Vycm9yJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5cbmNvbnN0IHR5cGVzID0ge1xuICAgICd0by1udW1iZXInOiBOdW1iZXJUeXBlLFxuICAgICd0by1jb2xvcic6IENvbG9yVHlwZVxufTtcblxuLyoqXG4gKiBTcGVjaWFsIGZvcm0gZm9yIGVycm9yLWNvYWxlc2NpbmcgY29lcmNpb24gZXhwcmVzc2lvbnMgXCJ0by1udW1iZXJcIixcbiAqIFwidG8tY29sb3JcIi4gIFNpbmNlIHRoZXNlIGNvZXJjaW9ucyBjYW4gZmFpbCBhdCBydW50aW1lLCB0aGV5IGFjY2VwdCBtdWx0aXBsZVxuICogYXJndW1lbnRzLCBvbmx5IGV2YWx1YXRpbmcgb25lIGF0IGEgdGltZSB1bnRpbCBvbmUgc3VjY2VlZHMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgQ29lcmNpb24gICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuXG4gICAgY29uc3RydWN0b3Ioa2V5ICAgICAgICAsIHR5cGUgICAgICAsIGFyZ3MgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgIH1cblxuICAgIHN0YXRpYyBwYXJzZShhcmdzICAgICAgICAgICAgICAsIGNvbnRleHQgICAgICAgICAgICAgICAgKSAgICAgICAgICAgICAge1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPCAyKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoYEV4cGVjdGVkIGF0IGxlYXN0IG9uZSBhcmd1bWVudC5gKTtcblxuICAgICAgICBjb25zdCBuYW1lICAgICAgICAgPSAoYXJnc1swXSAgICAgKTtcbiAgICAgICAgYXNzZXJ0KHR5cGVzW25hbWVdLCBuYW1lKTtcblxuICAgICAgICBjb25zdCB0eXBlID0gdHlwZXNbbmFtZV07XG5cbiAgICAgICAgY29uc3QgcGFyc2VkID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaW5wdXQgPSBjb250ZXh0LnBhcnNlKGFyZ3NbaV0sIGksIFZhbHVlVHlwZSk7XG4gICAgICAgICAgICBpZiAoIWlucHV0KSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHBhcnNlZC5wdXNoKGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgQ29lcmNpb24oY29udGV4dC5rZXksIHR5cGUsIHBhcnNlZCk7XG4gICAgfVxuXG4gICAgZXZhbHVhdGUoY3R4ICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICBpZiAodGhpcy50eXBlLmtpbmQgPT09ICdjb2xvcicpIHtcbiAgICAgICAgICAgIGxldCBpbnB1dDtcbiAgICAgICAgICAgIGxldCBlcnJvcjtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYXJnIG9mIHRoaXMuYXJncykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gYXJnLmV2YWx1YXRlKGN0eCk7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGMgPSBjdHgucGFyc2VDb2xvcihpbnB1dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjKSByZXR1cm4gYztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5sZW5ndGggPCAzIHx8IGlucHV0Lmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gYEludmFsaWQgcmJnYSB2YWx1ZSAke0pTT04uc3RyaW5naWZ5KGlucHV0KX06IGV4cGVjdGVkIGFuIGFycmF5IGNvbnRhaW5pbmcgZWl0aGVyIHRocmVlIG9yIGZvdXIgbnVtZXJpYyB2YWx1ZXMuYDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gdmFsaWRhdGVSR0JBKGlucHV0WzBdLCBpbnB1dFsxXSwgaW5wdXRbMl0sIGlucHV0WzNdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKChpbnB1dFswXSAgICAgKSAvIDI1NSwgKGlucHV0WzFdICAgICApIC8gMjU1LCAoaW5wdXRbMl0gICAgICkgLyAyNTUsIChpbnB1dFszXSAgICAgKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKGVycm9yIHx8IGBDb3VsZCBub3QgcGFyc2UgY29sb3IgZnJvbSB2YWx1ZSAnJHt0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnID8gaW5wdXQgOiBKU09OLnN0cmluZ2lmeShpbnB1dCl9J2ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYXJnIG9mIHRoaXMuYXJncykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gYXJnLmV2YWx1YXRlKGN0eCk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBudW0gPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChpc05hTihudW0pKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcihgQ291bGQgbm90IGNvbnZlcnQgJHtKU09OLnN0cmluZ2lmeSh1bndyYXAodmFsdWUpKX0gdG8gbnVtYmVyLmApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZWFjaENoaWxkKGZuICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICB0aGlzLmFyZ3MuZm9yRWFjaChmbik7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvZXJjaW9uO1xuIiwiLy8gICAgICBcblxuY29uc3QgVW5pdEJlemllciA9IHJlcXVpcmUoJ0BtYXBib3gvdW5pdGJlemllcicpO1xuY29uc3QgaW50ZXJwb2xhdGUgPSByZXF1aXJlKCcuLi8uLi91dGlsL2ludGVycG9sYXRlJyk7XG5jb25zdCB7IHRvU3RyaW5nLCBOdW1iZXJUeXBlIH0gPSByZXF1aXJlKCcuLi90eXBlcycpO1xuY29uc3QgeyBDb2xvciB9ID0gcmVxdWlyZSgnLi4vdmFsdWVzJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5cbmNsYXNzIEN1cnZlICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICBcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcblxuICAgIGNvbnN0cnVjdG9yKGtleSAgICAgICAgLCB0eXBlICAgICAgLCBpbnRlcnBvbGF0aW9uICAgICAgICAgICAgICAgICAgICwgaW5wdXQgICAgICAgICAgICAsIHN0b3BzICAgICAgICkge1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5pbnRlcnBvbGF0aW9uID0gaW50ZXJwb2xhdGlvbjtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuXG4gICAgICAgIHRoaXMubGFiZWxzID0gW107XG4gICAgICAgIHRoaXMub3V0cHV0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IFtsYWJlbCwgZXhwcmVzc2lvbl0gb2Ygc3RvcHMpIHtcbiAgICAgICAgICAgIHRoaXMubGFiZWxzLnB1c2gobGFiZWwpO1xuICAgICAgICAgICAgdGhpcy5vdXRwdXRzLnB1c2goZXhwcmVzc2lvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgaW50ZXJwb2xhdGlvbkZhY3RvcihpbnRlcnBvbGF0aW9uICAgICAgICAgICAgICAgICAgICwgaW5wdXQgICAgICAgICwgbG93ZXIgICAgICAgICwgdXBwZXIgICAgICAgICkge1xuICAgICAgICBsZXQgdCA9IDA7XG4gICAgICAgIGlmIChpbnRlcnBvbGF0aW9uLm5hbWUgPT09ICdleHBvbmVudGlhbCcpIHtcbiAgICAgICAgICAgIHQgPSBleHBvbmVudGlhbEludGVycG9sYXRpb24oaW5wdXQsIGludGVycG9sYXRpb24uYmFzZSwgbG93ZXIsIHVwcGVyKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnRlcnBvbGF0aW9uLm5hbWUgPT09ICdsaW5lYXInKSB7XG4gICAgICAgICAgICB0ID0gZXhwb25lbnRpYWxJbnRlcnBvbGF0aW9uKGlucHV0LCAxLCBsb3dlciwgdXBwZXIpO1xuICAgICAgICB9IGVsc2UgaWYgKGludGVycG9sYXRpb24ubmFtZSA9PT0gJ2N1YmljLWJlemllcicpIHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSBpbnRlcnBvbGF0aW9uLmNvbnRyb2xQb2ludHM7XG4gICAgICAgICAgICBjb25zdCB1YiA9IG5ldyBVbml0QmV6aWVyKGNbMF0sIGNbMV0sIGNbMl0sIGNbM10pO1xuICAgICAgICAgICAgdCA9IHViLnNvbHZlKGV4cG9uZW50aWFsSW50ZXJwb2xhdGlvbihpbnB1dCwgMSwgbG93ZXIsIHVwcGVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfVxuXG4gICAgc3RhdGljIHBhcnNlKGFyZ3MgICAgICAgICAgICAgICwgY29udGV4dCAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgbGV0IFsgLCBpbnRlcnBvbGF0aW9uLCBpbnB1dCwgLi4ucmVzdF0gPSBhcmdzO1xuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnRlcnBvbGF0aW9uKSB8fCBpbnRlcnBvbGF0aW9uLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoYEV4cGVjdGVkIGFuIGludGVycG9sYXRpb24gdHlwZSBleHByZXNzaW9uLmAsIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGludGVycG9sYXRpb25bMF0gPT09ICdzdGVwJykge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGlvbiA9IHsgbmFtZTogJ3N0ZXAnIH07XG4gICAgICAgIH0gZWxzZSBpZiAoaW50ZXJwb2xhdGlvblswXSA9PT0gJ2xpbmVhcicpIHtcbiAgICAgICAgICAgIGludGVycG9sYXRpb24gPSB7IG5hbWU6ICdsaW5lYXInIH07XG4gICAgICAgIH0gZWxzZSBpZiAoaW50ZXJwb2xhdGlvblswXSA9PT0gJ2V4cG9uZW50aWFsJykge1xuICAgICAgICAgICAgY29uc3QgYmFzZSA9IGludGVycG9sYXRpb25bMV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGJhc2UgIT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKGBFeHBvbmVudGlhbCBpbnRlcnBvbGF0aW9uIHJlcXVpcmVzIGEgbnVtZXJpYyBiYXNlLmAsIDEsIDEpO1xuICAgICAgICAgICAgaW50ZXJwb2xhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnZXhwb25lbnRpYWwnLFxuICAgICAgICAgICAgICAgIGJhc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoaW50ZXJwb2xhdGlvblswXSA9PT0gJ2N1YmljLWJlemllcicpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xQb2ludHMgPSBpbnRlcnBvbGF0aW9uLnNsaWNlKDEpO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGNvbnRyb2xQb2ludHMubGVuZ3RoICE9PSA0IHx8XG4gICAgICAgICAgICAgICAgY29udHJvbFBvaW50cy5zb21lKHQgPT4gdHlwZW9mIHQgIT09ICdudW1iZXInIHx8IHQgPCAwIHx8IHQgPiAxKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0N1YmljIGJlemllciBpbnRlcnBvbGF0aW9uIHJlcXVpcmVzIGZvdXIgbnVtZXJpYyBhcmd1bWVudHMgd2l0aCB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAxLicsIDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbnRlcnBvbGF0aW9uID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdjdWJpYy1iZXppZXInLFxuICAgICAgICAgICAgICAgIGNvbnRyb2xQb2ludHM6IChjb250cm9sUG9pbnRzICAgICApXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoYFVua25vd24gaW50ZXJwb2xhdGlvbiB0eXBlICR7U3RyaW5nKGludGVycG9sYXRpb25bMF0pfWAsIDEsIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaXNTdGVwID0gaW50ZXJwb2xhdGlvbi5uYW1lID09PSAnc3RlcCc7XG5cbiAgICAgICAgY29uc3QgbWluQXJncyA9IGlzU3RlcCA/IDUgOiA0O1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggLSAxIDwgbWluQXJncylcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKGBFeHBlY3RlZCBhdCBsZWFzdCAke21pbkFyZ3N9IGFyZ3VtZW50cywgYnV0IGZvdW5kIG9ubHkgJHthcmdzLmxlbmd0aCAtIDF9LmApO1xuXG4gICAgICAgIGNvbnN0IHBhcml0eSA9IG1pbkFyZ3MgJSAyO1xuICAgICAgICBpZiAoKGFyZ3MubGVuZ3RoIC0gMSkgJSAyICE9PSBwYXJpdHkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKGBFeHBlY3RlZCBhbiAke3Bhcml0eSA9PT0gMCA/ICdldmVuJyA6ICdvZGQnfSBudW1iZXIgb2YgYXJndW1lbnRzLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5wdXQgPSBjb250ZXh0LnBhcnNlKGlucHV0LCAyLCBOdW1iZXJUeXBlKTtcbiAgICAgICAgaWYgKCFpbnB1dCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgY29uc3Qgc3RvcHMgICAgICAgID0gW107XG5cbiAgICAgICAgbGV0IG91dHB1dFR5cGUgICAgICAgPSAobnVsbCAgICAgKTtcbiAgICAgICAgaWYgKGNvbnRleHQuZXhwZWN0ZWRUeXBlICYmIGNvbnRleHQuZXhwZWN0ZWRUeXBlLmtpbmQgIT09ICd2YWx1ZScpIHtcbiAgICAgICAgICAgIG91dHB1dFR5cGUgPSBjb250ZXh0LmV4cGVjdGVkVHlwZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1N0ZXApIHtcbiAgICAgICAgICAgIHJlc3QudW5zaGlmdCgtSW5maW5pdHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBjb25zdCBsYWJlbCA9IHJlc3RbaV07XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJlc3RbaSArIDFdO1xuXG4gICAgICAgICAgICBjb25zdCBsYWJlbEtleSA9IGlzU3RlcCA/IGkgKyAyIDogaSArIDM7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZUtleSA9IGlzU3RlcCA/IGkgKyAzIDogaSArIDQ7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGFiZWwgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0lucHV0L291dHB1dCBwYWlycyBmb3IgXCJjdXJ2ZVwiIGV4cHJlc3Npb25zIG11c3QgYmUgZGVmaW5lZCB1c2luZyBsaXRlcmFsIG51bWVyaWMgdmFsdWVzIChub3QgY29tcHV0ZWQgZXhwcmVzc2lvbnMpIGZvciB0aGUgaW5wdXQgdmFsdWVzLicsIGxhYmVsS2V5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN0b3BzLmxlbmd0aCAmJiBzdG9wc1tzdG9wcy5sZW5ndGggLSAxXVswXSA+IGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0lucHV0L291dHB1dCBwYWlycyBmb3IgXCJjdXJ2ZVwiIGV4cHJlc3Npb25zIG11c3QgYmUgYXJyYW5nZWQgd2l0aCBpbnB1dCB2YWx1ZXMgaW4gc3RyaWN0bHkgYXNjZW5kaW5nIG9yZGVyLicsIGxhYmVsS2V5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gY29udGV4dC5wYXJzZSh2YWx1ZSwgdmFsdWVLZXksIG91dHB1dFR5cGUpO1xuICAgICAgICAgICAgaWYgKCFwYXJzZWQpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgb3V0cHV0VHlwZSA9IG91dHB1dFR5cGUgfHwgcGFyc2VkLnR5cGU7XG4gICAgICAgICAgICBzdG9wcy5wdXNoKFtsYWJlbCwgcGFyc2VkXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW50ZXJwb2xhdGlvbi5uYW1lICE9PSAnc3RlcCcgJiZcbiAgICAgICAgICAgIG91dHB1dFR5cGUua2luZCAhPT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgIG91dHB1dFR5cGUua2luZCAhPT0gJ2NvbG9yJyAmJlxuICAgICAgICAgICAgIShvdXRwdXRUeXBlLmtpbmQgPT09ICdhcnJheScgJiYgb3V0cHV0VHlwZS5pdGVtVHlwZS5raW5kID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKGBUeXBlICR7dG9TdHJpbmcob3V0cHV0VHlwZSl9IGlzIG5vdCBpbnRlcnBvbGF0YWJsZSwgYW5kIHRodXMgY2Fubm90IGJlIHVzZWQgYXMgYSAke2ludGVycG9sYXRpb24ubmFtZX0gY3VydmUncyBvdXRwdXQgdHlwZS5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgQ3VydmUoY29udGV4dC5rZXksIG91dHB1dFR5cGUsIGludGVycG9sYXRpb24sIGlucHV0LCBzdG9wcyk7XG4gICAgfVxuXG4gICAgZXZhbHVhdGUoY3R4ICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmxhYmVscztcbiAgICAgICAgY29uc3Qgb3V0cHV0cyA9IHRoaXMub3V0cHV0cztcblxuICAgICAgICBpZiAobGFiZWxzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dHNbMF0uZXZhbHVhdGUoY3R4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHZhbHVlID0gKCh0aGlzLmlucHV0LmV2YWx1YXRlKGN0eCkgICAgICkgICAgICAgICk7XG4gICAgICAgIGlmICh2YWx1ZSA8PSBsYWJlbHNbMF0pIHtcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXRzWzBdLmV2YWx1YXRlKGN0eCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdG9wQ291bnQgPSBsYWJlbHMubGVuZ3RoO1xuICAgICAgICBpZiAodmFsdWUgPj0gbGFiZWxzW3N0b3BDb3VudCAtIDFdKSB7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0c1tzdG9wQ291bnQgLSAxXS5ldmFsdWF0ZShjdHgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaW5kZXggPSBmaW5kU3RvcExlc3NUaGFuT3JFcXVhbFRvKGxhYmVscywgdmFsdWUpO1xuICAgICAgICBpZiAodGhpcy5pbnRlcnBvbGF0aW9uLm5hbWUgPT09ICdzdGVwJykge1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dHNbaW5kZXhdLmV2YWx1YXRlKGN0eCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsb3dlciA9IGxhYmVsc1tpbmRleF07XG4gICAgICAgIGNvbnN0IHVwcGVyID0gbGFiZWxzW2luZGV4ICsgMV07XG4gICAgICAgIGNvbnN0IHQgPSBDdXJ2ZS5pbnRlcnBvbGF0aW9uRmFjdG9yKHRoaXMuaW50ZXJwb2xhdGlvbiwgdmFsdWUsIGxvd2VyLCB1cHBlcik7XG5cbiAgICAgICAgY29uc3Qgb3V0cHV0TG93ZXIgPSBvdXRwdXRzW2luZGV4XS5ldmFsdWF0ZShjdHgpO1xuICAgICAgICBjb25zdCBvdXRwdXRVcHBlciA9IG91dHB1dHNbaW5kZXggKyAxXS5ldmFsdWF0ZShjdHgpO1xuXG4gICAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLnR5cGUua2luZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbG9yJykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvciguLi5pbnRlcnBvbGF0ZS5jb2xvcigob3V0cHV0TG93ZXIgICAgICkudmFsdWUsIChvdXRwdXRVcHBlciAgICAgKS52YWx1ZSwgdCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGludGVycG9sYXRlW3R5cGVdKG91dHB1dExvd2VyLCBvdXRwdXRVcHBlciwgdCk7XG4gICAgfVxuXG4gICAgZWFjaENoaWxkKGZuICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICBmbih0aGlzLmlucHV0KTtcbiAgICAgICAgZm9yIChjb25zdCBleHByZXNzaW9uIG9mIHRoaXMub3V0cHV0cykge1xuICAgICAgICAgICAgZm4oZXhwcmVzc2lvbik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHJhdGlvIHRoYXQgY2FuIGJlIHVzZWQgdG8gaW50ZXJwb2xhdGUgYmV0d2VlbiBleHBvbmVudGlhbCBmdW5jdGlvblxuICogc3RvcHMuXG4gKiBIb3cgaXQgd29ya3M6IFR3byBjb25zZWN1dGl2ZSBzdG9wIHZhbHVlcyBkZWZpbmUgYSAoc2NhbGVkIGFuZCBzaGlmdGVkKSBleHBvbmVudGlhbCBmdW5jdGlvbiBgZih4KSA9IGEgKiBiYXNlXnggKyBiYCwgd2hlcmUgYGJhc2VgIGlzIHRoZSB1c2VyLXNwZWNpZmllZCBiYXNlLFxuICogYW5kIGBhYCBhbmQgYGJgIGFyZSBjb25zdGFudHMgYWZmb3JkaW5nIHN1ZmZpY2llbnQgZGVncmVlcyBvZiBmcmVlZG9tIHRvIGZpdFxuICogdGhlIGZ1bmN0aW9uIHRvIHRoZSBnaXZlbiBzdG9wcy5cbiAqXG4gKiBIZXJlJ3MgYSBiaXQgb2YgYWxnZWJyYSB0aGF0IGxldHMgdXMgY29tcHV0ZSBgZih4KWAgZGlyZWN0bHkgZnJvbSB0aGUgc3RvcFxuICogdmFsdWVzIHdpdGhvdXQgZXhwbGljaXRseSBzb2x2aW5nIGZvciBgYWAgYW5kIGBiYDpcbiAqXG4gKiBGaXJzdCBzdG9wIHZhbHVlOiBgZih4MCkgPSB5MCA9IGEgKiBiYXNlXngwICsgYmBcbiAqIFNlY29uZCBzdG9wIHZhbHVlOiBgZih4MSkgPSB5MSA9IGEgKiBiYXNlXngxICsgYmBcbiAqID0+IGB5MSAtIHkwID0gYShiYXNlXngxIC0gYmFzZV54MClgXG4gKiA9PiBgYSA9ICh5MSAtIHkwKS8oYmFzZV54MSAtIGJhc2VeeDApYFxuICpcbiAqIERlc2lyZWQgdmFsdWU6IGBmKHgpID0geSA9IGEgKiBiYXNlXnggKyBiYFxuICogPT4gYGYoeCkgPSB5MCArIGEgKiAoYmFzZV54IC0gYmFzZV54MClgXG4gKlxuICogRnJvbSB0aGUgYWJvdmUsIHdlIGNhbiByZXBsYWNlIHRoZSBgYWAgaW4gYGEgKiAoYmFzZV54IC0gYmFzZV54MClgIGFuZCBkbyBhXG4gKiBsaXR0bGUgYWxnZWJyYTpcbiAqIGBgYFxuICogYSAqIChiYXNlXnggLSBiYXNlXngwKSA9ICh5MSAtIHkwKS8oYmFzZV54MSAtIGJhc2VeeDApICogKGJhc2VeeCAtIGJhc2VeeDApXG4gKiAgICAgICAgICAgICAgICAgICAgID0gKHkxIC0geTApICogKGJhc2VeeCAtIGJhc2VeeDApIC8gKGJhc2VeeDEgLSBiYXNlXngwKVxuICogYGBgXG4gKlxuICogSWYgd2UgbGV0IGAoYmFzZV54IC0gYmFzZV54MCkgLyAoYmFzZV54MSBiYXNlXngwKWAsIHRoZW4gd2UgaGF2ZVxuICogYGYoeCkgPSB5MCArICh5MSAtIHkwKSAqIHJhdGlvYC4gIEluIG90aGVyIHdvcmRzLCBgcmF0aW9gIG1heSBiZSB0cmVhdGVkIGFzXG4gKiBhbiBpbnRlcnBvbGF0aW9uIGZhY3RvciBiZXR3ZWVuIHRoZSB0d28gc3RvcHMnIG91dHB1dCB2YWx1ZXMuXG4gKlxuICogKE5vdGU6IGEgc2xpZ2h0bHkgZGlmZmVyZW50IGZvcm0gZm9yIGByYXRpb2AsXG4gKiBgKGJhc2VeKHgteDApIC0gMSkgLyAoYmFzZV4oeDEteDApIC0gMSkgYCwgaXMgZXF1aXZhbGVudCwgYnV0IHJlcXVpcmVzIGZld2VyXG4gKiBleHBlbnNpdmUgYE1hdGgucG93KClgIG9wZXJhdGlvbnMuKVxuICpcbiAqIEBwcml2YXRlXG4qL1xuZnVuY3Rpb24gZXhwb25lbnRpYWxJbnRlcnBvbGF0aW9uKGlucHV0LCBiYXNlLCBsb3dlclZhbHVlLCB1cHBlclZhbHVlKSB7XG4gICAgY29uc3QgZGlmZmVyZW5jZSA9IHVwcGVyVmFsdWUgLSBsb3dlclZhbHVlO1xuICAgIGNvbnN0IHByb2dyZXNzID0gaW5wdXQgLSBsb3dlclZhbHVlO1xuXG4gICAgaWYgKGRpZmZlcmVuY2UgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIGlmIChiYXNlID09PSAxKSB7XG4gICAgICAgIHJldHVybiBwcm9ncmVzcyAvIGRpZmZlcmVuY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIChNYXRoLnBvdyhiYXNlLCBwcm9ncmVzcykgLSAxKSAvIChNYXRoLnBvdyhiYXNlLCBkaWZmZXJlbmNlKSAtIDEpO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDdXJ2ZTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBzdG9wIDw9IGlucHV0LCBvciAwIGlmIGl0IGRvZXNuJ3QgZXhpc3QuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBmaW5kU3RvcExlc3NUaGFuT3JFcXVhbFRvKHN0b3BzLCBpbnB1dCkge1xuICAgIGNvbnN0IG4gPSBzdG9wcy5sZW5ndGg7XG4gICAgbGV0IGxvd2VySW5kZXggPSAwO1xuICAgIGxldCB1cHBlckluZGV4ID0gbiAtIDE7XG4gICAgbGV0IGN1cnJlbnRJbmRleCA9IDA7XG4gICAgbGV0IGN1cnJlbnRWYWx1ZSwgdXBwZXJWYWx1ZTtcblxuICAgIHdoaWxlIChsb3dlckluZGV4IDw9IHVwcGVySW5kZXgpIHtcbiAgICAgICAgY3VycmVudEluZGV4ID0gTWF0aC5mbG9vcigobG93ZXJJbmRleCArIHVwcGVySW5kZXgpIC8gMik7XG4gICAgICAgIGN1cnJlbnRWYWx1ZSA9IHN0b3BzW2N1cnJlbnRJbmRleF07XG4gICAgICAgIHVwcGVyVmFsdWUgPSBzdG9wc1tjdXJyZW50SW5kZXggKyAxXTtcbiAgICAgICAgaWYgKGlucHV0ID09PSBjdXJyZW50VmFsdWUgfHwgaW5wdXQgPiBjdXJyZW50VmFsdWUgJiYgaW5wdXQgPCB1cHBlclZhbHVlKSB7IC8vIFNlYXJjaCBjb21wbGV0ZVxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRJbmRleDtcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50VmFsdWUgPCBpbnB1dCkge1xuICAgICAgICAgICAgbG93ZXJJbmRleCA9IGN1cnJlbnRJbmRleCArIDE7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFZhbHVlID4gaW5wdXQpIHtcbiAgICAgICAgICAgIHVwcGVySW5kZXggPSBjdXJyZW50SW5kZXggLSAxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGgubWF4KGN1cnJlbnRJbmRleCAtIDEsIDApO1xufVxuIiwiLy8gICAgICBcblxuY29uc3Qge1xuICAgIE51bGxUeXBlLFxuICAgIE51bWJlclR5cGUsXG4gICAgU3RyaW5nVHlwZSxcbiAgICBCb29sZWFuVHlwZSxcbiAgICBDb2xvclR5cGUsXG4gICAgT2JqZWN0VHlwZSxcbiAgICBWYWx1ZVR5cGUsXG4gICAgRXJyb3JUeXBlLFxuICAgIGFycmF5LFxuICAgIHRvU3RyaW5nXG59ID0gcmVxdWlyZSgnLi4vdHlwZXMnKTtcblxuY29uc3QgeyB0eXBlT2YsIENvbG9yLCB2YWxpZGF0ZVJHQkEgfSA9IHJlcXVpcmUoJy4uL3ZhbHVlcycpO1xuY29uc3QgeyBDb21wb3VuZEV4cHJlc3Npb24sIHZhcmFyZ3MgfSA9IHJlcXVpcmUoJy4uL2NvbXBvdW5kX2V4cHJlc3Npb24nKTtcbmNvbnN0IFJ1bnRpbWVFcnJvciA9IHJlcXVpcmUoJy4uL3J1bnRpbWVfZXJyb3InKTtcbmNvbnN0IExldCA9IHJlcXVpcmUoJy4vbGV0Jyk7XG5jb25zdCBWYXIgPSByZXF1aXJlKCcuL3ZhcicpO1xuY29uc3QgTGl0ZXJhbCA9IHJlcXVpcmUoJy4vbGl0ZXJhbCcpO1xuY29uc3QgQXNzZXJ0aW9uID0gcmVxdWlyZSgnLi9hc3NlcnRpb24nKTtcbmNvbnN0IEFycmF5QXNzZXJ0aW9uID0gcmVxdWlyZSgnLi9hcnJheScpO1xuY29uc3QgQ29lcmNpb24gPSByZXF1aXJlKCcuL2NvZXJjaW9uJyk7XG5jb25zdCBBdCA9IHJlcXVpcmUoJy4vYXQnKTtcbmNvbnN0IE1hdGNoID0gcmVxdWlyZSgnLi9tYXRjaCcpO1xuY29uc3QgQ2FzZSA9IHJlcXVpcmUoJy4vY2FzZScpO1xuY29uc3QgQ3VydmUgPSByZXF1aXJlKCcuL2N1cnZlJyk7XG5jb25zdCBDb2FsZXNjZSA9IHJlcXVpcmUoJy4vY29hbGVzY2UnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5cbmNvbnN0IGV4cHJlc3Npb25zICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0ge1xuICAgIC8vIHNwZWNpYWwgZm9ybXNcbiAgICAnbGV0JzogTGV0LFxuICAgICd2YXInOiBWYXIsXG4gICAgJ2xpdGVyYWwnOiBMaXRlcmFsLFxuICAgICdzdHJpbmcnOiBBc3NlcnRpb24sXG4gICAgJ251bWJlcic6IEFzc2VydGlvbixcbiAgICAnYm9vbGVhbic6IEFzc2VydGlvbixcbiAgICAnb2JqZWN0JzogQXNzZXJ0aW9uLFxuICAgICdhcnJheSc6IEFycmF5QXNzZXJ0aW9uLFxuICAgICd0by1udW1iZXInOiBDb2VyY2lvbixcbiAgICAndG8tY29sb3InOiBDb2VyY2lvbixcbiAgICAnYXQnOiBBdCxcbiAgICAnY2FzZSc6IENhc2UsXG4gICAgJ21hdGNoJzogTWF0Y2gsXG4gICAgJ2NvYWxlc2NlJzogQ29hbGVzY2UsXG4gICAgJ2N1cnZlJzogQ3VydmUsXG59O1xuXG5mdW5jdGlvbiByZ2JhKGN0eCwgW3IsIGcsIGIsIGFdKSB7XG4gICAgciA9IHIuZXZhbHVhdGUoY3R4KTtcbiAgICBnID0gZy5ldmFsdWF0ZShjdHgpO1xuICAgIGIgPSBiLmV2YWx1YXRlKGN0eCk7XG4gICAgYSA9IGEgJiYgYS5ldmFsdWF0ZShjdHgpO1xuICAgIGNvbnN0IGVycm9yID0gdmFsaWRhdGVSR0JBKHIsIGcsIGIsIGEpO1xuICAgIGlmIChlcnJvcikgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcihlcnJvcik7XG4gICAgcmV0dXJuIG5ldyBDb2xvcihyIC8gMjU1LCBnIC8gMjU1LCBiIC8gMjU1LCBhKTtcbn1cblxuZnVuY3Rpb24gaGFzKGtleSwgb2JqKSB7XG4gICAgcmV0dXJuIGtleSBpbiBvYmo7XG59XG5cbmZ1bmN0aW9uIGdldChrZXksIG9iaikge1xuICAgIGNvbnN0IHYgPSBvYmpba2V5XTtcbiAgICByZXR1cm4gdHlwZW9mIHYgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHY7XG59XG5cbmZ1bmN0aW9uIGxlbmd0aChjdHgsIFt2XSkge1xuICAgIHJldHVybiB2LmV2YWx1YXRlKGN0eCkubGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBlcShjdHgsIFthLCBiXSkgeyByZXR1cm4gYS5ldmFsdWF0ZShjdHgpID09PSBiLmV2YWx1YXRlKGN0eCk7IH1cbmZ1bmN0aW9uIG5lKGN0eCwgW2EsIGJdKSB7IHJldHVybiBhLmV2YWx1YXRlKGN0eCkgIT09IGIuZXZhbHVhdGUoY3R4KTsgfVxuZnVuY3Rpb24gbHQoY3R4LCBbYSwgYl0pIHsgcmV0dXJuIGEuZXZhbHVhdGUoY3R4KSA8IGIuZXZhbHVhdGUoY3R4KTsgfVxuZnVuY3Rpb24gZ3QoY3R4LCBbYSwgYl0pIHsgcmV0dXJuIGEuZXZhbHVhdGUoY3R4KSA+IGIuZXZhbHVhdGUoY3R4KTsgfVxuZnVuY3Rpb24gbHRlcShjdHgsIFthLCBiXSkgeyByZXR1cm4gYS5ldmFsdWF0ZShjdHgpIDw9IGIuZXZhbHVhdGUoY3R4KTsgfVxuZnVuY3Rpb24gZ3RlcShjdHgsIFthLCBiXSkgeyByZXR1cm4gYS5ldmFsdWF0ZShjdHgpID49IGIuZXZhbHVhdGUoY3R4KTsgfVxuXG5Db21wb3VuZEV4cHJlc3Npb24ucmVnaXN0ZXIoZXhwcmVzc2lvbnMsIHtcbiAgICAnZXJyb3InOiBbXG4gICAgICAgIEVycm9yVHlwZSxcbiAgICAgICAgW1N0cmluZ1R5cGVdLFxuICAgICAgICAoY3R4LCBbdl0pID0+IHsgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcih2LmV2YWx1YXRlKGN0eCkpOyB9XG4gICAgXSxcbiAgICAndHlwZW9mJzogW1xuICAgICAgICBTdHJpbmdUeXBlLFxuICAgICAgICBbVmFsdWVUeXBlXSxcbiAgICAgICAgKGN0eCwgW3ZdKSA9PiB0b1N0cmluZyh0eXBlT2Yodi5ldmFsdWF0ZShjdHgpKSlcbiAgICBdLFxuICAgICd0by1zdHJpbmcnOiBbXG4gICAgICAgIFN0cmluZ1R5cGUsXG4gICAgICAgIFtWYWx1ZVR5cGVdLFxuICAgICAgICAoY3R4LCBbdl0pID0+IHtcbiAgICAgICAgICAgIHYgPSB2LmV2YWx1YXRlKGN0eCk7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gdHlwZW9mIHY7XG4gICAgICAgICAgICBpZiAodiA9PT0gbnVsbCB8fCB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlID09PSAnbnVtYmVyJyB8fCB0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nKHYpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2IGluc3RhbmNlb2YgQ29sb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbciwgZywgYiwgYV0gPSB2LnZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBgcmdiYSgke3IgKiAyNTV9LCAke2cgKiAyNTV9LCAke2IgKiAyNTV9LCAke2F9KWA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ3RvLWJvb2xlYW4nOiBbXG4gICAgICAgIEJvb2xlYW5UeXBlLFxuICAgICAgICBbVmFsdWVUeXBlXSxcbiAgICAgICAgKGN0eCwgW3ZdKSA9PiBCb29sZWFuKHYuZXZhbHVhdGUoY3R4KSlcbiAgICBdLFxuICAgICd0by1yZ2JhJzogW1xuICAgICAgICBhcnJheShOdW1iZXJUeXBlLCA0KSxcbiAgICAgICAgW0NvbG9yVHlwZV0sXG4gICAgICAgIChjdHgsIFt2XSkgPT4gdi5ldmFsdWF0ZShjdHgpLnZhbHVlXG4gICAgXSxcbiAgICAncmdiJzogW1xuICAgICAgICBDb2xvclR5cGUsXG4gICAgICAgIFtOdW1iZXJUeXBlLCBOdW1iZXJUeXBlLCBOdW1iZXJUeXBlXSxcbiAgICAgICAgcmdiYVxuICAgIF0sXG4gICAgJ3JnYmEnOiBbXG4gICAgICAgIENvbG9yVHlwZSxcbiAgICAgICAgW051bWJlclR5cGUsIE51bWJlclR5cGUsIE51bWJlclR5cGUsIE51bWJlclR5cGVdLFxuICAgICAgICByZ2JhXG4gICAgXSxcbiAgICAnbGVuZ3RoJzoge1xuICAgICAgICB0eXBlOiBOdW1iZXJUeXBlLFxuICAgICAgICBvdmVybG9hZHM6IFtcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBbU3RyaW5nVHlwZV0sXG4gICAgICAgICAgICAgICAgbGVuZ3RoXG4gICAgICAgICAgICBdLCBbXG4gICAgICAgICAgICAgICAgW2FycmF5KFZhbHVlVHlwZSldLFxuICAgICAgICAgICAgICAgIGxlbmd0aFxuICAgICAgICAgICAgXVxuICAgICAgICBdXG4gICAgfSxcbiAgICAnaGFzJzoge1xuICAgICAgICB0eXBlOiBCb29sZWFuVHlwZSxcbiAgICAgICAgb3ZlcmxvYWRzOiBbXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgW1N0cmluZ1R5cGVdLFxuICAgICAgICAgICAgICAgIChjdHgsIFtrZXldKSA9PiBoYXMoa2V5LmV2YWx1YXRlKGN0eCksIGN0eC5wcm9wZXJ0aWVzKCkpXG4gICAgICAgICAgICBdLCBbXG4gICAgICAgICAgICAgICAgW1N0cmluZ1R5cGUsIE9iamVjdFR5cGVdLFxuICAgICAgICAgICAgICAgIChjdHgsIFtrZXksIG9ial0pID0+IGhhcyhrZXkuZXZhbHVhdGUoY3R4KSwgb2JqLmV2YWx1YXRlKGN0eCkpXG4gICAgICAgICAgICBdXG4gICAgICAgIF1cbiAgICB9LFxuICAgICdnZXQnOiB7XG4gICAgICAgIHR5cGU6IFZhbHVlVHlwZSxcbiAgICAgICAgb3ZlcmxvYWRzOiBbXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgW1N0cmluZ1R5cGVdLFxuICAgICAgICAgICAgICAgIChjdHgsIFtrZXldKSA9PiBnZXQoa2V5LmV2YWx1YXRlKGN0eCksIGN0eC5wcm9wZXJ0aWVzKCkpXG4gICAgICAgICAgICBdLCBbXG4gICAgICAgICAgICAgICAgW1N0cmluZ1R5cGUsIE9iamVjdFR5cGVdLFxuICAgICAgICAgICAgICAgIChjdHgsIFtrZXksIG9ial0pID0+IGdldChrZXkuZXZhbHVhdGUoY3R4KSwgb2JqLmV2YWx1YXRlKGN0eCkpXG4gICAgICAgICAgICBdXG4gICAgICAgIF1cbiAgICB9LFxuICAgICdwcm9wZXJ0aWVzJzogW1xuICAgICAgICBPYmplY3RUeXBlLFxuICAgICAgICBbXSxcbiAgICAgICAgKGN0eCkgPT4gY3R4LnByb3BlcnRpZXMoKVxuICAgIF0sXG4gICAgJ2dlb21ldHJ5LXR5cGUnOiBbXG4gICAgICAgIFN0cmluZ1R5cGUsXG4gICAgICAgIFtdLFxuICAgICAgICAoY3R4KSA9PiBjdHguZ2VvbWV0cnlUeXBlKClcbiAgICBdLFxuICAgICdpZCc6IFtcbiAgICAgICAgVmFsdWVUeXBlLFxuICAgICAgICBbXSxcbiAgICAgICAgKGN0eCkgPT4gY3R4LmlkKClcbiAgICBdLFxuICAgICd6b29tJzogW1xuICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICBbXSxcbiAgICAgICAgKGN0eCkgPT4gY3R4Lmdsb2JhbHMuem9vbVxuICAgIF0sXG4gICAgJ2hlYXRtYXAtZGVuc2l0eSc6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgW10sXG4gICAgICAgIChjdHgpID0+IGN0eC5nbG9iYWxzLmhlYXRtYXBEZW5zaXR5IHx8IDBcbiAgICBdLFxuICAgICcrJzogW1xuICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICB2YXJhcmdzKE51bWJlclR5cGUpLFxuICAgICAgICAoY3R4LCBhcmdzKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYXJnIG9mIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gYXJnLmV2YWx1YXRlKGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnKic6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgdmFyYXJncyhOdW1iZXJUeXBlKSxcbiAgICAgICAgKGN0eCwgYXJncykgPT4ge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IDE7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFyZyBvZiBhcmdzKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICo9IGFyZy5ldmFsdWF0ZShjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJy0nOiB7XG4gICAgICAgIHR5cGU6IE51bWJlclR5cGUsXG4gICAgICAgIG92ZXJsb2FkczogW1xuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFtOdW1iZXJUeXBlLCBOdW1iZXJUeXBlXSxcbiAgICAgICAgICAgICAgICAoY3R4LCBbYSwgYl0pID0+IGEuZXZhbHVhdGUoY3R4KSAtIGIuZXZhbHVhdGUoY3R4KVxuICAgICAgICAgICAgXSwgW1xuICAgICAgICAgICAgICAgIFtOdW1iZXJUeXBlXSxcbiAgICAgICAgICAgICAgICAoY3R4LCBbYV0pID0+IC1hLmV2YWx1YXRlKGN0eClcbiAgICAgICAgICAgIF1cbiAgICAgICAgXVxuICAgIH0sXG4gICAgJy8nOiBbXG4gICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgIFtOdW1iZXJUeXBlLCBOdW1iZXJUeXBlXSxcbiAgICAgICAgKGN0eCwgW2EsIGJdKSA9PiBhLmV2YWx1YXRlKGN0eCkgLyBiLmV2YWx1YXRlKGN0eClcbiAgICBdLFxuICAgICclJzogW1xuICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICBbTnVtYmVyVHlwZSwgTnVtYmVyVHlwZV0sXG4gICAgICAgIChjdHgsIFthLCBiXSkgPT4gYS5ldmFsdWF0ZShjdHgpICUgYi5ldmFsdWF0ZShjdHgpXG4gICAgXSxcbiAgICAnbG4yJzogW1xuICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICBbXSxcbiAgICAgICAgKCkgPT4gTWF0aC5MTjJcbiAgICBdLFxuICAgICdwaSc6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgW10sXG4gICAgICAgICgpID0+IE1hdGguUElcbiAgICBdLFxuICAgICdlJzogW1xuICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICBbXSxcbiAgICAgICAgKCkgPT4gTWF0aC5FXG4gICAgXSxcbiAgICAnXic6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgW051bWJlclR5cGUsIE51bWJlclR5cGVdLFxuICAgICAgICAoY3R4LCBbYiwgZV0pID0+IE1hdGgucG93KGIuZXZhbHVhdGUoY3R4KSwgZS5ldmFsdWF0ZShjdHgpKVxuICAgIF0sXG4gICAgJ2xvZzEwJzogW1xuICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICBbTnVtYmVyVHlwZV0sXG4gICAgICAgIChjdHgsIFtuXSkgPT4gTWF0aC5sb2cxMChuLmV2YWx1YXRlKGN0eCkpXG4gICAgXSxcbiAgICAnbG4nOiBbXG4gICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgIFtOdW1iZXJUeXBlXSxcbiAgICAgICAgKGN0eCwgW25dKSA9PiBNYXRoLmxvZyhuLmV2YWx1YXRlKGN0eCkpXG4gICAgXSxcbiAgICAnbG9nMic6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgW051bWJlclR5cGVdLFxuICAgICAgICAoY3R4LCBbbl0pID0+IE1hdGgubG9nMihuLmV2YWx1YXRlKGN0eCkpXG4gICAgXSxcbiAgICAnc2luJzogW1xuICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICBbTnVtYmVyVHlwZV0sXG4gICAgICAgIChjdHgsIFtuXSkgPT4gTWF0aC5zaW4obi5ldmFsdWF0ZShjdHgpKVxuICAgIF0sXG4gICAgJ2Nvcyc6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgW051bWJlclR5cGVdLFxuICAgICAgICAoY3R4LCBbbl0pID0+IE1hdGguY29zKG4uZXZhbHVhdGUoY3R4KSlcbiAgICBdLFxuICAgICd0YW4nOiBbXG4gICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgIFtOdW1iZXJUeXBlXSxcbiAgICAgICAgKGN0eCwgW25dKSA9PiBNYXRoLnRhbihuLmV2YWx1YXRlKGN0eCkpXG4gICAgXSxcbiAgICAnYXNpbic6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgW051bWJlclR5cGVdLFxuICAgICAgICAoY3R4LCBbbl0pID0+IE1hdGguYXNpbihuLmV2YWx1YXRlKGN0eCkpXG4gICAgXSxcbiAgICAnYWNvcyc6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgW051bWJlclR5cGVdLFxuICAgICAgICAoY3R4LCBbbl0pID0+IE1hdGguYWNvcyhuLmV2YWx1YXRlKGN0eCkpXG4gICAgXSxcbiAgICAnYXRhbic6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgW051bWJlclR5cGVdLFxuICAgICAgICAoY3R4LCBbbl0pID0+IE1hdGguYXRhbihuLmV2YWx1YXRlKGN0eCkpXG4gICAgXSxcbiAgICAnbWluJzogW1xuICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICB2YXJhcmdzKE51bWJlclR5cGUpLFxuICAgICAgICAoY3R4LCBhcmdzKSA9PiBNYXRoLm1pbiguLi5hcmdzLm1hcChhcmcgPT4gYXJnLmV2YWx1YXRlKGN0eCkpKVxuICAgIF0sXG4gICAgJ21heCc6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgdmFyYXJncyhOdW1iZXJUeXBlKSxcbiAgICAgICAgKGN0eCwgYXJncykgPT4gTWF0aC5tYXgoLi4uYXJncy5tYXAoYXJnID0+IGFyZy5ldmFsdWF0ZShjdHgpKSlcbiAgICBdLFxuICAgICc9PSc6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhblR5cGUsXG4gICAgICAgIG92ZXJsb2FkczogW1xuICAgICAgICAgICAgW1tOdW1iZXJUeXBlLCBOdW1iZXJUeXBlXSwgZXFdLFxuICAgICAgICAgICAgW1tTdHJpbmdUeXBlLCBTdHJpbmdUeXBlXSwgZXFdLFxuICAgICAgICAgICAgW1tCb29sZWFuVHlwZSwgQm9vbGVhblR5cGVdLCBlcV0sXG4gICAgICAgICAgICBbW051bGxUeXBlLCBOdWxsVHlwZV0sIGVxXVxuICAgICAgICBdXG4gICAgfSxcbiAgICAnIT0nOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW5UeXBlLFxuICAgICAgICBvdmVybG9hZHM6IFtcbiAgICAgICAgICAgIFtbTnVtYmVyVHlwZSwgTnVtYmVyVHlwZV0sIG5lXSxcbiAgICAgICAgICAgIFtbU3RyaW5nVHlwZSwgU3RyaW5nVHlwZV0sIG5lXSxcbiAgICAgICAgICAgIFtbQm9vbGVhblR5cGUsIEJvb2xlYW5UeXBlXSwgbmVdLFxuICAgICAgICAgICAgW1tOdWxsVHlwZSwgTnVsbFR5cGVdLCBuZV1cbiAgICAgICAgXVxuICAgIH0sXG4gICAgJz4nOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW5UeXBlLFxuICAgICAgICBvdmVybG9hZHM6IFtcbiAgICAgICAgICAgIFtbTnVtYmVyVHlwZSwgTnVtYmVyVHlwZV0sIGd0XSxcbiAgICAgICAgICAgIFtbU3RyaW5nVHlwZSwgU3RyaW5nVHlwZV0sIGd0XVxuICAgICAgICBdXG4gICAgfSxcbiAgICAnPCc6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhblR5cGUsXG4gICAgICAgIG92ZXJsb2FkczogW1xuICAgICAgICAgICAgW1tOdW1iZXJUeXBlLCBOdW1iZXJUeXBlXSwgbHRdLFxuICAgICAgICAgICAgW1tTdHJpbmdUeXBlLCBTdHJpbmdUeXBlXSwgbHRdXG4gICAgICAgIF1cbiAgICB9LFxuICAgICc+PSc6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhblR5cGUsXG4gICAgICAgIG92ZXJsb2FkczogW1xuICAgICAgICAgICAgW1tOdW1iZXJUeXBlLCBOdW1iZXJUeXBlXSwgZ3RlcV0sXG4gICAgICAgICAgICBbW1N0cmluZ1R5cGUsIFN0cmluZ1R5cGVdLCBndGVxXVxuICAgICAgICBdXG4gICAgfSxcbiAgICAnPD0nOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW5UeXBlLFxuICAgICAgICBvdmVybG9hZHM6IFtcbiAgICAgICAgICAgIFtbTnVtYmVyVHlwZSwgTnVtYmVyVHlwZV0sIGx0ZXFdLFxuICAgICAgICAgICAgW1tTdHJpbmdUeXBlLCBTdHJpbmdUeXBlXSwgbHRlcV1cbiAgICAgICAgXVxuICAgIH0sXG4gICAgJ2FsbCc6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhblR5cGUsXG4gICAgICAgIG92ZXJsb2FkczogW1xuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFtCb29sZWFuVHlwZSwgQm9vbGVhblR5cGVdLFxuICAgICAgICAgICAgICAgIChjdHgsIFthLCBiXSkgPT4gYS5ldmFsdWF0ZShjdHgpICYmIGIuZXZhbHVhdGUoY3R4KVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICB2YXJhcmdzKEJvb2xlYW5UeXBlKSxcbiAgICAgICAgICAgICAgICAoY3R4LCBhcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYXJnIG9mIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYXJnLmV2YWx1YXRlKGN0eCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgXVxuICAgIH0sXG4gICAgJ2FueSc6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhblR5cGUsXG4gICAgICAgIG92ZXJsb2FkczogW1xuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFtCb29sZWFuVHlwZSwgQm9vbGVhblR5cGVdLFxuICAgICAgICAgICAgICAgIChjdHgsIFthLCBiXSkgPT4gYS5ldmFsdWF0ZShjdHgpIHx8IGIuZXZhbHVhdGUoY3R4KVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICB2YXJhcmdzKEJvb2xlYW5UeXBlKSxcbiAgICAgICAgICAgICAgICAoY3R4LCBhcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYXJnIG9mIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmcuZXZhbHVhdGUoY3R4KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICBdXG4gICAgfSxcbiAgICAnISc6IFtcbiAgICAgICAgQm9vbGVhblR5cGUsXG4gICAgICAgIFtCb29sZWFuVHlwZV0sXG4gICAgICAgIChjdHgsIFtiXSkgPT4gIWIuZXZhbHVhdGUoY3R4KVxuICAgIF0sXG4gICAgJ3VwY2FzZSc6IFtcbiAgICAgICAgU3RyaW5nVHlwZSxcbiAgICAgICAgW1N0cmluZ1R5cGVdLFxuICAgICAgICAoY3R4LCBbc10pID0+IHMuZXZhbHVhdGUoY3R4KS50b1VwcGVyQ2FzZSgpXG4gICAgXSxcbiAgICAnZG93bmNhc2UnOiBbXG4gICAgICAgIFN0cmluZ1R5cGUsXG4gICAgICAgIFtTdHJpbmdUeXBlXSxcbiAgICAgICAgKGN0eCwgW3NdKSA9PiBzLmV2YWx1YXRlKGN0eCkudG9Mb3dlckNhc2UoKVxuICAgIF0sXG4gICAgJ2NvbmNhdCc6IFtcbiAgICAgICAgU3RyaW5nVHlwZSxcbiAgICAgICAgdmFyYXJncyhTdHJpbmdUeXBlKSxcbiAgICAgICAgKGN0eCwgYXJncykgPT4gYXJncy5tYXAoYXJnID0+IGFyZy5ldmFsdWF0ZShjdHgpKS5qb2luKCcnKVxuICAgIF1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cHJlc3Npb25zO1xuIiwiLy8gICAgICBcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5cbmNsYXNzIExldCAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgXG5cbiAgICBjb25zdHJ1Y3RvcihrZXkgICAgICAgICwgYmluZGluZ3MgICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgcmVzdWx0ICAgICAgICAgICAgKSB7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnR5cGUgPSByZXN1bHQudHlwZTtcbiAgICAgICAgdGhpcy5iaW5kaW5ncyA9IFtdLmNvbmNhdChiaW5kaW5ncyk7XG4gICAgICAgIHRoaXMucmVzdWx0ID0gcmVzdWx0O1xuICAgIH1cblxuICAgIGV2YWx1YXRlKGN0eCAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgY3R4LnB1c2hTY29wZSh0aGlzLmJpbmRpbmdzKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5yZXN1bHQuZXZhbHVhdGUoY3R4KTtcbiAgICAgICAgY3R4LnBvcFNjb3BlKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZWFjaENoaWxkKGZuICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICBmb3IgKGNvbnN0IGJpbmRpbmcgb2YgdGhpcy5iaW5kaW5ncykge1xuICAgICAgICAgICAgZm4oYmluZGluZ1sxXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm4odGhpcy5yZXN1bHQpO1xuICAgIH1cblxuICAgIHN0YXRpYyBwYXJzZShhcmdzICAgICAgICAgICAgICAsIGNvbnRleHQgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA8IDQpXG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihgRXhwZWN0ZWQgYXQgbGVhc3QgMyBhcmd1bWVudHMsIGJ1dCBmb3VuZCAke2FyZ3MubGVuZ3RoIC0gMX0gaW5zdGVhZC5gKTtcblxuICAgICAgICBjb25zdCBiaW5kaW5ncyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYXJncy5sZW5ndGggLSAxOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBhcmdzW2ldO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoYEV4cGVjdGVkIHN0cmluZywgYnV0IGZvdW5kICR7dHlwZW9mIG5hbWV9IGluc3RlYWQuYCwgaSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgvW15hLXpBLVowLTlfXS8udGVzdChuYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKGBWYXJpYWJsZSBuYW1lcyBtdXN0IGNvbnRhaW4gb25seSBhbHBoYW51bWVyaWMgY2hhcmFjdGVycyBvciAnXycuYCwgaSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY29udGV4dC5wYXJzZShhcmdzW2kgKyAxXSwgaSArIDEpO1xuICAgICAgICAgICAgaWYgKCF2YWx1ZSkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICAgIGJpbmRpbmdzLnB1c2goW25hbWUsIHZhbHVlXSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSBjb250ZXh0LnBhcnNlKGFyZ3NbYXJncy5sZW5ndGggLSAxXSwgYXJncy5sZW5ndGggLSAxLCB1bmRlZmluZWQsIGJpbmRpbmdzKTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHJldHVybiBudWxsO1xuXG4gICAgICAgIHJldHVybiBuZXcgTGV0KGNvbnRleHQua2V5LCBiaW5kaW5ncywgcmVzdWx0KTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTGV0O1xuIiwiLy8gICAgICBcblxuY29uc3QgeyBpc1ZhbHVlLCB0eXBlT2YgfSA9IHJlcXVpcmUoJy4uL3ZhbHVlcycpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5cbmNsYXNzIExpdGVyYWwgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICBcblxuICAgIGNvbnN0cnVjdG9yKGtleSAgICwgdHlwZSAgICAgICwgdmFsdWUgICAgICAgKSB7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgc3RhdGljIHBhcnNlKGFyZ3MgICAgICAgICAgICAgICwgY29udGV4dCAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAyKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoYCdsaXRlcmFsJyBleHByZXNzaW9uIHJlcXVpcmVzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBidXQgZm91bmQgJHthcmdzLmxlbmd0aCAtIDF9IGluc3RlYWQuYCk7XG5cbiAgICAgICAgaWYgKCFpc1ZhbHVlKGFyZ3NbMV0pKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoYGludmFsaWQgdmFsdWVgKTtcblxuICAgICAgICBjb25zdCB2YWx1ZSA9IChhcmdzWzFdICAgICApO1xuICAgICAgICBsZXQgdHlwZSA9IHR5cGVPZih2YWx1ZSk7XG5cbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlOiBpbmZlciB0aGUgaXRlbSB0eXBlIGlmIHBvc3NpYmxlIGZvciB6ZXJvLWxlbmd0aCBhcnJheXNcbiAgICAgICAgY29uc3QgZXhwZWN0ZWQgPSBjb250ZXh0LmV4cGVjdGVkVHlwZTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdHlwZS5raW5kID09PSAnYXJyYXknICYmXG4gICAgICAgICAgICB0eXBlLk4gPT09IDAgJiZcbiAgICAgICAgICAgIGV4cGVjdGVkICYmXG4gICAgICAgICAgICBleHBlY3RlZC5raW5kID09PSAnYXJyYXknICYmXG4gICAgICAgICAgICAodHlwZW9mIGV4cGVjdGVkLk4gIT09ICdudW1iZXInIHx8IGV4cGVjdGVkLk4gPT09IDApXG4gICAgICAgICkge1xuICAgICAgICAgICAgdHlwZSA9IGV4cGVjdGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsKGNvbnRleHQua2V5LCB0eXBlLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgZXZhbHVhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cblxuICAgIGVhY2hDaGlsZCgpIHt9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTGl0ZXJhbDtcbiIsIi8vICAgICAgXG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuY29uc3QgeyB0eXBlT2YgfSA9IHJlcXVpcmUoJy4uL3ZhbHVlcycpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuXG4vLyBNYXAgaW5wdXQgbGFiZWwgdmFsdWVzIHRvIG91dHB1dCBleHByZXNzaW9uIGluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuXG5jbGFzcyBNYXRjaCAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIFxuXG4gICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcblxuICAgIGNvbnN0cnVjdG9yKGtleSAgICAgICAgLCBpbnB1dFR5cGUgICAgICAsIG91dHB1dFR5cGUgICAgICAsIGlucHV0ICAgICAgICAgICAgLCBjYXNlcyAgICAgICAsIG91dHB1dHMgICAgICAgICAgICAgICAgICAgLCBvdGhlcndpc2UgICAgICAgICAgICApIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMuaW5wdXRUeXBlID0gaW5wdXRUeXBlO1xuICAgICAgICB0aGlzLnR5cGUgPSBvdXRwdXRUeXBlO1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMuY2FzZXMgPSBjYXNlcztcbiAgICAgICAgdGhpcy5vdXRwdXRzID0gb3V0cHV0cztcbiAgICAgICAgdGhpcy5vdGhlcndpc2UgPSBvdGhlcndpc2U7XG4gICAgfVxuXG4gICAgc3RhdGljIHBhcnNlKGFyZ3MgICAgICAgICAgICAgICwgY29udGV4dCAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDwgNSlcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKGBFeHBlY3RlZCBhdCBsZWFzdCA0IGFyZ3VtZW50cywgYnV0IGZvdW5kIG9ubHkgJHthcmdzLmxlbmd0aCAtIDF9LmApO1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggJSAyICE9PSAxKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoYEV4cGVjdGVkIGFuIGV2ZW4gbnVtYmVyIG9mIGFyZ3VtZW50cy5gKTtcblxuICAgICAgICBsZXQgaW5wdXRUeXBlO1xuICAgICAgICBsZXQgb3V0cHV0VHlwZTtcbiAgICAgICAgaWYgKGNvbnRleHQuZXhwZWN0ZWRUeXBlICYmIGNvbnRleHQuZXhwZWN0ZWRUeXBlLmtpbmQgIT09ICd2YWx1ZScpIHtcbiAgICAgICAgICAgIG91dHB1dFR5cGUgPSBjb250ZXh0LmV4cGVjdGVkVHlwZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYXNlcyA9IHt9O1xuICAgICAgICBjb25zdCBvdXRwdXRzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAyOyBpIDwgYXJncy5sZW5ndGggLSAxOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGxldCBsYWJlbHMgPSBhcmdzW2ldO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhcmdzW2kgKyAxXTtcblxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGxhYmVscykpIHtcbiAgICAgICAgICAgICAgICBsYWJlbHMgPSBbbGFiZWxzXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbGFiZWxDb250ZXh0ID0gY29udGV4dC5jb25jYXQoaSk7XG4gICAgICAgICAgICBpZiAobGFiZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsYWJlbENvbnRleHQuZXJyb3IoJ0V4cGVjdGVkIGF0IGxlYXN0IG9uZSBicmFuY2ggbGFiZWwuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgbGFiZWwgb2YgbGFiZWxzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsYWJlbCAhPT0gJ251bWJlcicgJiYgdHlwZW9mIGxhYmVsICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFiZWxDb250ZXh0LmVycm9yKGBCcmFuY2ggbGFiZWxzIG11c3QgYmUgbnVtYmVycyBvciBzdHJpbmdzLmApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxhYmVsID09PSAnbnVtYmVyJyAmJiBNYXRoLmFicyhsYWJlbCkgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFiZWxDb250ZXh0LmVycm9yKGBCcmFuY2ggbGFiZWxzIG11c3QgYmUgaW50ZWdlcnMgbm8gbGFyZ2VyIHRoYW4gJHtOdW1iZXIuTUFYX1NBRkVfSU5URUdFUn0uYCk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsYWJlbCA9PT0gJ251bWJlcicgJiYgTWF0aC5mbG9vcihsYWJlbCkgIT09IGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsYWJlbENvbnRleHQuZXJyb3IoYE51bWVyaWMgYnJhbmNoIGxhYmVscyBtdXN0IGJlIGludGVnZXIgdmFsdWVzLmApO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghaW5wdXRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0VHlwZSA9IHR5cGVPZihsYWJlbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsYWJlbENvbnRleHQuY2hlY2tTdWJ0eXBlKGlucHV0VHlwZSwgdHlwZU9mKGxhYmVsKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjYXNlc1tTdHJpbmcobGFiZWwpXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsQ29udGV4dC5lcnJvcignQnJhbmNoIGxhYmVscyBtdXN0IGJlIHVuaXF1ZS4nKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjYXNlc1tTdHJpbmcobGFiZWwpXSA9IG91dHB1dHMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjb250ZXh0LnBhcnNlKHZhbHVlLCBpLCBvdXRwdXRUeXBlKTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIG91dHB1dFR5cGUgPSBvdXRwdXRUeXBlIHx8IHJlc3VsdC50eXBlO1xuICAgICAgICAgICAgb3V0cHV0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpbnB1dCA9IGNvbnRleHQucGFyc2UoYXJnc1sxXSwgMSwgaW5wdXRUeXBlKTtcbiAgICAgICAgaWYgKCFpbnB1dCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgY29uc3Qgb3RoZXJ3aXNlID0gY29udGV4dC5wYXJzZShhcmdzW2FyZ3MubGVuZ3RoIC0gMV0sIGFyZ3MubGVuZ3RoIC0gMSwgb3V0cHV0VHlwZSk7XG4gICAgICAgIGlmICghb3RoZXJ3aXNlKSByZXR1cm4gbnVsbDtcblxuICAgICAgICBhc3NlcnQoaW5wdXRUeXBlICYmIG91dHB1dFR5cGUpO1xuICAgICAgICByZXR1cm4gbmV3IE1hdGNoKGNvbnRleHQua2V5LCAoaW5wdXRUeXBlICAgICApLCAob3V0cHV0VHlwZSAgICAgKSwgaW5wdXQsIGNhc2VzLCBvdXRwdXRzLCBvdGhlcndpc2UpO1xuICAgIH1cblxuICAgIGV2YWx1YXRlKGN0eCAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSAodGhpcy5pbnB1dC5ldmFsdWF0ZShjdHgpICAgICApO1xuICAgICAgICByZXR1cm4gKHRoaXMub3V0cHV0c1t0aGlzLmNhc2VzW2lucHV0XV0gfHwgdGhpcy5vdGhlcndpc2UpLmV2YWx1YXRlKGN0eCk7XG4gICAgfVxuXG4gICAgZWFjaENoaWxkKGZuICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICBmbih0aGlzLmlucHV0KTtcbiAgICAgICAgdGhpcy5vdXRwdXRzLmZvckVhY2goZm4pO1xuICAgICAgICBmbih0aGlzLm90aGVyd2lzZSk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGNoO1xuIiwiLy8gICAgICBcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5cbmNsYXNzIFZhciAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgIFxuXG4gICAgY29uc3RydWN0b3Ioa2V5ICAgICAgICAsIG5hbWUgICAgICAgICwgdHlwZSAgICAgICkge1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgcGFyc2UoYXJncyAgICAgICAgICAgICAgLCBjb250ZXh0ICAgICAgICAgICAgICAgICkge1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggIT09IDIgfHwgdHlwZW9mIGFyZ3NbMV0gIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoYCd2YXInIGV4cHJlc3Npb24gcmVxdWlyZXMgZXhhY3RseSBvbmUgc3RyaW5nIGxpdGVyYWwgYXJndW1lbnQuYCk7XG5cbiAgICAgICAgY29uc3QgbmFtZSA9IGFyZ3NbMV07XG4gICAgICAgIGlmICghY29udGV4dC5zY29wZS5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKGBVbmtub3duIHZhcmlhYmxlIFwiJHtuYW1lfVwiLiBNYWtlIHN1cmUgXCIke25hbWV9XCIgaGFzIGJlZW4gYm91bmQgaW4gYW4gZW5jbG9zaW5nIFwibGV0XCIgZXhwcmVzc2lvbiBiZWZvcmUgdXNpbmcgaXQuYCwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFZhcihjb250ZXh0LmtleSwgbmFtZSwgY29udGV4dC5zY29wZS5nZXQobmFtZSkudHlwZSk7XG4gICAgfVxuXG4gICAgZXZhbHVhdGUoY3R4ICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICByZXR1cm4gY3R4LnNjb3BlLmdldCh0aGlzLm5hbWUpLmV2YWx1YXRlKGN0eCk7XG4gICAgfVxuXG4gICAgZWFjaENoaWxkKCkge31cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBWYXI7XG4iLCIvLyAgICAgIFxuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcbmNvbnN0IFNjb3BlID0gcmVxdWlyZSgnLi9zY29wZScpO1xuY29uc3QgcGFyc2VDb2xvciA9IHJlcXVpcmUoJy4uL3V0aWwvcGFyc2VfY29sb3InKTtcbmNvbnN0IHtDb2xvcn0gPSByZXF1aXJlKCcuL3ZhbHVlcycpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5cbmNvbnN0IGdlb21ldHJ5VHlwZXMgPSBbJ1Vua25vd24nLCAnUG9pbnQnLCAnTGluZVN0cmluZycsICdQb2x5Z29uJ107XG5cbmNsYXNzIEV2YWx1YXRpb25Db250ZXh0IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgIFxuXG4gICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnNjb3BlID0gbmV3IFNjb3BlKCk7XG4gICAgICAgIHRoaXMuX3BhcnNlQ29sb3JDYWNoZSA9IHt9O1xuICAgIH1cblxuICAgIGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZWF0dXJlICYmICdpZCcgaW4gdGhpcy5mZWF0dXJlID8gdGhpcy5mZWF0dXJlLmlkIDogbnVsbDtcbiAgICB9XG5cbiAgICBnZW9tZXRyeVR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZlYXR1cmUgPyB0eXBlb2YgdGhpcy5mZWF0dXJlLnR5cGUgPT09ICdudW1iZXInID8gZ2VvbWV0cnlUeXBlc1t0aGlzLmZlYXR1cmUudHlwZV0gOiB0aGlzLmZlYXR1cmUudHlwZSA6IG51bGw7XG4gICAgfVxuXG4gICAgcHJvcGVydGllcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZSAmJiB0aGlzLmZlYXR1cmUucHJvcGVydGllcyB8fCB7fTtcbiAgICB9XG5cbiAgICBwdXNoU2NvcGUoYmluZGluZ3MgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICB0aGlzLnNjb3BlID0gdGhpcy5zY29wZS5jb25jYXQoYmluZGluZ3MpO1xuICAgIH1cblxuICAgIHBvcFNjb3BlKCkge1xuICAgICAgICBhc3NlcnQodGhpcy5zY29wZS5wYXJlbnQpO1xuICAgICAgICB0aGlzLnNjb3BlID0gKHRoaXMuc2NvcGUucGFyZW50ICAgICApO1xuICAgIH1cblxuICAgIHBhcnNlQ29sb3IoaW5wdXQgICAgICAgICkgICAgICAgICB7XG4gICAgICAgIGxldCBjYWNoZWQgPSB0aGlzLl9wYXJzZUNvbG9yQ2FjaGVbaW5wdXRdO1xuICAgICAgICBpZiAoIWNhY2hlZCkge1xuICAgICAgICAgICAgY29uc3QgYyA9IHBhcnNlQ29sb3IoaW5wdXQpO1xuICAgICAgICAgICAgY2FjaGVkID0gdGhpcy5fcGFyc2VDb2xvckNhY2hlW2lucHV0XSA9IGMgPyBuZXcgQ29sb3IoY1swXSwgY1sxXSwgY1syXSwgY1szXSkgOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEV2YWx1YXRpb25Db250ZXh0O1xuIiwiLy8gICAgICBcblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5jb25zdCBQYXJzaW5nRXJyb3IgPSByZXF1aXJlKCcuL3BhcnNpbmdfZXJyb3InKTtcbmNvbnN0IFBhcnNpbmdDb250ZXh0ID0gcmVxdWlyZSgnLi9wYXJzaW5nX2NvbnRleHQnKTtcbmNvbnN0IEV2YWx1YXRpb25Db250ZXh0ID0gcmVxdWlyZSgnLi9ldmFsdWF0aW9uX2NvbnRleHQnKTtcbmNvbnN0IHtDb21wb3VuZEV4cHJlc3Npb259ID0gcmVxdWlyZSgnLi9jb21wb3VuZF9leHByZXNzaW9uJyk7XG5jb25zdCBDdXJ2ZSA9IHJlcXVpcmUoJy4vZGVmaW5pdGlvbnMvY3VydmUnKTtcbmNvbnN0IENvYWxlc2NlID0gcmVxdWlyZSgnLi9kZWZpbml0aW9ucy9jb2FsZXNjZScpO1xuY29uc3QgTGV0ID0gcmVxdWlyZSgnLi9kZWZpbml0aW9ucy9sZXQnKTtcbmNvbnN0IGRlZmluaXRpb25zID0gcmVxdWlyZSgnLi9kZWZpbml0aW9ucycpO1xuY29uc3QgaXNDb25zdGFudCA9IHJlcXVpcmUoJy4vaXNfY29uc3RhbnQnKTtcbmNvbnN0IHt1bndyYXB9ID0gcmVxdWlyZSgnLi92YWx1ZXMnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5cbiAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gIFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICBcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICBcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICBcbiAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICBcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgXG4gICAgIFxuICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgIFxuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgIFxuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBcbiAgXG5cbmZ1bmN0aW9uIGlzRXhwcmVzc2lvbihleHByZXNzaW9uICAgICAgICkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGV4cHJlc3Npb24pICYmIGV4cHJlc3Npb24ubGVuZ3RoID4gMCAmJlxuICAgICAgICB0eXBlb2YgZXhwcmVzc2lvblswXSA9PT0gJ3N0cmluZycgJiYgZXhwcmVzc2lvblswXSBpbiBkZWZpbml0aW9ucztcbn1cblxuLyoqXG4gKiBQYXJzZSBhbmQgdHlwZWNoZWNrIHRoZSBnaXZlbiBzdHlsZSBzcGVjIEpTT04gZXhwcmVzc2lvbi4gIElmXG4gKiBvcHRpb25zLmRlZmF1bHRWYWx1ZSBpcyBwcm92aWRlZCwgdGhlbiB0aGUgcmVzdWx0aW5nIFN0eWxlRXhwcmVzc2lvbidzXG4gKiBgZXZhbHVhdGUoKWAgbWV0aG9kIHdpbGwgaGFuZGxlIGVycm9ycyBieSBsb2dnaW5nIGEgd2FybmluZyAob25jZSBwZXJcbiAqIG1lc3NhZ2UpIGFuZCByZXR1cm5pbmcgdGhlIGRlZmF1bHQgdmFsdWUuICBPdGhlcndpc2UsIGl0IHdpbGwgdGhyb3dcbiAqIGV2YWx1YXRpb24gZXJyb3JzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUV4cHJlc3Npb24oZXhwcmVzc2lvbiAgICAgICAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5U3BlYyAgICAgICAgICAgICAgICAgICAgICAgICAgICAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQgICAgICAgICAgICAgICAgICAgICAgICAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgICAgICAgICAgICAgICAgICAgICAgICAgICA9IHt9KSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICBjb25zdCBwYXJzZXIgPSBuZXcgUGFyc2luZ0NvbnRleHQoZGVmaW5pdGlvbnMsIFtdLCBnZXRFeHBlY3RlZFR5cGUocHJvcGVydHlTcGVjKSk7XG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2VyLnBhcnNlKGV4cHJlc3Npb24pO1xuICAgIGlmICghcGFyc2VkKSB7XG4gICAgICAgIGFzc2VydChwYXJzZXIuZXJyb3JzLmxlbmd0aCA+IDApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdWx0OiAnZXJyb3InLFxuICAgICAgICAgICAgZXJyb3JzOiBwYXJzZXIuZXJyb3JzXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3QgZXZhbHVhdG9yID0gbmV3IEV2YWx1YXRpb25Db250ZXh0KCk7XG5cbiAgICBsZXQgZXZhbHVhdGU7XG4gICAgaWYgKG9wdGlvbnMuaGFuZGxlRXJyb3JzID09PSBmYWxzZSkge1xuICAgICAgICBldmFsdWF0ZSA9IGZ1bmN0aW9uIChnbG9iYWxzLCBmZWF0dXJlKSB7XG4gICAgICAgICAgICBldmFsdWF0b3IuZ2xvYmFscyA9IGdsb2JhbHM7XG4gICAgICAgICAgICBldmFsdWF0b3IuZmVhdHVyZSA9IGZlYXR1cmU7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VkLmV2YWx1YXRlKGV2YWx1YXRvcik7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgd2FybmluZ0hpc3RvcnkgICAgICAgICAgICAgICAgICAgICAgICAgICA9IHt9O1xuICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSBnZXREZWZhdWx0VmFsdWUocHJvcGVydHlTcGVjKTtcbiAgICAgICAgZXZhbHVhdGUgPSBmdW5jdGlvbiAoZ2xvYmFscywgZmVhdHVyZSkge1xuICAgICAgICAgICAgZXZhbHVhdG9yLmdsb2JhbHMgPSBnbG9iYWxzO1xuICAgICAgICAgICAgZXZhbHVhdG9yLmZlYXR1cmUgPSBmZWF0dXJlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBwYXJzZWQuZXZhbHVhdGUoZXZhbHVhdG9yKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bndyYXAoZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVud3JhcCh2YWwpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmICghd2FybmluZ0hpc3RvcnlbZS5tZXNzYWdlXSkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuaW5nSGlzdG9yeVtlLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGUubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVud3JhcChkZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IGlzRmVhdHVyZUNvbnN0YW50ID0gaXNDb25zdGFudC5pc0ZlYXR1cmVDb25zdGFudChwYXJzZWQpO1xuICAgIGlmICghaXNGZWF0dXJlQ29uc3RhbnQgJiYgY29udGV4dCA9PT0gJ3Byb3BlcnR5JyAmJiAhcHJvcGVydHlTcGVjWydwcm9wZXJ0eS1mdW5jdGlvbiddKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN1bHQ6ICdlcnJvcicsXG4gICAgICAgICAgICBlcnJvcnM6IFtuZXcgUGFyc2luZ0Vycm9yKCcnLCAncHJvcGVydHkgZXhwcmVzc2lvbnMgbm90IHN1cHBvcnRlZCcpXVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IGlzWm9vbUNvbnN0YW50ID0gaXNDb25zdGFudC5pc0dsb2JhbFByb3BlcnR5Q29uc3RhbnQocGFyc2VkLCBbJ3pvb20nXSk7XG4gICAgaWYgKGlzWm9vbUNvbnN0YW50KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN1bHQ6ICdzdWNjZXNzJyxcbiAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICBpc1pvb21Db25zdGFudDogdHJ1ZSxcbiAgICAgICAgICAgIGlzRmVhdHVyZUNvbnN0YW50LFxuICAgICAgICAgICAgZXZhbHVhdGUsXG4gICAgICAgICAgICBwYXJzZWRcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGNvbnRleHQgPT09ICdmaWx0ZXInKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN1bHQ6ICdzdWNjZXNzJyxcbiAgICAgICAgICAgIGNvbnRleHQ6ICdmaWx0ZXInLFxuICAgICAgICAgICAgaXNab29tQ29uc3RhbnQ6IGZhbHNlLFxuICAgICAgICAgICAgaXNGZWF0dXJlQ29uc3RhbnQsXG4gICAgICAgICAgICBldmFsdWF0ZSxcbiAgICAgICAgICAgIHBhcnNlZFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IHpvb21DdXJ2ZSA9IGZpbmRab29tQ3VydmUocGFyc2VkKTtcbiAgICBpZiAoIXpvb21DdXJ2ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdWx0OiAnZXJyb3InLFxuICAgICAgICAgICAgZXJyb3JzOiBbbmV3IFBhcnNpbmdFcnJvcignJywgJ1wiem9vbVwiIGV4cHJlc3Npb24gbWF5IG9ubHkgYmUgdXNlZCBhcyBpbnB1dCB0byBhIHRvcC1sZXZlbCBcImN1cnZlXCIgZXhwcmVzc2lvbi4nKV1cbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKCEoem9vbUN1cnZlIGluc3RhbmNlb2YgQ3VydmUpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN1bHQ6ICdlcnJvcicsXG4gICAgICAgICAgICBlcnJvcnM6IFtuZXcgUGFyc2luZ0Vycm9yKHpvb21DdXJ2ZS5rZXksIHpvb21DdXJ2ZS5lcnJvcildXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmICh6b29tQ3VydmUuaW50ZXJwb2xhdGlvbi5uYW1lICE9PSAnc3RlcCcgJiYgcHJvcGVydHlTcGVjWydmdW5jdGlvbiddID09PSAncGllY2V3aXNlLWNvbnN0YW50Jykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdWx0OiAnZXJyb3InLFxuICAgICAgICAgICAgZXJyb3JzOiBbbmV3IFBhcnNpbmdFcnJvcih6b29tQ3VydmUua2V5LCAnaW50ZXJwb2xhdGlvbiB0eXBlIG11c3QgYmUgXCJzdGVwXCIgZm9yIHRoaXMgcHJvcGVydHknKV1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICByZXN1bHQ6ICdzdWNjZXNzJyxcbiAgICAgICAgY29udGV4dDogJ3Byb3BlcnR5JyxcbiAgICAgICAgaXNab29tQ29uc3RhbnQ6IGZhbHNlLFxuICAgICAgICBpc0ZlYXR1cmVDb25zdGFudCxcbiAgICAgICAgZXZhbHVhdGUsXG4gICAgICAgIHBhcnNlZCxcblxuICAgICAgICAvLyBjYXB0dXJlIG1ldGFkYXRhIGZyb20gdGhlIGN1cnZlIGRlZmluaXRpb24gdGhhdCdzIG5lZWRlZCBmb3JcbiAgICAgICAgLy8gb3VyIHByZXBvcHVsYXRlLWFuZC1pbnRlcnBvbGF0ZSBhcHByb2FjaCB0byBwYWludCBwcm9wZXJ0aWVzXG4gICAgICAgIC8vIHRoYXQgYXJlIHpvb20tYW5kLXByb3BlcnR5IGRlcGVuZGVudC5cbiAgICAgICAgaW50ZXJwb2xhdGlvbjogem9vbUN1cnZlLmludGVycG9sYXRpb24sXG4gICAgICAgIHpvb21TdG9wczogem9vbUN1cnZlLmxhYmVsc1xuICAgIH07XG59XG5cbm1vZHVsZS5leHBvcnRzLmNyZWF0ZUV4cHJlc3Npb24gPSBjcmVhdGVFeHByZXNzaW9uO1xubW9kdWxlLmV4cG9ydHMuaXNFeHByZXNzaW9uID0gaXNFeHByZXNzaW9uO1xuXG4vLyBab29tLWRlcGVuZGVudCBleHByZXNzaW9ucyBtYXkgb25seSB1c2UgW1wiem9vbVwiXSBhcyB0aGUgaW5wdXQgdG8gYVxuLy8gJ3RvcC1sZXZlbCcgXCJjdXJ2ZVwiIGV4cHJlc3Npb24uIChUaGUgY3VydmUgbWF5IGJlIHdyYXBwZWQgaW4gb25lIG9yIG1vcmVcbi8vIFwibGV0XCIgb3IgXCJjb2FsZXNjZVwiIGV4cHJlc3Npb25zLilcbmZ1bmN0aW9uIGZpbmRab29tQ3VydmUoZXhwcmVzc2lvbiAgICAgICAgICAgICkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgIGlmIChleHByZXNzaW9uIGluc3RhbmNlb2YgQ3VydmUpIHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBleHByZXNzaW9uLmlucHV0O1xuICAgICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBDb21wb3VuZEV4cHJlc3Npb24gJiYgaW5wdXQubmFtZSA9PT0gJ3pvb20nKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwcmVzc2lvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChleHByZXNzaW9uIGluc3RhbmNlb2YgTGV0KSB7XG4gICAgICAgIHJldHVybiBmaW5kWm9vbUN1cnZlKGV4cHJlc3Npb24ucmVzdWx0KTtcbiAgICB9IGVsc2UgaWYgKGV4cHJlc3Npb24gaW5zdGFuY2VvZiBDb2FsZXNjZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBhcmcgb2YgZXhwcmVzc2lvbi5hcmdzKSB7XG4gICAgICAgICAgICBjb25zdCBlID0gZmluZFpvb21DdXJ2ZShhcmcpO1xuICAgICAgICAgICAgaWYgKCFlKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGUuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZSBpbnN0YW5jZW9mIEN1cnZlICYmICFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBrZXk6IGUua2V5LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogJ09ubHkgb25lIHpvb20tYmFzZWQgY3VydmUgbWF5IGJlIHVzZWQgaW4gYSBzdHlsZSBmdW5jdGlvbi4nXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG5jb25zdCB7XG4gICAgQ29sb3JUeXBlLFxuICAgIFN0cmluZ1R5cGUsXG4gICAgTnVtYmVyVHlwZSxcbiAgICBCb29sZWFuVHlwZSxcbiAgICBWYWx1ZVR5cGUsXG4gICAgYXJyYXlcbn0gPSByZXF1aXJlKCcuL3R5cGVzJyk7XG5cbmZ1bmN0aW9uIGdldEV4cGVjdGVkVHlwZShzcGVjICAgICAgICAgICAgICAgICAgICAgICAgICAgICkgICAgICAgICAgICAgIHtcbiAgICBjb25zdCB0eXBlcyA9IHtcbiAgICAgICAgY29sb3I6IENvbG9yVHlwZSxcbiAgICAgICAgc3RyaW5nOiBTdHJpbmdUeXBlLFxuICAgICAgICBudW1iZXI6IE51bWJlclR5cGUsXG4gICAgICAgIGVudW06IFN0cmluZ1R5cGUsXG4gICAgICAgIGJvb2xlYW46IEJvb2xlYW5UeXBlXG4gICAgfTtcblxuICAgIGlmIChzcGVjLnR5cGUgPT09ICdhcnJheScpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5KHR5cGVzW3NwZWMudmFsdWVdIHx8IFZhbHVlVHlwZSwgc3BlYy5sZW5ndGgpO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlc1tzcGVjLnR5cGVdIHx8IG51bGw7XG59XG5cbmNvbnN0IHtpc0Z1bmN0aW9ufSA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9uJyk7XG5jb25zdCBwYXJzZUNvbG9yID0gcmVxdWlyZSgnLi4vdXRpbC9wYXJzZV9jb2xvcicpO1xuY29uc3Qge0NvbG9yfSA9IHJlcXVpcmUoJy4vdmFsdWVzJyk7XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRWYWx1ZShzcGVjICAgICAgICAgICAgICAgICAgICAgICAgICAgICkgICAgICAgICAgICAgICB7XG4gICAgY29uc3QgZGVmYXVsdFZhbHVlID0gc3BlYy5kZWZhdWx0O1xuICAgIGlmIChzcGVjLnR5cGUgPT09ICdjb2xvcicgJiYgaXNGdW5jdGlvbihkZWZhdWx0VmFsdWUpKSB7XG4gICAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgaGVhdG1hcC1jb2xvcjogaXQgdXNlcyB0aGUgJ2RlZmF1bHQ6JyB0byBkZWZpbmUgYVxuICAgICAgICAvLyBkZWZhdWx0IGNvbG9yIHJhbXAsIGJ1dCBjcmVhdGVFeHByZXNzaW9uIGV4cGVjdHMgYSBzaW1wbGUgdmFsdWUgdG8gZmFsbFxuICAgICAgICAvLyBiYWNrIHRvIGluIGNhc2Ugb2YgcnVudGltZSBlcnJvcnNcbiAgICAgICAgcmV0dXJuIFswLCAwLCAwLCAwXTtcbiAgICB9IGVsc2UgaWYgKHNwZWMudHlwZSA9PT0gJ2NvbG9yJykge1xuICAgICAgICBjb25zdCBjICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IChwYXJzZUNvbG9yKChkZWZhdWx0VmFsdWUgICAgICkpICAgICApO1xuICAgICAgICBhc3NlcnQoQXJyYXkuaXNBcnJheShjKSk7XG4gICAgICAgIHJldHVybiBuZXcgQ29sb3IoY1swXSwgY1sxXSwgY1syXSwgY1szXSk7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0VmFsdWUgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZWZhdWx0VmFsdWU7XG59XG4iLCIvLyAgICAgIFxuXG5jb25zdCB7IENvbXBvdW5kRXhwcmVzc2lvbiB9ID0gcmVxdWlyZSgnLi9jb21wb3VuZF9leHByZXNzaW9uJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5cbmZ1bmN0aW9uIGlzRmVhdHVyZUNvbnN0YW50KGUgICAgICAgICAgICApIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIENvbXBvdW5kRXhwcmVzc2lvbikge1xuICAgICAgICBpZiAoZS5uYW1lID09PSAnZ2V0JyAmJiBlLmFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5uYW1lID09PSAnaGFzJyAmJiBlLmFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICBlLm5hbWUgPT09ICdwcm9wZXJ0aWVzJyB8fFxuICAgICAgICAgICAgZS5uYW1lID09PSAnZ2VvbWV0cnktdHlwZScgfHxcbiAgICAgICAgICAgIGUubmFtZSA9PT0gJ2lkJ1xuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxldCByZXN1bHQgPSB0cnVlO1xuICAgIGUuZWFjaENoaWxkKGFyZyA9PiB7XG4gICAgICAgIGlmIChyZXN1bHQgJiYgIWlzRmVhdHVyZUNvbnN0YW50KGFyZykpIHsgcmVzdWx0ID0gZmFsc2U7IH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBpc0dsb2JhbFByb3BlcnR5Q29uc3RhbnQoZSAgICAgICAgICAgICwgcHJvcGVydGllcyAgICAgICAgICAgICAgICkge1xuICAgIGlmIChlIGluc3RhbmNlb2YgQ29tcG91bmRFeHByZXNzaW9uICYmIHByb3BlcnRpZXMuaW5kZXhPZihlLm5hbWUpID49IDApIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgbGV0IHJlc3VsdCA9IHRydWU7XG4gICAgZS5lYWNoQ2hpbGQoKGFyZykgPT4ge1xuICAgICAgICBpZiAocmVzdWx0ICYmICFpc0dsb2JhbFByb3BlcnR5Q29uc3RhbnQoYXJnLCBwcm9wZXJ0aWVzKSkgeyByZXN1bHQgPSBmYWxzZTsgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGlzRmVhdHVyZUNvbnN0YW50LFxuICAgIGlzR2xvYmFsUHJvcGVydHlDb25zdGFudCxcbn07XG4iLCIvLyAgICAgIFxuXG5jb25zdCBTY29wZSA9IHJlcXVpcmUoJy4vc2NvcGUnKTtcbmNvbnN0IHtjaGVja1N1YnR5cGV9ID0gcmVxdWlyZSgnLi90eXBlcycpO1xuY29uc3QgUGFyc2luZ0Vycm9yID0gcmVxdWlyZSgnLi9wYXJzaW5nX2Vycm9yJyk7XG5jb25zdCBMaXRlcmFsID0gcmVxdWlyZSgnLi9kZWZpbml0aW9ucy9saXRlcmFsJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuXG4vKipcbiAqIFN0YXRlIGFzc29jaWF0ZWQgcGFyc2luZyBhdCBhIGdpdmVuIHBvaW50IGluIGFuIGV4cHJlc3Npb24gdHJlZS5cbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFBhcnNpbmdDb250ZXh0IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuXG4gICAgLy8gVGhlIGV4cGVjdGVkIHR5cGUgb2YgdGhpcyBleHByZXNzaW9uLiBQcm92aWRlZCBvbmx5IHRvIGFsbG93IEV4cHJlc3Npb25cbiAgICAvLyBpbXBsZW1lbnRhdGlvbnMgdG8gaW5mZXIgYXJndW1lbnQgdHlwZXM6IEV4cHJlc3Npb24jcGFyc2UoKSBuZWVkIG5vdFxuICAgIC8vIGNoZWNrIHRoYXQgdGhlIG91dHB1dCB0eXBlIG9mIHRoZSBwYXJzZWQgZXhwcmVzc2lvbiBtYXRjaGVzXG4gICAgLy8gYGV4cGVjdGVkVHlwZWAuXG4gICAgICAgICAgICAgICAgICAgICAgICBcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBkZWZpbml0aW9ucyAgICxcbiAgICAgICAgcGF0aCAgICAgICAgICAgICAgICA9IFtdLFxuICAgICAgICBleHBlY3RlZFR5cGUgICAgICAgLFxuICAgICAgICBzY29wZSAgICAgICAgPSBuZXcgU2NvcGUoKSxcbiAgICAgICAgZXJyb3JzICAgICAgICAgICAgICAgICAgICAgID0gW11cbiAgICApIHtcbiAgICAgICAgdGhpcy5kZWZpbml0aW9ucyA9IGRlZmluaXRpb25zO1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLmtleSA9IHBhdGgubWFwKHBhcnQgPT4gYFske3BhcnR9XWApLmpvaW4oJycpO1xuICAgICAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICB0aGlzLmV4cGVjdGVkVHlwZSA9IGV4cGVjdGVkVHlwZTtcbiAgICB9XG5cbiAgICBwYXJzZShleHByICAgICAgICwgaW5kZXggICAgICAgICAsIGV4cGVjdGVkVHlwZSAgICAgICAgLCBiaW5kaW5ncyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkgICAgICAgICAgICAgIHtcbiAgICAgICAgbGV0IGNvbnRleHQgPSB0aGlzO1xuICAgICAgICBpZiAoaW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0LmNvbmNhdChpbmRleCwgZXhwZWN0ZWRUeXBlLCBiaW5kaW5ncyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXhwciA9PT0gbnVsbCB8fCB0eXBlb2YgZXhwciA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGV4cHIgPT09ICdib29sZWFuJyB8fCB0eXBlb2YgZXhwciA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGV4cHIgPSBbJ2xpdGVyYWwnLCBleHByXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGV4cHIpKSB7XG4gICAgICAgICAgICBpZiAoZXhwci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihgRXhwZWN0ZWQgYW4gYXJyYXkgd2l0aCBhdCBsZWFzdCBvbmUgZWxlbWVudC4gSWYgeW91IHdhbnRlZCBhIGxpdGVyYWwgYXJyYXksIHVzZSBbXCJsaXRlcmFsXCIsIFtdXS5gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3Qgb3AgPSBleHByWzBdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmVycm9yKGBFeHByZXNzaW9uIG5hbWUgbXVzdCBiZSBhIHN0cmluZywgYnV0IGZvdW5kICR7dHlwZW9mIG9wfSBpbnN0ZWFkLiBJZiB5b3Ugd2FudGVkIGEgbGl0ZXJhbCBhcnJheSwgdXNlIFtcImxpdGVyYWxcIiwgWy4uLl1dLmAsIDApO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBFeHByID0gY29udGV4dC5kZWZpbml0aW9uc1tvcF07XG4gICAgICAgICAgICBpZiAoRXhwcikge1xuICAgICAgICAgICAgICAgIGxldCBwYXJzZWQgPSBFeHByLnBhcnNlKGV4cHIsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGlmICghcGFyc2VkKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICBjb25zdCBleHBlY3RlZCA9IGNvbnRleHQuZXhwZWN0ZWRUeXBlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjdHVhbCA9IHBhcnNlZC50eXBlO1xuICAgICAgICAgICAgICAgIGlmIChleHBlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHdlIGV4cGVjdCBhIG51bWJlciwgc3RyaW5nLCBvciBib29sZWFuIGJ1dCBoYXZlIGFcbiAgICAgICAgICAgICAgICAgICAgLy8gVmFsdWUsIHdyYXAgaXQgaW4gYSByZWZpbmluZyBhc3NlcnRpb24sIGFuZCB3aGVuIHdlIGV4cGVjdFxuICAgICAgICAgICAgICAgICAgICAvLyBhIENvbG9yIGJ1dCBoYXZlIGEgU3RyaW5nIG9yIFZhbHVlLCB3cmFwIGl0IGluIFwidG8tY29sb3JcIlxuICAgICAgICAgICAgICAgICAgICAvLyBjb2VyY2lvbi5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FuQXNzZXJ0ID0gZXhwZWN0ZWQua2luZCA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkLmtpbmQgPT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZC5raW5kID09PSAnYm9vbGVhbic7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbkFzc2VydCAmJiBhY3R1YWwua2luZCA9PT0gJ3ZhbHVlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgQXNzZXJ0aW9uID0gcmVxdWlyZSgnLi9kZWZpbml0aW9ucy9hc3NlcnRpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZCA9IG5ldyBBc3NlcnRpb24ocGFyc2VkLmtleSwgZXhwZWN0ZWQsIFtwYXJzZWRdKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChleHBlY3RlZC5raW5kID09PSAnY29sb3InICYmIChhY3R1YWwua2luZCA9PT0gJ3ZhbHVlJyB8fCBhY3R1YWwua2luZCA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBDb2VyY2lvbiA9IHJlcXVpcmUoJy4vZGVmaW5pdGlvbnMvY29lcmNpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZCA9IG5ldyBDb2VyY2lvbihwYXJzZWQua2V5LCBleHBlY3RlZCwgW3BhcnNlZF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuY2hlY2tTdWJ0eXBlKGV4cGVjdGVkLCBwYXJzZWQudHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgYW4gZXhwcmVzc2lvbidzIGFyZ3VtZW50cyBhcmUgYWxsIGxpdGVyYWxzLCB3ZSBjYW4gZXZhbHVhdGVcbiAgICAgICAgICAgICAgICAvLyBpdCBpbW1lZGlhdGVseSBhbmQgcmVwbGFjZSBpdCB3aXRoIGEgbGl0ZXJhbCB2YWx1ZSBpbiB0aGVcbiAgICAgICAgICAgICAgICAvLyBwYXJzZWQvY29tcGlsZWQgcmVzdWx0LlxuICAgICAgICAgICAgICAgIGlmICghKHBhcnNlZCBpbnN0YW5jZW9mIExpdGVyYWwpICYmIGlzQ29uc3RhbnQocGFyc2VkKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlYyA9IG5ldyAocmVxdWlyZSgnLi9ldmFsdWF0aW9uX2NvbnRleHQnKSkoKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZCA9IG5ldyBMaXRlcmFsKHBhcnNlZC5rZXksIHBhcnNlZC50eXBlLCBwYXJzZWQuZXZhbHVhdGUoZWMpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5lcnJvcihlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihgVW5rbm93biBleHByZXNzaW9uIFwiJHtvcH1cIi4gSWYgeW91IHdhbnRlZCBhIGxpdGVyYWwgYXJyYXksIHVzZSBbXCJsaXRlcmFsXCIsIFsuLi5dXS5gLCAwKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKGAndW5kZWZpbmVkJyB2YWx1ZSBpbnZhbGlkLiBVc2UgbnVsbCBpbnN0ZWFkLmApO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHByID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoYEJhcmUgb2JqZWN0cyBpbnZhbGlkLiBVc2UgW1wibGl0ZXJhbFwiLCB7Li4ufV0gaW5zdGVhZC5gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKGBFeHBlY3RlZCBhbiBhcnJheSwgYnV0IGZvdW5kICR7dHlwZW9mIGV4cHJ9IGluc3RlYWQuYCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGlzIGNvbnRleHQgc3VpdGFibGUgZm9yIHBhcnNpbmcgdGhlIHN1YmV4cHJlc3Npb24gYXRcbiAgICAgKiBpbmRleCBgaW5kZXhgLCBvcHRpb25hbGx5IGFwcGVuZGluZyB0byAnbGV0JyBiaW5kaW5nIG1hcC5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCBgZXJyb3JzYCBwcm9wZXJ0eSwgaW50ZW5kZWQgZm9yIGNvbGxlY3RpbmcgZXJyb3JzIHdoaWxlXG4gICAgICogcGFyc2luZywgaXMgY29waWVkIGJ5IHJlZmVyZW5jZSByYXRoZXIgdGhhbiBjbG9uZWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25jYXQoaW5kZXggICAgICAgICwgZXhwZWN0ZWRUeXBlICAgICAgICAsIGJpbmRpbmdzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSB0eXBlb2YgaW5kZXggPT09ICdudW1iZXInID8gdGhpcy5wYXRoLmNvbmNhdChpbmRleCkgOiB0aGlzLnBhdGg7XG4gICAgICAgIGNvbnN0IHNjb3BlID0gYmluZGluZ3MgPyB0aGlzLnNjb3BlLmNvbmNhdChiaW5kaW5ncykgOiB0aGlzLnNjb3BlO1xuICAgICAgICByZXR1cm4gbmV3IFBhcnNpbmdDb250ZXh0KFxuICAgICAgICAgICAgdGhpcy5kZWZpbml0aW9ucyxcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBleHBlY3RlZFR5cGUgfHwgbnVsbCxcbiAgICAgICAgICAgIHNjb3BlLFxuICAgICAgICAgICAgdGhpcy5lcnJvcnNcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdXNoIGEgcGFyc2luZyAob3IgdHlwZSBjaGVja2luZykgZXJyb3IgaW50byB0aGUgYHRoaXMuZXJyb3JzYFxuICAgICAqIEBwYXJhbSBlcnJvciBUaGUgbWVzc2FnZVxuICAgICAqIEBwYXJhbSBrZXlzIE9wdGlvbmFsbHkgc3BlY2lmeSB0aGUgc291cmNlIG9mIHRoZSBlcnJvciBhdCBhIGNoaWxkXG4gICAgICogb2YgdGhlIGN1cnJlbnQgZXhwcmVzc2lvbiBhdCBgdGhpcy5rZXlgLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZXJyb3IoZXJyb3IgICAgICAgICwgLi4ua2V5cyAgICAgICAgICAgICAgICkge1xuICAgICAgICBjb25zdCBrZXkgPSBgJHt0aGlzLmtleX0ke2tleXMubWFwKGsgPT4gYFske2t9XWApLmpvaW4oJycpfWA7XG4gICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IFBhcnNpbmdFcnJvcihrZXksIGVycm9yKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBudWxsIGlmIGB0YCBpcyBhIHN1YnR5cGUgb2YgYGV4cGVjdGVkYDsgb3RoZXJ3aXNlIHJldHVybnMgYW5cbiAgICAgKiBlcnJvciBtZXNzYWdlIGFuZCBhbHNvIHB1c2hlcyBpdCB0byBgdGhpcy5lcnJvcnNgLlxuICAgICAqL1xuICAgIGNoZWNrU3VidHlwZShleHBlY3RlZCAgICAgICwgdCAgICAgICkgICAgICAgICAge1xuICAgICAgICBjb25zdCBlcnJvciA9IGNoZWNrU3VidHlwZShleHBlY3RlZCwgdCk7XG4gICAgICAgIGlmIChlcnJvcikgdGhpcy5lcnJvcihlcnJvcik7XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUGFyc2luZ0NvbnRleHQ7XG5cbmZ1bmN0aW9uIGlzQ29uc3RhbnQoZXhwcmVzc2lvbiAgICAgICAgICAgICkge1xuICAgIC8vIHJlcXVpcmVzIHdpdGhpbiBmdW5jdGlvbiBib2R5IHRvIHdvcmthcm91bmQgY2lyY3VsYXIgZGVwZW5kZW5jeVxuICAgIGNvbnN0IHtDb21wb3VuZEV4cHJlc3Npb259ID0gcmVxdWlyZSgnLi9jb21wb3VuZF9leHByZXNzaW9uJyk7XG4gICAgY29uc3Qge2lzR2xvYmFsUHJvcGVydHlDb25zdGFudCwgaXNGZWF0dXJlQ29uc3RhbnR9ID0gcmVxdWlyZSgnLi9pc19jb25zdGFudCcpO1xuICAgIGNvbnN0IFZhciA9IHJlcXVpcmUoJy4vZGVmaW5pdGlvbnMvdmFyJyk7XG5cbiAgICBpZiAoZXhwcmVzc2lvbiBpbnN0YW5jZW9mIFZhcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChleHByZXNzaW9uIGluc3RhbmNlb2YgQ29tcG91bmRFeHByZXNzaW9uICYmIGV4cHJlc3Npb24ubmFtZSA9PT0gJ2Vycm9yJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IGxpdGVyYWxBcmdzID0gdHJ1ZTtcbiAgICBleHByZXNzaW9uLmVhY2hDaGlsZChhcmcgPT4ge1xuICAgICAgICBpZiAoIShhcmcgaW5zdGFuY2VvZiBMaXRlcmFsKSkgeyBsaXRlcmFsQXJncyA9IGZhbHNlOyB9XG4gICAgfSk7XG4gICAgaWYgKCFsaXRlcmFsQXJncykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzRmVhdHVyZUNvbnN0YW50KGV4cHJlc3Npb24pICYmXG4gICAgICAgIGlzR2xvYmFsUHJvcGVydHlDb25zdGFudChleHByZXNzaW9uLCBbJ3pvb20nLCAnaGVhdG1hcC1kZW5zaXR5J10pO1xufVxuIiwiLy8gICAgICBcblxuY2xhc3MgUGFyc2luZ0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBcbiAgICBjb25zdHJ1Y3RvcihrZXkgICAgICAgICwgbWVzc2FnZSAgICAgICAgKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUGFyc2luZ0Vycm9yO1xuIiwiLy8gICAgICBcblxuY2xhc3MgUnVudGltZUVycm9yIHtcbiAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIFxuXG4gICAgY29uc3RydWN0b3IobWVzc2FnZSAgICAgICAgKSB7XG4gICAgICAgIHRoaXMubmFtZSA9ICdFeHByZXNzaW9uRXZhbHVhdGlvbkVycm9yJztcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB9XG5cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJ1bnRpbWVFcnJvcjtcbiIsIi8vICAgICAgXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuXG4vKipcbiAqIFRyYWNrcyBgbGV0YCBiaW5kaW5ncyBkdXJpbmcgZXhwcmVzc2lvbiBwYXJzaW5nLlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgU2NvcGUge1xuICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGNvbnN0cnVjdG9yKHBhcmVudCAgICAgICAgLCBiaW5kaW5ncyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gW10pIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuYmluZGluZ3MgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgZXhwcmVzc2lvbl0gb2YgYmluZGluZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuYmluZGluZ3NbbmFtZV0gPSBleHByZXNzaW9uO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uY2F0KGJpbmRpbmdzICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTY29wZSh0aGlzLCBiaW5kaW5ncyk7XG4gICAgfVxuXG4gICAgZ2V0KG5hbWUgICAgICAgICkgICAgICAgICAgICAge1xuICAgICAgICBpZiAodGhpcy5iaW5kaW5nc1tuYW1lXSkgeyByZXR1cm4gdGhpcy5iaW5kaW5nc1tuYW1lXTsgfVxuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHsgcmV0dXJuIHRoaXMucGFyZW50LmdldChuYW1lKTsgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bmFtZX0gbm90IGZvdW5kIGluIHNjb3BlLmApO1xuICAgIH1cblxuICAgIGhhcyhuYW1lICAgICAgICApICAgICAgICAgIHtcbiAgICAgICAgaWYgKHRoaXMuYmluZGluZ3NbbmFtZV0pIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5oYXMobmFtZSkgOiBmYWxzZTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2NvcGU7XG4iLCIvLyAgICAgIFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcblxuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBcbiBcblxuY29uc3QgTnVsbFR5cGUgPSB7IGtpbmQ6ICdudWxsJyB9O1xuY29uc3QgTnVtYmVyVHlwZSA9IHsga2luZDogJ251bWJlcicgfTtcbmNvbnN0IFN0cmluZ1R5cGUgPSB7IGtpbmQ6ICdzdHJpbmcnIH07XG5jb25zdCBCb29sZWFuVHlwZSA9IHsga2luZDogJ2Jvb2xlYW4nIH07XG5jb25zdCBDb2xvclR5cGUgPSB7IGtpbmQ6ICdjb2xvcicgfTtcbmNvbnN0IE9iamVjdFR5cGUgPSB7IGtpbmQ6ICdvYmplY3QnIH07XG5jb25zdCBWYWx1ZVR5cGUgPSB7IGtpbmQ6ICd2YWx1ZScgfTtcbmNvbnN0IEVycm9yVHlwZSA9IHsga2luZDogJ2Vycm9yJyB9O1xuXG5mdW5jdGlvbiBhcnJheShpdGVtVHlwZSAgICAgICwgTiAgICAgICAgICkgICAgICAgICAgICB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAga2luZDogJ2FycmF5JyxcbiAgICAgICAgaXRlbVR5cGUsXG4gICAgICAgIE5cbiAgICB9O1xufVxuXG5mdW5jdGlvbiB0b1N0cmluZyh0eXBlICAgICAgKSAgICAgICAgIHtcbiAgICBpZiAodHlwZS5raW5kID09PSAnYXJyYXknKSB7XG4gICAgICAgIGNvbnN0IGl0ZW1UeXBlID0gdG9TdHJpbmcodHlwZS5pdGVtVHlwZSk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdHlwZS5OID09PSAnbnVtYmVyJyA/XG4gICAgICAgICAgICBgYXJyYXk8JHtpdGVtVHlwZX0sICR7dHlwZS5OfT5gIDpcbiAgICAgICAgICAgIHR5cGUuaXRlbVR5cGUua2luZCA9PT0gJ3ZhbHVlJyA/ICdhcnJheScgOiBgYXJyYXk8JHtpdGVtVHlwZX0+YDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHlwZS5raW5kO1xuICAgIH1cbn1cblxuY29uc3QgdmFsdWVNZW1iZXJUeXBlcyA9IFtcbiAgICBOdWxsVHlwZSxcbiAgICBOdW1iZXJUeXBlLFxuICAgIFN0cmluZ1R5cGUsXG4gICAgQm9vbGVhblR5cGUsXG4gICAgQ29sb3JUeXBlLFxuICAgIE9iamVjdFR5cGUsXG4gICAgYXJyYXkoVmFsdWVUeXBlKVxuXTtcblxuLyoqXG4gKiBSZXR1cm5zIG51bGwgaWYgYHRgIGlzIGEgc3VidHlwZSBvZiBgZXhwZWN0ZWRgOyBvdGhlcndpc2UgcmV0dXJucyBhblxuICogZXJyb3IgbWVzc2FnZS5cbiAqICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tTdWJ0eXBlKGV4cGVjdGVkICAgICAgLCB0ICAgICAgKSAgICAgICAgICB7XG4gICAgaWYgKHQua2luZCA9PT0gJ2Vycm9yJykge1xuICAgICAgICAvLyBFcnJvciBpcyBhIHN1YnR5cGUgb2YgZXZlcnkgdHlwZVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGV4cGVjdGVkLmtpbmQgPT09ICdhcnJheScpIHtcbiAgICAgICAgaWYgKHQua2luZCA9PT0gJ2FycmF5JyAmJlxuICAgICAgICAgICAgIWNoZWNrU3VidHlwZShleHBlY3RlZC5pdGVtVHlwZSwgdC5pdGVtVHlwZSkgJiZcbiAgICAgICAgICAgICh0eXBlb2YgZXhwZWN0ZWQuTiAhPT0gJ251bWJlcicgfHwgZXhwZWN0ZWQuTiA9PT0gdC5OKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGV4cGVjdGVkLmtpbmQgPT09IHQua2luZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGV4cGVjdGVkLmtpbmQgPT09ICd2YWx1ZScpIHtcbiAgICAgICAgZm9yIChjb25zdCBtZW1iZXJUeXBlIG9mIHZhbHVlTWVtYmVyVHlwZXMpIHtcbiAgICAgICAgICAgIGlmICghY2hlY2tTdWJ0eXBlKG1lbWJlclR5cGUsIHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYEV4cGVjdGVkICR7dG9TdHJpbmcoZXhwZWN0ZWQpfSBidXQgZm91bmQgJHt0b1N0cmluZyh0KX0gaW5zdGVhZC5gO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBOdWxsVHlwZSxcbiAgICBOdW1iZXJUeXBlLFxuICAgIFN0cmluZ1R5cGUsXG4gICAgQm9vbGVhblR5cGUsXG4gICAgQ29sb3JUeXBlLFxuICAgIE9iamVjdFR5cGUsXG4gICAgVmFsdWVUeXBlLFxuICAgIGFycmF5LFxuICAgIEVycm9yVHlwZSxcbiAgICB0b1N0cmluZyxcbiAgICBjaGVja1N1YnR5cGVcbn07XG4iLCIvLyAgICAgIFxuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcblxuY29uc3Qge1xuICAgIE51bGxUeXBlLFxuICAgIE51bWJlclR5cGUsXG4gICAgU3RyaW5nVHlwZSxcbiAgICBCb29sZWFuVHlwZSxcbiAgICBDb2xvclR5cGUsXG4gICAgT2JqZWN0VHlwZSxcbiAgICBWYWx1ZVR5cGUsXG4gICAgYXJyYXlcbn0gPSByZXF1aXJlKCcuL3R5cGVzJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuXG5jbGFzcyBDb2xvciB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGNvbnN0cnVjdG9yKHIgICAgICAgICwgZyAgICAgICAgLCBiICAgICAgICAsIGEgICAgICAgICA9IDEpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IFtyLCBnLCBiLCBhXTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUkdCQShyICAgICAgICwgZyAgICAgICAsIGIgICAgICAgLCBhICAgICAgICApICAgICAgICAgIHtcbiAgICBpZiAoIShcbiAgICAgICAgdHlwZW9mIHIgPT09ICdudW1iZXInICYmIHIgPj0gMCAmJiByIDw9IDI1NSAmJlxuICAgICAgICB0eXBlb2YgZyA9PT0gJ251bWJlcicgJiYgZyA+PSAwICYmIGcgPD0gMjU1ICYmXG4gICAgICAgIHR5cGVvZiBiID09PSAnbnVtYmVyJyAmJiBiID49IDAgJiYgYiA8PSAyNTVcbiAgICApKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdHlwZW9mIGEgPT09ICdudW1iZXInID8gW3IsIGcsIGIsIGFdIDogW3IsIGcsIGJdO1xuICAgICAgICByZXR1cm4gYEludmFsaWQgcmdiYSB2YWx1ZSBbJHt2YWx1ZS5qb2luKCcsICcpfV06ICdyJywgJ2cnLCBhbmQgJ2InIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAyNTUuYDtcbiAgICB9XG5cbiAgICBpZiAoIShcbiAgICAgICAgdHlwZW9mIGEgPT09ICd1bmRlZmluZWQnIHx8ICh0eXBlb2YgYSA9PT0gJ251bWJlcicgJiYgYSA+PSAwICYmIGEgPD0gMSlcbiAgICApKSB7XG4gICAgICAgIHJldHVybiBgSW52YWxpZCByZ2JhIHZhbHVlIFske1tyLCBnLCBiLCBhXS5qb2luKCcsICcpfV06ICdhJyBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMS5gO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5cbmZ1bmN0aW9uIGlzVmFsdWUobWl4ZWQgICAgICAgKSAgICAgICAgICB7XG4gICAgaWYgKG1peGVkID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1peGVkID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtaXhlZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1peGVkID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKG1peGVkIGluc3RhbmNlb2YgQ29sb3IpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG1peGVkKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgbWl4ZWQpIHtcbiAgICAgICAgICAgIGlmICghaXNWYWx1ZShpdGVtKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtaXhlZCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbWl4ZWQpIHtcbiAgICAgICAgICAgIGlmICghaXNWYWx1ZShtaXhlZFtrZXldKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB0eXBlT2YodmFsdWUgICAgICAgKSAgICAgICB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBOdWxsVHlwZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZ1R5cGU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gQm9vbGVhblR5cGU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXJUeXBlO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBDb2xvcikge1xuICAgICAgICByZXR1cm4gQ29sb3JUeXBlO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICBsZXQgaXRlbVR5cGUgICAgICAgO1xuXG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgdCA9IHR5cGVPZihpdGVtKTtcbiAgICAgICAgICAgIGlmICghaXRlbVR5cGUpIHtcbiAgICAgICAgICAgICAgICBpdGVtVHlwZSA9IHQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW1UeXBlID09PSB0KSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZW1UeXBlID0gVmFsdWVUeXBlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFycmF5KGl0ZW1UeXBlIHx8IFZhbHVlVHlwZSwgbGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jyk7XG4gICAgICAgIHJldHVybiBPYmplY3RUeXBlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdW53cmFwKHZhbHVlICAgICAgICkgICAgICAgIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBDb2xvciA/IHZhbHVlLnZhbHVlIDogdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIENvbG9yLFxuICAgIHZhbGlkYXRlUkdCQSxcbiAgICBpc1ZhbHVlLFxuICAgIHR5cGVPZixcbiAgICB1bndyYXBcbn07XG4iLCIvLyAgICAgIFxuXG5jb25zdCB7Y3JlYXRlRXhwcmVzc2lvbn0gPSByZXF1aXJlKCcuLi9leHByZXNzaW9uJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlRmlsdGVyO1xubW9kdWxlLmV4cG9ydHMuaXNFeHByZXNzaW9uRmlsdGVyID0gaXNFeHByZXNzaW9uRmlsdGVyO1xuXG5mdW5jdGlvbiBpc0V4cHJlc3Npb25GaWx0ZXIoZmlsdGVyKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGZpbHRlcikgfHwgZmlsdGVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHN3aXRjaCAoZmlsdGVyWzBdKSB7XG4gICAgY2FzZSAnaGFzJzpcbiAgICAgICAgcmV0dXJuIGZpbHRlci5sZW5ndGggPj0gMiAmJiBmaWx0ZXJbMV0gIT09ICckaWQnICYmIGZpbHRlclsxXSAhPT0gJyR0eXBlJztcblxuICAgIGNhc2UgJ2luJzpcbiAgICBjYXNlICchaW4nOlxuICAgIGNhc2UgJyFoYXMnOlxuICAgIGNhc2UgJ25vbmUnOlxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBjYXNlICc9PSc6XG4gICAgY2FzZSAnIT0nOlxuICAgIGNhc2UgJz4nOlxuICAgIGNhc2UgJz49JzpcbiAgICBjYXNlICc8JzpcbiAgICBjYXNlICc8PSc6XG4gICAgICAgIHJldHVybiBmaWx0ZXIubGVuZ3RoID09PSAzICYmIChBcnJheS5pc0FycmF5KGZpbHRlclsxXSkgfHwgQXJyYXkuaXNBcnJheShmaWx0ZXJbMl0pKTtcblxuICAgIGNhc2UgJ2FueSc6XG4gICAgY2FzZSAnYWxsJzpcbiAgICAgICAgZm9yIChjb25zdCBmIG9mIGZpbHRlci5zbGljZSgxKSkge1xuICAgICAgICAgICAgaWYgKCFpc0V4cHJlc3Npb25GaWx0ZXIoZikgJiYgdHlwZW9mIGYgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cblxuY29uc3QgdHlwZXMgPSBbJ1Vua25vd24nLCAnUG9pbnQnLCAnTGluZVN0cmluZycsICdQb2x5Z29uJ107XG5cbmNvbnN0IGZpbHRlclNwZWMgPSB7XG4gICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgJ2RlZmF1bHQnOiBmYWxzZSxcbiAgICAnZnVuY3Rpb24nOiB0cnVlLFxuICAgICdwcm9wZXJ0eS1mdW5jdGlvbic6IHRydWVcbn07XG5cbi8qKlxuICogR2l2ZW4gYSBmaWx0ZXIgZXhwcmVzc2VkIGFzIG5lc3RlZCBhcnJheXMsIHJldHVybiBhIG5ldyBmdW5jdGlvblxuICogdGhhdCBldmFsdWF0ZXMgd2hldGhlciBhIGdpdmVuIGZlYXR1cmUgKHdpdGggYSAucHJvcGVydGllcyBvciAudGFncyBwcm9wZXJ0eSlcbiAqIHBhc3NlcyBpdHMgdGVzdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gZmlsdGVyIG1hcGJveCBnbCBmaWx0ZXJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gZmlsdGVyLWV2YWx1YXRpbmcgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRmlsdGVyKGZpbHRlciAgICAgKSAgICAgICAgICAgICAgICB7XG4gICAgaWYgKCFmaWx0ZXIpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCFpc0V4cHJlc3Npb25GaWx0ZXIoZmlsdGVyKSkge1xuICAgICAgICByZXR1cm4gKG5ldyBGdW5jdGlvbignZycsICdmJywgYHZhciBwID0gKGYgJiYgZi5wcm9wZXJ0aWVzIHx8IHt9KTsgcmV0dXJuICR7Y29tcGlsZShmaWx0ZXIpfWApICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbXBpbGVkID0gY3JlYXRlRXhwcmVzc2lvbihmaWx0ZXIsIGZpbHRlclNwZWMsICdmaWx0ZXInKTtcbiAgICBpZiAoY29tcGlsZWQucmVzdWx0ID09PSAnc3VjY2VzcycpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBpbGVkLmV2YWx1YXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihjb21waWxlZC5lcnJvcnMubWFwKGVyciA9PiBgJHtlcnIua2V5fTogJHtlcnIubWVzc2FnZX1gKS5qb2luKCcsICcpKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGUoZmlsdGVyKSB7XG4gICAgaWYgKCFmaWx0ZXIpIHJldHVybiAndHJ1ZSc7XG4gICAgY29uc3Qgb3AgPSBmaWx0ZXJbMF07XG4gICAgaWYgKGZpbHRlci5sZW5ndGggPD0gMSkgcmV0dXJuIG9wID09PSAnYW55JyA/ICdmYWxzZScgOiAndHJ1ZSc7XG4gICAgY29uc3Qgc3RyID1cbiAgICAgICAgb3AgPT09ICc9PScgPyBjb21waWxlQ29tcGFyaXNvbk9wKGZpbHRlclsxXSwgZmlsdGVyWzJdLCAnPT09JywgZmFsc2UpIDpcbiAgICAgICAgb3AgPT09ICchPScgPyBjb21waWxlQ29tcGFyaXNvbk9wKGZpbHRlclsxXSwgZmlsdGVyWzJdLCAnIT09JywgZmFsc2UpIDpcbiAgICAgICAgb3AgPT09ICc8JyB8fFxuICAgICAgICBvcCA9PT0gJz4nIHx8XG4gICAgICAgIG9wID09PSAnPD0nIHx8XG4gICAgICAgIG9wID09PSAnPj0nID8gY29tcGlsZUNvbXBhcmlzb25PcChmaWx0ZXJbMV0sIGZpbHRlclsyXSwgb3AsIHRydWUpIDpcbiAgICAgICAgb3AgPT09ICdhbnknID8gY29tcGlsZUxvZ2ljYWxPcChmaWx0ZXIuc2xpY2UoMSksICd8fCcpIDpcbiAgICAgICAgb3AgPT09ICdhbGwnID8gY29tcGlsZUxvZ2ljYWxPcChmaWx0ZXIuc2xpY2UoMSksICcmJicpIDpcbiAgICAgICAgb3AgPT09ICdub25lJyA/IGNvbXBpbGVOZWdhdGlvbihjb21waWxlTG9naWNhbE9wKGZpbHRlci5zbGljZSgxKSwgJ3x8JykpIDpcbiAgICAgICAgb3AgPT09ICdpbicgPyBjb21waWxlSW5PcChmaWx0ZXJbMV0sIGZpbHRlci5zbGljZSgyKSkgOlxuICAgICAgICBvcCA9PT0gJyFpbicgPyBjb21waWxlTmVnYXRpb24oY29tcGlsZUluT3AoZmlsdGVyWzFdLCBmaWx0ZXIuc2xpY2UoMikpKSA6XG4gICAgICAgIG9wID09PSAnaGFzJyA/IGNvbXBpbGVIYXNPcChmaWx0ZXJbMV0pIDpcbiAgICAgICAgb3AgPT09ICchaGFzJyA/IGNvbXBpbGVOZWdhdGlvbihjb21waWxlSGFzT3AoZmlsdGVyWzFdKSkgOlxuICAgICAgICAndHJ1ZSc7XG4gICAgcmV0dXJuIGAoJHtzdHJ9KWA7XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVQcm9wZXJ0eVJlZmVyZW5jZShwcm9wZXJ0eSkge1xuICAgIGNvbnN0IHJlZiA9XG4gICAgICAgIHByb3BlcnR5ID09PSAnJHR5cGUnID8gJ2YudHlwZScgOlxuICAgICAgICBwcm9wZXJ0eSA9PT0gJyRpZCcgPyAnZi5pZCcgOiBgcFske0pTT04uc3RyaW5naWZ5KHByb3BlcnR5KX1dYDtcbiAgICByZXR1cm4gcmVmO1xufVxuXG5mdW5jdGlvbiBjb21waWxlQ29tcGFyaXNvbk9wKHByb3BlcnR5LCB2YWx1ZSwgb3AsIGNoZWNrVHlwZSkge1xuICAgIGNvbnN0IGxlZnQgPSBjb21waWxlUHJvcGVydHlSZWZlcmVuY2UocHJvcGVydHkpO1xuICAgIGNvbnN0IHJpZ2h0ID0gcHJvcGVydHkgPT09ICckdHlwZScgPyB0eXBlcy5pbmRleE9mKHZhbHVlKSA6IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICByZXR1cm4gKGNoZWNrVHlwZSA/IGB0eXBlb2YgJHtsZWZ0fT09PSB0eXBlb2YgJHtyaWdodH0mJmAgOiAnJykgKyBsZWZ0ICsgb3AgKyByaWdodDtcbn1cblxuZnVuY3Rpb24gY29tcGlsZUxvZ2ljYWxPcChleHByZXNzaW9ucywgb3ApIHtcbiAgICByZXR1cm4gZXhwcmVzc2lvbnMubWFwKGNvbXBpbGUpLmpvaW4ob3ApO1xufVxuXG5mdW5jdGlvbiBjb21waWxlSW5PcChwcm9wZXJ0eSwgdmFsdWVzKSB7XG4gICAgaWYgKHByb3BlcnR5ID09PSAnJHR5cGUnKSB2YWx1ZXMgPSB2YWx1ZXMubWFwKCh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gdHlwZXMuaW5kZXhPZih2YWx1ZSk7XG4gICAgfSk7XG4gICAgY29uc3QgbGVmdCA9IEpTT04uc3RyaW5naWZ5KHZhbHVlcy5zb3J0KGNvbXBhcmUpKTtcbiAgICBjb25zdCByaWdodCA9IGNvbXBpbGVQcm9wZXJ0eVJlZmVyZW5jZShwcm9wZXJ0eSk7XG5cbiAgICBpZiAodmFsdWVzLmxlbmd0aCA8PSAyMDApIHJldHVybiBgJHtsZWZ0fS5pbmRleE9mKCR7cmlnaHR9KSAhPT0gLTFgO1xuXG4gICAgcmV0dXJuIGAkeydmdW5jdGlvbih2LCBhLCBpLCBqKSB7JyArXG4gICAgICAgICd3aGlsZSAoaSA8PSBqKSB7IHZhciBtID0gKGkgKyBqKSA+PiAxOycgK1xuICAgICAgICAnICAgIGlmIChhW21dID09PSB2KSByZXR1cm4gdHJ1ZTsgaWYgKGFbbV0gPiB2KSBqID0gbSAtIDE7IGVsc2UgaSA9IG0gKyAxOycgK1xuICAgICAgICAnfScgK1xuICAgICdyZXR1cm4gZmFsc2U7IH0oJ30ke3JpZ2h0fSwgJHtsZWZ0fSwwLCR7dmFsdWVzLmxlbmd0aCAtIDF9KWA7XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVIYXNPcChwcm9wZXJ0eSkge1xuICAgIHJldHVybiBwcm9wZXJ0eSA9PT0gJyRpZCcgPyAnXCJpZFwiIGluIGYnIDogYCR7SlNPTi5zdHJpbmdpZnkocHJvcGVydHkpfSBpbiBwYDtcbn1cblxuZnVuY3Rpb24gY29tcGlsZU5lZ2F0aW9uKGV4cHJlc3Npb24pIHtcbiAgICByZXR1cm4gYCEoJHtleHByZXNzaW9ufSlgO1xufVxuXG4vLyBDb21wYXJpc29uIGZ1bmN0aW9uIHRvIHNvcnQgbnVtYmVycyBhbmQgc3RyaW5nc1xuZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwO1xufVxuIiwiXG5jb25zdCByZWZlcmVuY2UgPSByZXF1aXJlKCcuL3JlZmVyZW5jZS9sYXRlc3QuanMnKTtcbmNvbnN0IHNvcnRPYmplY3QgPSByZXF1aXJlKCdzb3J0LW9iamVjdCcpO1xuXG5mdW5jdGlvbiBzYW1lT3JkZXJBcyhyZWZlcmVuY2UpIHtcbiAgICBjb25zdCBrZXlPcmRlciA9IHt9O1xuXG4gICAgT2JqZWN0LmtleXMocmVmZXJlbmNlKS5mb3JFYWNoKChrLCBpKSA9PiB7XG4gICAgICAgIGtleU9yZGVyW2tdID0gaSArIDE7XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzb3J0OiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIChrZXlPcmRlclthXSB8fCBJbmZpbml0eSkgLVxuICAgICAgICAgICAgICAgICAgIChrZXlPcmRlcltiXSB8fCBJbmZpbml0eSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vKipcbiAqIEZvcm1hdCBhIE1hcGJveCBHTCBTdHlsZS4gIFJldHVybnMgYSBzdHJpbmdpZmllZCBzdHlsZSB3aXRoIGl0cyBrZXlzXG4gKiBzb3J0ZWQgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlIHJlZmVyZW5jZSBzdHlsZS5cbiAqXG4gKiBUaGUgb3B0aW9uYWwgYHNwYWNlYCBhcmd1bWVudCBpcyBwYXNzZWQgdG9cbiAqIFtgSlNPTi5zdHJpbmdpZnlgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9KU09OL3N0cmluZ2lmeSlcbiAqIHRvIGdlbmVyYXRlIGZvcm1hdHRlZCBvdXRwdXQuXG4gKlxuICogSWYgYHNwYWNlYCBpcyB1bnNwZWNpZmllZCwgYSBkZWZhdWx0IG9mIGAyYCBzcGFjZXMgd2lsbCBiZSB1c2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc3R5bGUgYSBNYXBib3ggR0wgU3R5bGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3BhY2VdIHNwYWNlIGFyZ3VtZW50IHRvIHBhc3MgdG8gYEpTT04uc3RyaW5naWZ5YFxuICogQHJldHVybnMge3N0cmluZ30gc3RyaW5naWZpZWQgZm9ybWF0dGVkIEpTT05cbiAqIEBleGFtcGxlXG4gKiB2YXIgZnMgPSByZXF1aXJlKCdmcycpO1xuICogdmFyIGZvcm1hdCA9IHJlcXVpcmUoJ21hcGJveC1nbC1zdHlsZS1zcGVjJykuZm9ybWF0O1xuICogdmFyIHN0eWxlID0gZnMucmVhZEZpbGVTeW5jKCcuL3NvdXJjZS5qc29uJywgJ3V0ZjgnKTtcbiAqIGZzLndyaXRlRmlsZVN5bmMoJy4vZGVzdC5qc29uJywgZm9ybWF0KHN0eWxlKSk7XG4gKiBmcy53cml0ZUZpbGVTeW5jKCcuL2Rlc3QubWluLmpzb24nLCBmb3JtYXQoc3R5bGUsIDApKTtcbiAqL1xuZnVuY3Rpb24gZm9ybWF0KHN0eWxlLCBzcGFjZSkge1xuICAgIGlmIChzcGFjZSA9PT0gdW5kZWZpbmVkKSBzcGFjZSA9IDI7XG4gICAgc3R5bGUgPSBzb3J0T2JqZWN0KHN0eWxlLCBzYW1lT3JkZXJBcyhyZWZlcmVuY2UuJHJvb3QpKTtcblxuICAgIGlmIChzdHlsZS5sYXllcnMpIHtcbiAgICAgICAgc3R5bGUubGF5ZXJzID0gc3R5bGUubGF5ZXJzLm1hcCgobGF5ZXIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzb3J0T2JqZWN0KGxheWVyLCBzYW1lT3JkZXJBcyhyZWZlcmVuY2UubGF5ZXIpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0eWxlLCBudWxsLCBzcGFjZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZm9ybWF0O1xuIiwiY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5jb25zdCBleHRlbmQgPSByZXF1aXJlKCcuLi91dGlsL2V4dGVuZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnZlcnRGdW5jdGlvbjtcblxuZnVuY3Rpb24gY29udmVydEZ1bmN0aW9uKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYywgbmFtZSkge1xuICAgIGxldCBleHByZXNzaW9uO1xuXG4gICAgcGFyYW1ldGVycyA9IGV4dGVuZCh7fSwgcGFyYW1ldGVycyk7XG4gICAgbGV0IGRlZmF1bHRFeHByZXNzaW9uO1xuICAgIGlmICh0eXBlb2YgcGFyYW1ldGVycy5kZWZhdWx0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBkZWZhdWx0RXhwcmVzc2lvbiA9IGNvbnZlcnRWYWx1ZShwYXJhbWV0ZXJzLmRlZmF1bHQsIHByb3BlcnR5U3BlYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZGVmYXVsdEV4cHJlc3Npb24gPSBjb252ZXJ0VmFsdWUocHJvcGVydHlTcGVjLmRlZmF1bHQsIHByb3BlcnR5U3BlYyk7XG4gICAgICAgIGlmIChkZWZhdWx0RXhwcmVzc2lvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZGVmYXVsdEV4cHJlc3Npb24gPSBbJ2Vycm9yJywgJ05vIGRlZmF1bHQgcHJvcGVydHkgdmFsdWUgYXZhaWxhYmxlLiddO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtZXRlcnMuc3RvcHMpIHtcbiAgICAgICAgY29uc3Qgem9vbUFuZEZlYXR1cmVEZXBlbmRlbnQgPSBwYXJhbWV0ZXJzLnN0b3BzICYmIHR5cGVvZiBwYXJhbWV0ZXJzLnN0b3BzWzBdWzBdID09PSAnb2JqZWN0JztcbiAgICAgICAgY29uc3QgZmVhdHVyZURlcGVuZGVudCA9IHpvb21BbmRGZWF0dXJlRGVwZW5kZW50IHx8IHBhcmFtZXRlcnMucHJvcGVydHkgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgem9vbURlcGVuZGVudCA9IHpvb21BbmRGZWF0dXJlRGVwZW5kZW50IHx8ICFmZWF0dXJlRGVwZW5kZW50O1xuXG4gICAgICAgIGNvbnN0IHN0b3BzID0gcGFyYW1ldGVycy5zdG9wcy5tYXAoKHN0b3ApID0+IHtcbiAgICAgICAgICAgIHJldHVybiBbc3RvcFswXSwgY29udmVydFZhbHVlKHN0b3BbMV0sIHByb3BlcnR5U3BlYyldO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAocGFyYW1ldGVycy5jb2xvclNwYWNlICYmIHBhcmFtZXRlcnMuY29sb3JTcGFjZSAhPT0gJ3JnYicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5pbXBsZW1lbnRlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5hbWUgPT09ICdoZWF0bWFwLWNvbG9yJykge1xuICAgICAgICAgICAgYXNzZXJ0KHpvb21EZXBlbmRlbnQpO1xuICAgICAgICAgICAgZXhwcmVzc2lvbiA9IGNvbnZlcnRab29tRnVuY3Rpb24ocGFyYW1ldGVycywgcHJvcGVydHlTcGVjLCBzdG9wcywgWydoZWF0bWFwLWRlbnNpdHknXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoem9vbUFuZEZlYXR1cmVEZXBlbmRlbnQpIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb24gPSBjb252ZXJ0Wm9vbUFuZFByb3BlcnR5RnVuY3Rpb24ocGFyYW1ldGVycywgcHJvcGVydHlTcGVjLCBzdG9wcywgZGVmYXVsdEV4cHJlc3Npb24pO1xuICAgICAgICB9IGVsc2UgaWYgKHpvb21EZXBlbmRlbnQpIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb24gPSBjb252ZXJ0Wm9vbUZ1bmN0aW9uKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYywgc3RvcHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhwcmVzc2lvbiA9IGNvbnZlcnRQcm9wZXJ0eUZ1bmN0aW9uKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYywgc3RvcHMsIGRlZmF1bHRFeHByZXNzaW9uKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlkZW50aXR5IGZ1bmN0aW9uXG4gICAgICAgIGV4cHJlc3Npb24gPSBjb252ZXJ0SWRlbnRpdHlGdW5jdGlvbihwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMsIGRlZmF1bHRFeHByZXNzaW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXhwcmVzc2lvbjtcbn1cblxuZnVuY3Rpb24gY29udmVydElkZW50aXR5RnVuY3Rpb24ocGFyYW1ldGVycywgcHJvcGVydHlTcGVjLCBkZWZhdWx0RXhwcmVzc2lvbikge1xuICAgIGNvbnN0IGdldCA9IFsnZ2V0JywgcGFyYW1ldGVycy5wcm9wZXJ0eV07XG4gICAgY29uc3QgdHlwZSA9IHByb3BlcnR5U3BlYy50eXBlO1xuICAgIGlmICh0eXBlID09PSAnY29sb3InKSB7XG4gICAgICAgIHJldHVybiBbJ3RvLWNvbG9yJywgZ2V0LCBwYXJhbWV0ZXJzLmRlZmF1bHQgfHwgbnVsbCwgcHJvcGVydHlTcGVjLmRlZmF1bHQgfHwgbnVsbF07XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnYXJyYXknICYmIHR5cGVvZiBwcm9wZXJ0eVNwZWMubGVuZ3RoID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gWydhcnJheScsIHByb3BlcnR5U3BlYy52YWx1ZSwgcHJvcGVydHlTcGVjLmxlbmd0aCwgZ2V0XTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdhcnJheScpIHtcbiAgICAgICAgcmV0dXJuIFsnYXJyYXknLCBwcm9wZXJ0eVNwZWMudmFsdWUsIGdldF07XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnZW51bScpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICdsZXQnLFxuICAgICAgICAgICAgJ3Byb3BlcnR5X3ZhbHVlJywgWydzdHJpbmcnLCBnZXRdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdtYXRjaCcsXG4gICAgICAgICAgICAgICAgWyd2YXInLCAncHJvcGVydHlfdmFsdWUnXSxcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhwcm9wZXJ0eVNwZWMudmFsdWVzKSwgWyd2YXInLCAncHJvcGVydHlfdmFsdWUnXSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0RXhwcmVzc2lvblxuICAgICAgICAgICAgXVxuICAgICAgICBdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbcHJvcGVydHlTcGVjLnR5cGUsIGdldCwgcGFyYW1ldGVycy5kZWZhdWx0IHx8IG51bGwsIHByb3BlcnR5U3BlYy5kZWZhdWx0IHx8IG51bGxdO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY29udmVydFZhbHVlKHZhbHVlLCBzcGVjKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdmFsdWUgPT09IG51bGwpIHJldHVybiBudWxsO1xuICAgIGlmIChzcGVjLnR5cGUgPT09ICdjb2xvcicpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gZWxzZSBpZiAoc3BlYy50eXBlID09PSAnYXJyYXknKSB7XG4gICAgICAgIHJldHVybiBbJ2xpdGVyYWwnLCB2YWx1ZV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY29udmVydFpvb21BbmRQcm9wZXJ0eUZ1bmN0aW9uKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYywgc3RvcHMsIGRlZmF1bHRFeHByZXNzaW9uKSB7XG4gICAgY29uc3QgZmVhdHVyZUZ1bmN0aW9uUGFyYW1ldGVycyA9IHt9O1xuICAgIGNvbnN0IGZlYXR1cmVGdW5jdGlvblN0b3BzID0ge307XG4gICAgY29uc3Qgem9vbVN0b3BzID0gW107XG4gICAgZm9yIChsZXQgcyA9IDA7IHMgPCBzdG9wcy5sZW5ndGg7IHMrKykge1xuICAgICAgICBjb25zdCBzdG9wID0gc3RvcHNbc107XG4gICAgICAgIGNvbnN0IHpvb20gPSBzdG9wWzBdLnpvb207XG4gICAgICAgIGlmIChmZWF0dXJlRnVuY3Rpb25QYXJhbWV0ZXJzW3pvb21dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZlYXR1cmVGdW5jdGlvblBhcmFtZXRlcnNbem9vbV0gPSB7XG4gICAgICAgICAgICAgICAgem9vbTogem9vbSxcbiAgICAgICAgICAgICAgICB0eXBlOiBwYXJhbWV0ZXJzLnR5cGUsXG4gICAgICAgICAgICAgICAgcHJvcGVydHk6IHBhcmFtZXRlcnMucHJvcGVydHksXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogcGFyYW1ldGVycy5kZWZhdWx0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZlYXR1cmVGdW5jdGlvblN0b3BzW3pvb21dID0gW107XG4gICAgICAgICAgICB6b29tU3RvcHMucHVzaCh6b29tKTtcbiAgICAgICAgfVxuICAgICAgICBmZWF0dXJlRnVuY3Rpb25TdG9wc1t6b29tXS5wdXNoKFtzdG9wWzBdLnZhbHVlLCBzdG9wWzFdXSk7XG4gICAgfVxuXG4gICAgLy8gdGhlIGludGVycG9sYXRpb24gdHlwZSBmb3IgdGhlIHpvb20gZGltZW5zaW9uIG9mIGEgem9vbS1hbmQtcHJvcGVydHlcbiAgICAvLyBmdW5jdGlvbiBpcyBkZXRlcm1pbmVkIGRpcmVjdGx5IGZyb20gdGhlIHN0eWxlIHByb3BlcnR5IHNwZWNpZmljYXRpb25cbiAgICAvLyBmb3Igd2hpY2ggaXQncyBiZWluZyB1c2VkOiBsaW5lYXIgZm9yIGludGVycG9sYXRhYmxlIHByb3BlcnRpZXMsIHN0ZXBcbiAgICAvLyBvdGhlcndpc2UuXG4gICAgY29uc3QgZnVuY3Rpb25UeXBlID0gZ2V0RnVuY3Rpb25UeXBlKHt9LCBwcm9wZXJ0eVNwZWMpO1xuICAgIGxldCBpbnRlcnBvbGF0aW9uVHlwZTtcbiAgICBsZXQgaXNTdGVwID0gZmFsc2U7XG4gICAgaWYgKGZ1bmN0aW9uVHlwZSA9PT0gJ2V4cG9uZW50aWFsJykge1xuICAgICAgICBpbnRlcnBvbGF0aW9uVHlwZSA9IFsnbGluZWFyJ107XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaW50ZXJwb2xhdGlvblR5cGUgPSBbJ3N0ZXAnXTtcbiAgICAgICAgaXNTdGVwID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgZXhwcmVzc2lvbiA9IFsnY3VydmUnLCBpbnRlcnBvbGF0aW9uVHlwZSwgWyd6b29tJ11dO1xuXG4gICAgZm9yIChjb25zdCB6IG9mIHpvb21TdG9wcykge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBjb252ZXJ0UHJvcGVydHlGdW5jdGlvbihmZWF0dXJlRnVuY3Rpb25QYXJhbWV0ZXJzW3pdLCBwcm9wZXJ0eVNwZWMsIGZlYXR1cmVGdW5jdGlvblN0b3BzW3pdLCBkZWZhdWx0RXhwcmVzc2lvbik7XG4gICAgICAgIGFwcGVuZFN0b3BQYWlyKGV4cHJlc3Npb24sIHosIG91dHB1dCwgaXNTdGVwKTtcbiAgICB9XG5cbiAgICBmaXh1cERlZ2VuZXJhdGVTdGVwQ3VydmUoZXhwcmVzc2lvbik7XG5cbiAgICByZXR1cm4gZXhwcmVzc2lvbjtcbn1cblxuZnVuY3Rpb24gY29udmVydFByb3BlcnR5RnVuY3Rpb24ocGFyYW1ldGVycywgcHJvcGVydHlTcGVjLCBzdG9wcywgZGVmYXVsdEV4cHJlc3Npb24pIHtcbiAgICBjb25zdCB0eXBlID0gZ2V0RnVuY3Rpb25UeXBlKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYyk7XG5cbiAgICBjb25zdCBpbnB1dFR5cGUgPSB0eXBlb2Ygc3RvcHNbMF1bMF07XG4gICAgYXNzZXJ0KFxuICAgICAgICBpbnB1dFR5cGUgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgIGlucHV0VHlwZSA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgaW5wdXRUeXBlID09PSAnYm9vbGVhbidcbiAgICApO1xuXG4gICAgbGV0IGlucHV0ID0gW2lucHV0VHlwZSwgWydnZXQnLCBwYXJhbWV0ZXJzLnByb3BlcnR5XV07XG5cbiAgICBsZXQgZXhwcmVzc2lvbjtcbiAgICBsZXQgaXNTdGVwID0gZmFsc2U7XG4gICAgaWYgKHR5cGUgPT09ICdjYXRlZ29yaWNhbCcgJiYgaW5wdXRUeXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgYXNzZXJ0KHBhcmFtZXRlcnMuc3RvcHMubGVuZ3RoID4gMCAmJiBwYXJhbWV0ZXJzLnN0b3BzLmxlbmd0aCA8PSAyKTtcbiAgICAgICAgaWYgKHBhcmFtZXRlcnMuc3RvcHNbMF1bMF0gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpbnB1dCA9IFsnIScsIGlucHV0XTtcbiAgICAgICAgfVxuICAgICAgICBleHByZXNzaW9uID0gWyAnY2FzZScsIGlucHV0LCBwYXJhbWV0ZXJzLnN0b3BzWzBdWzFdIF07XG4gICAgICAgIGlmIChwYXJhbWV0ZXJzLnN0b3BzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb24ucHVzaChwYXJhbWV0ZXJzLnN0b3BzWzFdWzFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb24ucHVzaChkZWZhdWx0RXhwcmVzc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb247XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnY2F0ZWdvcmljYWwnKSB7XG4gICAgICAgIGV4cHJlc3Npb24gPSBbJ21hdGNoJywgaW5wdXRdO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2ludGVydmFsJykge1xuICAgICAgICBleHByZXNzaW9uID0gWydjdXJ2ZScsIFsnc3RlcCddLCBpbnB1dF07XG4gICAgICAgIGlzU3RlcCA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnZXhwb25lbnRpYWwnKSB7XG4gICAgICAgIGNvbnN0IGJhc2UgPSBwYXJhbWV0ZXJzLmJhc2UgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuYmFzZSA6IDE7XG4gICAgICAgIGV4cHJlc3Npb24gPSBbJ2N1cnZlJywgWydleHBvbmVudGlhbCcsIGJhc2VdLCBpbnB1dF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHByb3BlcnR5IGZ1bmN0aW9uIHR5cGUgJHt0eXBlfWApO1xuICAgIH1cblxuICAgIGZvciAoY29uc3Qgc3RvcCBvZiBzdG9wcykge1xuICAgICAgICBhcHBlbmRTdG9wUGFpcihleHByZXNzaW9uLCBzdG9wWzBdLCBzdG9wWzFdLCBpc1N0ZXApO1xuICAgIH1cblxuICAgIGlmIChleHByZXNzaW9uWzBdID09PSAnbWF0Y2gnKSB7XG4gICAgICAgIGV4cHJlc3Npb24ucHVzaChkZWZhdWx0RXhwcmVzc2lvbik7XG4gICAgfVxuXG4gICAgZml4dXBEZWdlbmVyYXRlU3RlcEN1cnZlKGV4cHJlc3Npb24pO1xuXG4gICAgcmV0dXJuIGV4cHJlc3Npb247XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRab29tRnVuY3Rpb24ocGFyYW1ldGVycywgcHJvcGVydHlTcGVjLCBzdG9wcywgaW5wdXQgPSBbJ3pvb20nXSkge1xuICAgIGNvbnN0IHR5cGUgPSBnZXRGdW5jdGlvblR5cGUocGFyYW1ldGVycywgcHJvcGVydHlTcGVjKTtcbiAgICBsZXQgZXhwcmVzc2lvbjtcbiAgICBsZXQgaXNTdGVwID0gZmFsc2U7XG4gICAgaWYgKHR5cGUgPT09ICdpbnRlcnZhbCcpIHtcbiAgICAgICAgZXhwcmVzc2lvbiA9IFsnY3VydmUnLCBbJ3N0ZXAnXSwgaW5wdXRdO1xuICAgICAgICBpc1N0ZXAgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2V4cG9uZW50aWFsJykge1xuICAgICAgICBjb25zdCBiYXNlID0gcGFyYW1ldGVycy5iYXNlICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmJhc2UgOiAxO1xuICAgICAgICBleHByZXNzaW9uID0gWydjdXJ2ZScsIFsnZXhwb25lbnRpYWwnLCBiYXNlXSwgaW5wdXRdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biB6b29tIGZ1bmN0aW9uIHR5cGUgXCIke3R5cGV9XCJgKTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHN0b3Agb2Ygc3RvcHMpIHtcbiAgICAgICAgYXBwZW5kU3RvcFBhaXIoZXhwcmVzc2lvbiwgc3RvcFswXSwgc3RvcFsxXSwgaXNTdGVwKTtcbiAgICB9XG5cbiAgICBmaXh1cERlZ2VuZXJhdGVTdGVwQ3VydmUoZXhwcmVzc2lvbik7XG5cbiAgICByZXR1cm4gZXhwcmVzc2lvbjtcbn1cblxuZnVuY3Rpb24gZml4dXBEZWdlbmVyYXRlU3RlcEN1cnZlKGV4cHJlc3Npb24pIHtcbiAgICAvLyBkZWdlbmVyYXRlIHN0ZXAgY3VydmUgKGkuZS4gYSBjb25zdGFudCBmdW5jdGlvbik6IGFkZCBhIG5vb3Agc3RvcFxuICAgIGlmIChleHByZXNzaW9uWzBdID09PSAnY3VydmUnICYmIGV4cHJlc3Npb25bMV1bMF0gPT09ICdzdGVwJyAmJiBleHByZXNzaW9uLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICBleHByZXNzaW9uLnB1c2goMCk7XG4gICAgICAgIGV4cHJlc3Npb24ucHVzaChleHByZXNzaW9uWzNdKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFwcGVuZFN0b3BQYWlyKGN1cnZlLCBpbnB1dCwgb3V0cHV0LCBpc1N0ZXApIHtcbiAgICAvLyBzdGVwIGN1cnZlcyBkb24ndCBnZXQgdGhlIGZpcnN0IGlucHV0IHZhbHVlLCBhcyBpdCBpcyByZWR1bmRhbnQuXG4gICAgaWYgKCEoaXNTdGVwICYmIGN1cnZlLmxlbmd0aCA9PT0gMykpIHtcbiAgICAgICAgY3VydmUucHVzaChpbnB1dCk7XG4gICAgfVxuICAgIGN1cnZlLnB1c2gob3V0cHV0KTtcbn1cblxuZnVuY3Rpb24gZ2V0RnVuY3Rpb25UeXBlIChwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMpIHtcbiAgICBpZiAocGFyYW1ldGVycy50eXBlKSB7XG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJzLnR5cGU7XG4gICAgfSBlbHNlIGlmIChwcm9wZXJ0eVNwZWMuZnVuY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHByb3BlcnR5U3BlYy5mdW5jdGlvbiA9PT0gJ2ludGVycG9sYXRlZCcgPyAnZXhwb25lbnRpYWwnIDogJ2ludGVydmFsJztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJ2V4cG9uZW50aWFsJztcbiAgICB9XG59XG4iLCJcbmNvbnN0IGNvbG9yU3BhY2VzID0gcmVxdWlyZSgnLi4vdXRpbC9jb2xvcl9zcGFjZXMnKTtcbmNvbnN0IHBhcnNlQ29sb3IgPSByZXF1aXJlKCcuLi91dGlsL3BhcnNlX2NvbG9yJyk7XG5jb25zdCBleHRlbmQgPSByZXF1aXJlKCcuLi91dGlsL2V4dGVuZCcpO1xuY29uc3QgZ2V0VHlwZSA9IHJlcXVpcmUoJy4uL3V0aWwvZ2V0X3R5cGUnKTtcbmNvbnN0IGludGVycG9sYXRlID0gcmVxdWlyZSgnLi4vdXRpbC9pbnRlcnBvbGF0ZScpO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpO1xufVxuXG5mdW5jdGlvbiBpZGVudGl0eUZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4geDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb24ocGFyYW1ldGVycywgcHJvcGVydHlTcGVjLCBuYW1lKSB7XG4gICAgY29uc3QgaXNDb2xvciA9IHByb3BlcnR5U3BlYy50eXBlID09PSAnY29sb3InO1xuICAgIGNvbnN0IHpvb21BbmRGZWF0dXJlRGVwZW5kZW50ID0gcGFyYW1ldGVycy5zdG9wcyAmJiB0eXBlb2YgcGFyYW1ldGVycy5zdG9wc1swXVswXSA9PT0gJ29iamVjdCc7XG4gICAgY29uc3QgZmVhdHVyZURlcGVuZGVudCA9IHpvb21BbmRGZWF0dXJlRGVwZW5kZW50IHx8IHBhcmFtZXRlcnMucHJvcGVydHkgIT09IHVuZGVmaW5lZDtcbiAgICBjb25zdCB6b29tRGVwZW5kZW50ID0gem9vbUFuZEZlYXR1cmVEZXBlbmRlbnQgfHwgIWZlYXR1cmVEZXBlbmRlbnQ7XG4gICAgY29uc3QgdHlwZSA9IHBhcmFtZXRlcnMudHlwZSB8fCAocHJvcGVydHlTcGVjLmZ1bmN0aW9uID09PSAnaW50ZXJwb2xhdGVkJyA/ICdleHBvbmVudGlhbCcgOiAnaW50ZXJ2YWwnKTtcblxuICAgIGlmIChpc0NvbG9yKSB7XG4gICAgICAgIHBhcmFtZXRlcnMgPSBleHRlbmQoe30sIHBhcmFtZXRlcnMpO1xuXG4gICAgICAgIGlmIChwYXJhbWV0ZXJzLnN0b3BzKSB7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzLnN0b3BzID0gcGFyYW1ldGVycy5zdG9wcy5tYXAoKHN0b3ApID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3N0b3BbMF0sIHBhcnNlQ29sb3Ioc3RvcFsxXSldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyYW1ldGVycy5kZWZhdWx0KSB7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzLmRlZmF1bHQgPSBwYXJzZUNvbG9yKHBhcmFtZXRlcnMuZGVmYXVsdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzLmRlZmF1bHQgPSBwYXJzZUNvbG9yKHByb3BlcnR5U3BlYy5kZWZhdWx0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxldCBpbm5lckZ1bjtcbiAgICBsZXQgaGFzaGVkU3RvcHM7XG4gICAgbGV0IGNhdGVnb3JpY2FsS2V5VHlwZTtcbiAgICBpZiAodHlwZSA9PT0gJ2V4cG9uZW50aWFsJykge1xuICAgICAgICBpbm5lckZ1biA9IGV2YWx1YXRlRXhwb25lbnRpYWxGdW5jdGlvbjtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdpbnRlcnZhbCcpIHtcbiAgICAgICAgaW5uZXJGdW4gPSBldmFsdWF0ZUludGVydmFsRnVuY3Rpb247XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnY2F0ZWdvcmljYWwnKSB7XG4gICAgICAgIGlubmVyRnVuID0gZXZhbHVhdGVDYXRlZ29yaWNhbEZ1bmN0aW9uO1xuXG4gICAgICAgIC8vIEZvciBjYXRlZ29yaWNhbCBmdW5jdGlvbnMsIGdlbmVyYXRlIGFuIE9iamVjdCBhcyBhIGhhc2htYXAgb2YgdGhlIHN0b3BzIGZvciBmYXN0IHNlYXJjaGluZ1xuICAgICAgICBoYXNoZWRTdG9wcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGZvciAoY29uc3Qgc3RvcCBvZiBwYXJhbWV0ZXJzLnN0b3BzKSB7XG4gICAgICAgICAgICBoYXNoZWRTdG9wc1tzdG9wWzBdXSA9IHN0b3BbMV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbmZlciBrZXkgdHlwZSBiYXNlZCBvbiBmaXJzdCBzdG9wIGtleS0tIHVzZWQgdG8gZW5jZm9yY2Ugc3RyaWN0IHR5cGUgY2hlY2tpbmcgbGF0ZXJcbiAgICAgICAgY2F0ZWdvcmljYWxLZXlUeXBlID0gdHlwZW9mIHBhcmFtZXRlcnMuc3RvcHNbMF1bMF07XG5cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdpZGVudGl0eScpIHtcbiAgICAgICAgaW5uZXJGdW4gPSBldmFsdWF0ZUlkZW50aXR5RnVuY3Rpb247XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGZ1bmN0aW9uIHR5cGUgXCIke3R5cGV9XCJgKTtcbiAgICB9XG5cbiAgICBsZXQgb3V0cHV0RnVuY3Rpb247XG5cbiAgICAvLyBJZiB3ZSdyZSBpbnRlcnBvbGF0aW5nIGNvbG9ycyBpbiBhIGNvbG9yIHN5c3RlbSBvdGhlciB0aGFuIFJHQkEsXG4gICAgLy8gZmlyc3QgdHJhbnNsYXRlIGFsbCBzdG9wIHZhbHVlcyB0byB0aGF0IGNvbG9yIHN5c3RlbSwgdGhlbiBpbnRlcnBvbGF0ZVxuICAgIC8vIGFycmF5cyBhcyB1c3VhbC4gVGhlIGBvdXRwdXRGdW5jdGlvbmAgb3B0aW9uIGxldHMgdXMgdGhlbiB0cmFuc2xhdGVcbiAgICAvLyB0aGUgcmVzdWx0IG9mIHRoYXQgaW50ZXJwb2xhdGlvbiBiYWNrIGludG8gUkdCQS5cbiAgICBpZiAocGFyYW1ldGVycy5jb2xvclNwYWNlICYmIHBhcmFtZXRlcnMuY29sb3JTcGFjZSAhPT0gJ3JnYicpIHtcbiAgICAgICAgaWYgKGNvbG9yU3BhY2VzW3BhcmFtZXRlcnMuY29sb3JTcGFjZV0pIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yc3BhY2UgPSBjb2xvclNwYWNlc1twYXJhbWV0ZXJzLmNvbG9yU3BhY2VdO1xuICAgICAgICAgICAgLy8gQXZvaWQgbXV0YXRpbmcgdGhlIHBhcmFtZXRlcnMgdmFsdWVcbiAgICAgICAgICAgIHBhcmFtZXRlcnMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHBhcmFtZXRlcnMpKTtcbiAgICAgICAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgcGFyYW1ldGVycy5zdG9wcy5sZW5ndGg7IHMrKykge1xuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuc3RvcHNbc10gPSBbXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuc3RvcHNbc11bMF0sXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yc3BhY2UuZm9yd2FyZChwYXJhbWV0ZXJzLnN0b3BzW3NdWzFdKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRwdXRGdW5jdGlvbiA9IGNvbG9yc3BhY2UucmV2ZXJzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBjb2xvciBzcGFjZTogJHtwYXJhbWV0ZXJzLmNvbG9yU3BhY2V9YCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXRGdW5jdGlvbiA9IGlkZW50aXR5RnVuY3Rpb247XG4gICAgfVxuXG4gICAgaWYgKHpvb21BbmRGZWF0dXJlRGVwZW5kZW50KSB7XG4gICAgICAgIGNvbnN0IGZlYXR1cmVGdW5jdGlvbnMgPSB7fTtcbiAgICAgICAgY29uc3Qgem9vbVN0b3BzID0gW107XG4gICAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgcGFyYW1ldGVycy5zdG9wcy5sZW5ndGg7IHMrKykge1xuICAgICAgICAgICAgY29uc3Qgc3RvcCA9IHBhcmFtZXRlcnMuc3RvcHNbc107XG4gICAgICAgICAgICBjb25zdCB6b29tID0gc3RvcFswXS56b29tO1xuICAgICAgICAgICAgaWYgKGZlYXR1cmVGdW5jdGlvbnNbem9vbV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGZlYXR1cmVGdW5jdGlvbnNbem9vbV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHpvb206IHpvb20sXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHBhcmFtZXRlcnMudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IHBhcmFtZXRlcnMucHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHBhcmFtZXRlcnMuZGVmYXVsdCxcbiAgICAgICAgICAgICAgICAgICAgc3RvcHM6IFtdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB6b29tU3RvcHMucHVzaCh6b29tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZlYXR1cmVGdW5jdGlvbnNbem9vbV0uc3RvcHMucHVzaChbc3RvcFswXS52YWx1ZSwgc3RvcFsxXV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZmVhdHVyZUZ1bmN0aW9uU3RvcHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB6IG9mIHpvb21TdG9wcykge1xuICAgICAgICAgICAgZmVhdHVyZUZ1bmN0aW9uU3RvcHMucHVzaChbZmVhdHVyZUZ1bmN0aW9uc1t6XS56b29tLCBjcmVhdGVGdW5jdGlvbihmZWF0dXJlRnVuY3Rpb25zW3pdLCBwcm9wZXJ0eVNwZWMpXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNGZWF0dXJlQ29uc3RhbnQ6IGZhbHNlLFxuICAgICAgICAgICAgaW50ZXJwb2xhdGlvbjoge25hbWU6ICdsaW5lYXInfSxcbiAgICAgICAgICAgIHpvb21TdG9wczogZmVhdHVyZUZ1bmN0aW9uU3RvcHMubWFwKHMgPT4gc1swXSksXG4gICAgICAgICAgICBldmFsdWF0ZSh7em9vbX0sIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0RnVuY3Rpb24oZXZhbHVhdGVFeHBvbmVudGlhbEZ1bmN0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcHM6IGZlYXR1cmVGdW5jdGlvblN0b3BzLFxuICAgICAgICAgICAgICAgICAgICBiYXNlOiBwYXJhbWV0ZXJzLmJhc2VcbiAgICAgICAgICAgICAgICB9LCBwcm9wZXJ0eVNwZWMsIHpvb20pLmV2YWx1YXRlKHpvb20sIHByb3BlcnRpZXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHpvb21EZXBlbmRlbnQpIHtcbiAgICAgICAgbGV0IGV2YWx1YXRlO1xuICAgICAgICBpZiAobmFtZSA9PT0gJ2hlYXRtYXAtY29sb3InKSB7XG4gICAgICAgICAgICBldmFsdWF0ZSA9ICh7aGVhdG1hcERlbnNpdHl9KSA9PiBvdXRwdXRGdW5jdGlvbihpbm5lckZ1bihwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMsIGhlYXRtYXBEZW5zaXR5LCBoYXNoZWRTdG9wcywgY2F0ZWdvcmljYWxLZXlUeXBlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBldmFsdWF0ZSA9ICh7em9vbX0pID0+IG91dHB1dEZ1bmN0aW9uKGlubmVyRnVuKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYywgem9vbSwgaGFzaGVkU3RvcHMsIGNhdGVnb3JpY2FsS2V5VHlwZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc0ZlYXR1cmVDb25zdGFudDogdHJ1ZSxcbiAgICAgICAgICAgIGlzWm9vbUNvbnN0YW50OiBmYWxzZSxcbiAgICAgICAgICAgIGludGVycG9sYXRpb246IHR5cGUgPT09ICdleHBvbmVudGlhbCcgP1xuICAgICAgICAgICAgICAgIHtuYW1lOiAnZXhwb25lbnRpYWwnLCBiYXNlOiBwYXJhbWV0ZXJzLmJhc2UgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuYmFzZSA6IDF9IDpcbiAgICAgICAgICAgICAgICB7bmFtZTogJ3N0ZXAnfSxcbiAgICAgICAgICAgIHpvb21TdG9wczogcGFyYW1ldGVycy5zdG9wcy5tYXAocyA9PiBzWzBdKSxcbiAgICAgICAgICAgIGV2YWx1YXRlXG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzRmVhdHVyZUNvbnN0YW50OiBmYWxzZSxcbiAgICAgICAgICAgIGlzWm9vbUNvbnN0YW50OiB0cnVlLFxuICAgICAgICAgICAgZXZhbHVhdGUoXywgZmVhdHVyZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZmVhdHVyZSAmJiBmZWF0dXJlLnByb3BlcnRpZXMgPyBmZWF0dXJlLnByb3BlcnRpZXNbcGFyYW1ldGVycy5wcm9wZXJ0eV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvYWxlc2NlKHBhcmFtZXRlcnMuZGVmYXVsdCwgcHJvcGVydHlTcGVjLmRlZmF1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0RnVuY3Rpb24oaW5uZXJGdW4ocGFyYW1ldGVycywgcHJvcGVydHlTcGVjLCB2YWx1ZSwgaGFzaGVkU3RvcHMsIGNhdGVnb3JpY2FsS2V5VHlwZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY29hbGVzY2UoYSwgYiwgYykge1xuICAgIGlmIChhICE9PSB1bmRlZmluZWQpIHJldHVybiBhO1xuICAgIGlmIChiICE9PSB1bmRlZmluZWQpIHJldHVybiBiO1xuICAgIGlmIChjICE9PSB1bmRlZmluZWQpIHJldHVybiBjO1xufVxuXG5mdW5jdGlvbiBldmFsdWF0ZUNhdGVnb3JpY2FsRnVuY3Rpb24ocGFyYW1ldGVycywgcHJvcGVydHlTcGVjLCBpbnB1dCwgaGFzaGVkU3RvcHMsIGtleVR5cGUpIHtcbiAgICBjb25zdCBldmFsdWF0ZWQgPSB0eXBlb2YgaW5wdXQgPT09IGtleVR5cGUgPyBoYXNoZWRTdG9wc1tpbnB1dF0gOiB1bmRlZmluZWQ7IC8vIEVuZm9yY2Ugc3RyaWN0IHR5cGluZyBvbiBpbnB1dFxuICAgIHJldHVybiBjb2FsZXNjZShldmFsdWF0ZWQsIHBhcmFtZXRlcnMuZGVmYXVsdCwgcHJvcGVydHlTcGVjLmRlZmF1bHQpO1xufVxuXG5mdW5jdGlvbiBldmFsdWF0ZUludGVydmFsRnVuY3Rpb24ocGFyYW1ldGVycywgcHJvcGVydHlTcGVjLCBpbnB1dCkge1xuICAgIC8vIEVkZ2UgY2FzZXNcbiAgICBpZiAoZ2V0VHlwZShpbnB1dCkgIT09ICdudW1iZXInKSByZXR1cm4gY29hbGVzY2UocGFyYW1ldGVycy5kZWZhdWx0LCBwcm9wZXJ0eVNwZWMuZGVmYXVsdCk7XG4gICAgY29uc3QgbiA9IHBhcmFtZXRlcnMuc3RvcHMubGVuZ3RoO1xuICAgIGlmIChuID09PSAxKSByZXR1cm4gcGFyYW1ldGVycy5zdG9wc1swXVsxXTtcbiAgICBpZiAoaW5wdXQgPD0gcGFyYW1ldGVycy5zdG9wc1swXVswXSkgcmV0dXJuIHBhcmFtZXRlcnMuc3RvcHNbMF1bMV07XG4gICAgaWYgKGlucHV0ID49IHBhcmFtZXRlcnMuc3RvcHNbbiAtIDFdWzBdKSByZXR1cm4gcGFyYW1ldGVycy5zdG9wc1tuIC0gMV1bMV07XG5cbiAgICBjb25zdCBpbmRleCA9IGZpbmRTdG9wTGVzc1RoYW5PckVxdWFsVG8ocGFyYW1ldGVycy5zdG9wcywgaW5wdXQpO1xuXG4gICAgcmV0dXJuIHBhcmFtZXRlcnMuc3RvcHNbaW5kZXhdWzFdO1xufVxuXG5mdW5jdGlvbiBldmFsdWF0ZUV4cG9uZW50aWFsRnVuY3Rpb24ocGFyYW1ldGVycywgcHJvcGVydHlTcGVjLCBpbnB1dCkge1xuICAgIGNvbnN0IGJhc2UgPSBwYXJhbWV0ZXJzLmJhc2UgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuYmFzZSA6IDE7XG5cbiAgICAvLyBFZGdlIGNhc2VzXG4gICAgaWYgKGdldFR5cGUoaW5wdXQpICE9PSAnbnVtYmVyJykgcmV0dXJuIGNvYWxlc2NlKHBhcmFtZXRlcnMuZGVmYXVsdCwgcHJvcGVydHlTcGVjLmRlZmF1bHQpO1xuICAgIGNvbnN0IG4gPSBwYXJhbWV0ZXJzLnN0b3BzLmxlbmd0aDtcbiAgICBpZiAobiA9PT0gMSkgcmV0dXJuIHBhcmFtZXRlcnMuc3RvcHNbMF1bMV07XG4gICAgaWYgKGlucHV0IDw9IHBhcmFtZXRlcnMuc3RvcHNbMF1bMF0pIHJldHVybiBwYXJhbWV0ZXJzLnN0b3BzWzBdWzFdO1xuICAgIGlmIChpbnB1dCA+PSBwYXJhbWV0ZXJzLnN0b3BzW24gLSAxXVswXSkgcmV0dXJuIHBhcmFtZXRlcnMuc3RvcHNbbiAtIDFdWzFdO1xuXG4gICAgY29uc3QgaW5kZXggPSBmaW5kU3RvcExlc3NUaGFuT3JFcXVhbFRvKHBhcmFtZXRlcnMuc3RvcHMsIGlucHV0KTtcbiAgICBjb25zdCB0ID0gaW50ZXJwb2xhdGlvbkZhY3RvcihcbiAgICAgICAgaW5wdXQsIGJhc2UsXG4gICAgICAgIHBhcmFtZXRlcnMuc3RvcHNbaW5kZXhdWzBdLFxuICAgICAgICBwYXJhbWV0ZXJzLnN0b3BzW2luZGV4ICsgMV1bMF0pO1xuXG4gICAgY29uc3Qgb3V0cHV0TG93ZXIgPSBwYXJhbWV0ZXJzLnN0b3BzW2luZGV4XVsxXTtcbiAgICBjb25zdCBvdXRwdXRVcHBlciA9IHBhcmFtZXRlcnMuc3RvcHNbaW5kZXggKyAxXVsxXTtcbiAgICBjb25zdCBpbnRlcnAgPSBpbnRlcnBvbGF0ZVtwcm9wZXJ0eVNwZWMudHlwZV0gfHwgaWRlbnRpdHlGdW5jdGlvbjtcblxuICAgIGlmICh0eXBlb2Ygb3V0cHV0TG93ZXIuZXZhbHVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGV2YWx1YXRlKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBldmFsdWF0ZWRMb3dlciA9IG91dHB1dExvd2VyLmV2YWx1YXRlLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICAgICAgY29uc3QgZXZhbHVhdGVkVXBwZXIgPSBvdXRwdXRVcHBlci5ldmFsdWF0ZS5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgZmlsbC1vdXRsaW5lLWNvbG9yLCB3aGljaCBoYXMgbm8gc3BlYyBkZWZhdWx0LlxuICAgICAgICAgICAgICAgIGlmIChldmFsdWF0ZWRMb3dlciA9PT0gdW5kZWZpbmVkIHx8IGV2YWx1YXRlZFVwcGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVycChldmFsdWF0ZWRMb3dlciwgZXZhbHVhdGVkVXBwZXIsIHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBpbnRlcnAob3V0cHV0TG93ZXIsIG91dHB1dFVwcGVyLCB0KTtcbn1cblxuZnVuY3Rpb24gZXZhbHVhdGVJZGVudGl0eUZ1bmN0aW9uKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYywgaW5wdXQpIHtcbiAgICBpZiAocHJvcGVydHlTcGVjLnR5cGUgPT09ICdjb2xvcicpIHtcbiAgICAgICAgaW5wdXQgPSBwYXJzZUNvbG9yKGlucHV0KTtcbiAgICB9IGVsc2UgaWYgKGdldFR5cGUoaW5wdXQpICE9PSBwcm9wZXJ0eVNwZWMudHlwZSAmJiAocHJvcGVydHlTcGVjLnR5cGUgIT09ICdlbnVtJyB8fCAhcHJvcGVydHlTcGVjLnZhbHVlc1tpbnB1dF0pKSB7XG4gICAgICAgIGlucHV0ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gY29hbGVzY2UoaW5wdXQsIHBhcmFtZXRlcnMuZGVmYXVsdCwgcHJvcGVydHlTcGVjLmRlZmF1bHQpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IHN0b3AgPD0gaW5wdXQsIG9yIDAgaWYgaXQgZG9lc24ndCBleGlzdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBmaW5kU3RvcExlc3NUaGFuT3JFcXVhbFRvKHN0b3BzLCBpbnB1dCkge1xuICAgIGNvbnN0IG4gPSBzdG9wcy5sZW5ndGg7XG4gICAgbGV0IGxvd2VySW5kZXggPSAwO1xuICAgIGxldCB1cHBlckluZGV4ID0gbiAtIDE7XG4gICAgbGV0IGN1cnJlbnRJbmRleCA9IDA7XG4gICAgbGV0IGN1cnJlbnRWYWx1ZSwgdXBwZXJWYWx1ZTtcblxuICAgIHdoaWxlIChsb3dlckluZGV4IDw9IHVwcGVySW5kZXgpIHtcbiAgICAgICAgY3VycmVudEluZGV4ID0gTWF0aC5mbG9vcigobG93ZXJJbmRleCArIHVwcGVySW5kZXgpIC8gMik7XG4gICAgICAgIGN1cnJlbnRWYWx1ZSA9IHN0b3BzW2N1cnJlbnRJbmRleF1bMF07XG4gICAgICAgIHVwcGVyVmFsdWUgPSBzdG9wc1tjdXJyZW50SW5kZXggKyAxXVswXTtcbiAgICAgICAgaWYgKGlucHV0ID09PSBjdXJyZW50VmFsdWUgfHwgaW5wdXQgPiBjdXJyZW50VmFsdWUgJiYgaW5wdXQgPCB1cHBlclZhbHVlKSB7IC8vIFNlYXJjaCBjb21wbGV0ZVxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRJbmRleDtcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50VmFsdWUgPCBpbnB1dCkge1xuICAgICAgICAgICAgbG93ZXJJbmRleCA9IGN1cnJlbnRJbmRleCArIDE7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFZhbHVlID4gaW5wdXQpIHtcbiAgICAgICAgICAgIHVwcGVySW5kZXggPSBjdXJyZW50SW5kZXggLSAxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGgubWF4KGN1cnJlbnRJbmRleCAtIDEsIDApO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSByYXRpbyB0aGF0IGNhbiBiZSB1c2VkIHRvIGludGVycG9sYXRlIGJldHdlZW4gZXhwb25lbnRpYWwgZnVuY3Rpb25cbiAqIHN0b3BzLlxuICpcbiAqIEhvdyBpdCB3b3JrczpcbiAqIFR3byBjb25zZWN1dGl2ZSBzdG9wIHZhbHVlcyBkZWZpbmUgYSAoc2NhbGVkIGFuZCBzaGlmdGVkKSBleHBvbmVudGlhbFxuICogZnVuY3Rpb24gYGYoeCkgPSBhICogYmFzZV54ICsgYmAsIHdoZXJlIGBiYXNlYCBpcyB0aGUgdXNlci1zcGVjaWZpZWQgYmFzZSxcbiAqIGFuZCBgYWAgYW5kIGBiYCBhcmUgY29uc3RhbnRzIGFmZm9yZGluZyBzdWZmaWNpZW50IGRlZ3JlZXMgb2YgZnJlZWRvbSB0byBmaXRcbiAqIHRoZSBmdW5jdGlvbiB0byB0aGUgZ2l2ZW4gc3RvcHMuXG4gKlxuICogSGVyZSdzIGEgYml0IG9mIGFsZ2VicmEgdGhhdCBsZXRzIHVzIGNvbXB1dGUgYGYoeClgIGRpcmVjdGx5IGZyb20gdGhlIHN0b3BcbiAqIHZhbHVlcyB3aXRob3V0IGV4cGxpY2l0bHkgc29sdmluZyBmb3IgYGFgIGFuZCBgYmA6XG4gKlxuICogRmlyc3Qgc3RvcCB2YWx1ZTogYGYoeDApID0geTAgPSBhICogYmFzZV54MCArIGJgXG4gKiBTZWNvbmQgc3RvcCB2YWx1ZTogYGYoeDEpID0geTEgPSBhICogYmFzZV54MSArIGJgXG4gKiA9PiBgeTEgLSB5MCA9IGEoYmFzZV54MSAtIGJhc2VeeDApYFxuICogPT4gYGEgPSAoeTEgLSB5MCkvKGJhc2VeeDEgLSBiYXNlXngwKWBcbiAqXG4gKiBEZXNpcmVkIHZhbHVlOiBgZih4KSA9IHkgPSBhICogYmFzZV54ICsgYmBcbiAqID0+IGBmKHgpID0geTAgKyBhICogKGJhc2VeeCAtIGJhc2VeeDApYFxuICpcbiAqIEZyb20gdGhlIGFib3ZlLCB3ZSBjYW4gcmVwbGFjZSB0aGUgYGFgIGluIGBhICogKGJhc2VeeCAtIGJhc2VeeDApYCBhbmQgZG8gYVxuICogbGl0dGxlIGFsZ2VicmE6XG4gKiBgYGBcbiAqIGEgKiAoYmFzZV54IC0gYmFzZV54MCkgPSAoeTEgLSB5MCkvKGJhc2VeeDEgLSBiYXNlXngwKSAqIChiYXNlXnggLSBiYXNlXngwKVxuICogICAgICAgICAgICAgICAgICAgICA9ICh5MSAtIHkwKSAqIChiYXNlXnggLSBiYXNlXngwKSAvIChiYXNlXngxIC0gYmFzZV54MClcbiAqIGBgYFxuICpcbiAqIElmIHdlIGxldCBgKGJhc2VeeCAtIGJhc2VeeDApIC8gKGJhc2VeeDEgYmFzZV54MClgLCB0aGVuIHdlIGhhdmVcbiAqIGBmKHgpID0geTAgKyAoeTEgLSB5MCkgKiByYXRpb2AuICBJbiBvdGhlciB3b3JkcywgYHJhdGlvYCBtYXkgYmUgdHJlYXRlZCBhc1xuICogYW4gaW50ZXJwb2xhdGlvbiBmYWN0b3IgYmV0d2VlbiB0aGUgdHdvIHN0b3BzJyBvdXRwdXQgdmFsdWVzLlxuICpcbiAqIChOb3RlOiBhIHNsaWdodGx5IGRpZmZlcmVudCBmb3JtIGZvciBgcmF0aW9gLFxuICogYChiYXNlXih4LXgwKSAtIDEpIC8gKGJhc2VeKHgxLXgwKSAtIDEpIGAsIGlzIGVxdWl2YWxlbnQsIGJ1dCByZXF1aXJlcyBmZXdlclxuICogZXhwZW5zaXZlIGBNYXRoLnBvdygpYCBvcGVyYXRpb25zLilcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpbnRlcnBvbGF0aW9uRmFjdG9yKGlucHV0LCBiYXNlLCBsb3dlclZhbHVlLCB1cHBlclZhbHVlKSB7XG4gICAgY29uc3QgZGlmZmVyZW5jZSA9IHVwcGVyVmFsdWUgLSBsb3dlclZhbHVlO1xuICAgIGNvbnN0IHByb2dyZXNzID0gaW5wdXQgLSBsb3dlclZhbHVlO1xuXG4gICAgaWYgKGRpZmZlcmVuY2UgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIGlmIChiYXNlID09PSAxKSB7XG4gICAgICAgIHJldHVybiBwcm9ncmVzcyAvIGRpZmZlcmVuY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIChNYXRoLnBvdyhiYXNlLCBwcm9ncmVzcykgLSAxKSAvIChNYXRoLnBvdyhiYXNlLCBkaWZmZXJlbmNlKSAtIDEpO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgY3JlYXRlRnVuY3Rpb24sXG4gICAgaXNGdW5jdGlvblxufTtcbiIsIlxuZXhwb3J0cy52NiA9IHJlcXVpcmUoJy4vcmVmZXJlbmNlL3Y2Lmpzb24nKTtcbmV4cG9ydHMudjcgPSByZXF1aXJlKCcuL3JlZmVyZW5jZS92Ny5qc29uJyk7XG5leHBvcnRzLnY4ID0gcmVxdWlyZSgnLi9yZWZlcmVuY2UvdjguanNvbicpO1xuZXhwb3J0cy5sYXRlc3QgPSByZXF1aXJlKCcuL3JlZmVyZW5jZS9sYXRlc3QnKTtcblxuZXhwb3J0cy5mb3JtYXQgPSByZXF1aXJlKCcuL2Zvcm1hdCcpO1xuZXhwb3J0cy5taWdyYXRlID0gcmVxdWlyZSgnLi9taWdyYXRlJyk7XG5leHBvcnRzLmNvbXBvc2l0ZSA9IHJlcXVpcmUoJy4vY29tcG9zaXRlJyk7XG5leHBvcnRzLmRpZmYgPSByZXF1aXJlKCcuL2RpZmYnKTtcbmV4cG9ydHMuVmFsaWRhdGlvbkVycm9yID0gcmVxdWlyZSgnLi9lcnJvci92YWxpZGF0aW9uX2Vycm9yJyk7XG5leHBvcnRzLlBhcnNpbmdFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3IvcGFyc2luZ19lcnJvcicpO1xuZXhwb3J0cy5leHByZXNzaW9uID0gcmVxdWlyZSgnLi9leHByZXNzaW9uJyk7XG5leHBvcnRzLmZlYXR1cmVGaWx0ZXIgPSByZXF1aXJlKCcuL2ZlYXR1cmVfZmlsdGVyJyk7XG5cbmV4cG9ydHMudmFsaWRhdGUgPSByZXF1aXJlKCcuL3ZhbGlkYXRlX3N0eWxlJyk7XG5leHBvcnRzLnZhbGlkYXRlLnBhcnNlZCA9IHJlcXVpcmUoJy4vdmFsaWRhdGVfc3R5bGUnKTtcbmV4cG9ydHMudmFsaWRhdGUubGF0ZXN0ID0gcmVxdWlyZSgnLi92YWxpZGF0ZV9zdHlsZScpO1xuIiwiXG4vKipcbiAqIE1pZ3JhdGUgYSBNYXBib3ggR0wgU3R5bGUgdG8gdGhlIGxhdGVzdCB2ZXJzaW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAYWxpYXMgbWlncmF0ZVxuICogQHBhcmFtIHtvYmplY3R9IHN0eWxlIGEgTWFwYm94IEdMIFN0eWxlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBhIG1pZ3JhdGVkIHN0eWxlXG4gKiBAZXhhbXBsZVxuICogdmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbiAqIHZhciBtaWdyYXRlID0gcmVxdWlyZSgnbWFwYm94LWdsLXN0eWxlLXNwZWMnKS5taWdyYXRlO1xuICogdmFyIHN0eWxlID0gZnMucmVhZEZpbGVTeW5jKCcuL3N0eWxlLmpzb24nLCAndXRmOCcpO1xuICogZnMud3JpdGVGaWxlU3luYygnLi9zdHlsZS5qc29uJywgSlNPTi5zdHJpbmdpZnkobWlncmF0ZShzdHlsZSkpKTtcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzdHlsZSkge1xuICAgIGxldCBtaWdyYXRlZCA9IGZhbHNlO1xuXG4gICAgaWYgKHN0eWxlLnZlcnNpb24gPT09IDYpIHtcbiAgICAgICAgc3R5bGUgPSByZXF1aXJlKCcuL21pZ3JhdGUvdjcnKShzdHlsZSk7XG4gICAgICAgIG1pZ3JhdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoc3R5bGUudmVyc2lvbiA9PT0gNyB8fCBzdHlsZS52ZXJzaW9uID09PSA4KSB7XG4gICAgICAgIHN0eWxlID0gcmVxdWlyZSgnLi9taWdyYXRlL3Y4Jykoc3R5bGUpO1xuICAgICAgICBtaWdyYXRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCFtaWdyYXRlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBtaWdyYXRlIGZyb20nLCBzdHlsZS52ZXJzaW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3R5bGU7XG59O1xuIiwiXG5jb25zdCByZWYgPSByZXF1aXJlKCcuLi9yZWZlcmVuY2UvdjcuanNvbicpO1xuXG5mdW5jdGlvbiBlYWNoTGF5ZXIobGF5ZXIsIGNhbGxiYWNrKSB7XG4gICAgZm9yIChjb25zdCBrIGluIGxheWVyLmxheWVycykge1xuICAgICAgICBjYWxsYmFjayhsYXllci5sYXllcnNba10pO1xuICAgICAgICBlYWNoTGF5ZXIobGF5ZXIubGF5ZXJzW2tdLCBjYWxsYmFjayk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBlYWNoUGFpbnQobGF5ZXIsIGNhbGxiYWNrKSB7XG4gICAgZm9yIChjb25zdCBrIGluIGxheWVyKSB7XG4gICAgICAgIGlmIChrLmluZGV4T2YoJ3BhaW50JykgPT09IDApIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGxheWVyW2tdLCBrKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG4vLyBkYXNoIG1pZ3JhdGlvbnMgYXJlIG9ubHkgc2FmZSB0byBydW4gb25jZSBwZXIgc3R5bGVcbmNvbnN0IE1JR1JBVEVfREFTSEVTID0gZmFsc2U7XG5cbmNvbnN0IHZlYzJwcm9wcyA9IHtcbiAgICBcImZpbGwtdHJhbnNsYXRlXCI6IHRydWUsXG4gICAgXCJsaW5lLXRyYW5zbGF0ZVwiOiB0cnVlLFxuICAgIFwiaWNvbi1vZmZzZXRcIjogdHJ1ZSxcbiAgICBcInRleHQtb2Zmc2V0XCI6IHRydWUsXG4gICAgXCJpY29uLXRyYW5zbGF0ZVwiOiB0cnVlLFxuICAgIFwidGV4dC10cmFuc2xhdGVcIjogdHJ1ZVxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgc3R5bGUudmVyc2lvbiA9IDc7XG5cbiAgICBjb25zdCBwcm9jZXNzZWRDb25zdGFudHMgPSB7fTtcblxuICAgIGVhY2hMYXllcihzdHlsZSwgKGxheWVyKSA9PiB7XG5cbiAgICAgICAgY29uc3Qgcm91bmQgPSBsYXllci5sYXlvdXQgJiYgbGF5ZXIubGF5b3V0WydsaW5lLWNhcCddID09PSAncm91bmQnO1xuXG4gICAgICAgIGVhY2hQYWludChsYXllciwgKHBhaW50KSA9PiB7XG5cblxuICAgICAgICAgICAgLy8gc3BsaXQgcmFzdGVyIGJyaWdodG5lc3NcbiAgICAgICAgICAgIGlmIChwYWludFsncmFzdGVyLWJyaWdodG5lc3MnXSkge1xuICAgICAgICAgICAgICAgIGxldCBidmFsID0gcGFpbnRbJ3Jhc3Rlci1icmlnaHRuZXNzJ107XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBidmFsID09PSAnc3RyaW5nJykgYnZhbCA9IHN0eWxlLmNvbnN0YW50c1tidmFsXTtcbiAgICAgICAgICAgICAgICBwYWludFsncmFzdGVyLWJyaWdodG5lc3MtbWluJ10gPSB0eXBlb2YgYnZhbFswXSA9PT0gJ3N0cmluZycgPyBzdHlsZS5jb25zdGFudHNbYnZhbFswXV0gOiBidmFsWzBdO1xuICAgICAgICAgICAgICAgIHBhaW50WydyYXN0ZXItYnJpZ2h0bmVzcy1tYXgnXSA9IHR5cGVvZiBidmFsWzFdID09PSAnc3RyaW5nJyA/IHN0eWxlLmNvbnN0YW50c1tidmFsWzFdXSA6IGJ2YWxbMV07XG4gICAgICAgICAgICAgICAgZGVsZXRlIHBhaW50WydyYXN0ZXItYnJpZ2h0bmVzcyddO1xuICAgICAgICAgICAgfVxuXG5cblxuICAgICAgICAgICAgLy8gTWlncmF0ZSB2ZWMyIHByb3AgZnVuY3Rpb25zXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHZlYzJwcm9wIGluIHZlYzJwcm9wcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IHBhaW50W3ZlYzJwcm9wXTtcbiAgICAgICAgICAgICAgICBpZiAodmFsICYmIEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcyA9IHZhbFswXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHQgPSB2YWxbMV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcyA9IHN0eWxlLmNvbnN0YW50c1tzXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gc3R5bGUuY29uc3RhbnRzW3RdO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gbm90IGZ1bmN0aW9ucywgbm90aGluZyB0byBtaWdyYXRlXG4gICAgICAgICAgICAgICAgICAgIGlmIChzID09PSB1bmRlZmluZWQgfHwgdCA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzLnN0b3BzICYmICF0LnN0b3BzKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdG9wWm9vbXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJhc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzLnN0b3BzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHMuc3RvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9wWm9vbXMucHVzaChzLnN0b3BzW2ldWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2UgPSBzLmJhc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQuc3RvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgdC5zdG9wcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3Bab29tcy5wdXNoKHQuc3RvcHNba11bMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZSA9IGJhc2UgfHwgdC5iYXNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0b3Bab29tcy5zb3J0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZm4gPSBwYXJzZU51bWJlckFycmF5KFtzLCB0XSk7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3U3RvcHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaCA9IDA7IGggPCBzdG9wWm9vbXMubGVuZ3RoOyBoKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHogPSBzdG9wWm9vbXNbaF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeiA9PT0gc3RvcFpvb21zW2ggLSAxXSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTdG9wcy5wdXNoKFt6LCBmbih6KV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcGFpbnRbdmVjMnByb3BdID0geyBzdG9wczogbmV3U3RvcHMgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJhc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhaW50W3ZlYzJwcm9wXS5iYXNlID0gYmFzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuXG5cbiAgICAgICAgICAgIGlmIChwYWludFsnbGluZS1kYXNoYXJyYXknXSAmJiBNSUdSQVRFX0RBU0hFUykge1xuICAgICAgICAgICAgICAgIGxldCB3ID0gcGFpbnRbJ2xpbmUtd2lkdGgnXSA/IHBhaW50WydsaW5lLXdpZHRoJ10gOiByZWYuY2xhc3NfbGluZVsnbGluZS13aWR0aCddLmRlZmF1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3ID09PSAnc3RyaW5nJykgdyA9IHN0eWxlLmNvbnN0YW50c1t3XTtcblxuICAgICAgICAgICAgICAgIGxldCBkYXNoYXJyYXkgPSBwYWludFsnbGluZS1kYXNoYXJyYXknXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRhc2hhcnJheSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3QgcHJvY2VzcyBhIGNvbnN0YW50IG1vcmUgdGhhbiBvbmNlXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzZWRDb25zdGFudHNbZGFzaGFycmF5XSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWRDb25zdGFudHNbZGFzaGFycmF5XSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgZGFzaGFycmF5ID0gc3R5bGUuY29uc3RhbnRzW2Rhc2hhcnJheV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXNoYXJyYXlbMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhc2hhcnJheVswXSA9IHN0eWxlLmNvbnN0YW50c1tkYXNoYXJyYXlbMF1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRhc2hhcnJheVsxXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgZGFzaGFycmF5WzFdID0gc3R5bGUuY29uc3RhbnRzW2Rhc2hhcnJheVsxXV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3Qgd2lkdGhGbiA9IHBhcnNlTnVtYmVyKHcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhc2hGbiA9IHBhcnNlTnVtYmVyQXJyYXkoZGFzaGFycmF5KTtcblxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoZXJlIGlzIG5vIHBlcmZlY3Qgd2F5IHRvIGNvbnZlcnQgb2xkIGZ1bmN0aW9ucyxcbiAgICAgICAgICAgICAgICAvLyBqdXN0IHVzZSB0aGUgdmFsdWVzIGF0IHoxNyB0byBtYWtlIHRoZSBuZXcgdmFsdWUuXG4gICAgICAgICAgICAgICAgY29uc3Qgem9vbSA9IDE3O1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgd2lkdGggPSB0eXBlb2Ygd2lkdGhGbiA9PT0gJ2Z1bmN0aW9uJyA/IHdpZHRoRm4oem9vbSkgOiB3aWR0aEZuO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhc2ggPSBkYXNoRm4oem9vbSk7XG5cbiAgICAgICAgICAgICAgICBkYXNoWzBdIC89IHdpZHRoO1xuICAgICAgICAgICAgICAgIGRhc2hbMV0gLz0gd2lkdGg7XG5cbiAgICAgICAgICAgICAgICBpZiAocm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGFzaFswXSAtPSAxO1xuICAgICAgICAgICAgICAgICAgICBkYXNoWzFdICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYWludFsnbGluZS1kYXNoYXJyYXknXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUuY29uc3RhbnRzW3BhaW50WydsaW5lLWRhc2hhcnJheSddXSA9IGRhc2g7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFpbnRbJ2xpbmUtZGFzaGFycmF5J10gPSBkYXNoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBzdHlsZS5sYXllcnMgPSBzdHlsZS5sYXllcnMuZmlsdGVyKChsYXllcikgPT4ge1xuICAgICAgICByZXR1cm4gIWxheWVyLmxheWVycztcbiAgICB9KTtcblxuICAgIHJldHVybiBzdHlsZTtcbn07XG5cbi8vIGZyb20gbWFwYm94LWdsLWpzL3NyYy9zdHlsZS9zdHlsZV9kZWNsYXJhdGlvbi5qc1xuXG5mdW5jdGlvbiBwYXJzZU51bWJlckFycmF5KGFycmF5KSB7XG4gICAgY29uc3Qgd2lkdGhzID0gYXJyYXkubWFwKHBhcnNlTnVtYmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbih6KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdpZHRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godHlwZW9mIHdpZHRoc1tpXSA9PT0gJ2Z1bmN0aW9uJyA/IHdpZHRoc1tpXSh6KSA6IHdpZHRoc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufVxuXG5cbmZ1bmN0aW9uIHBhcnNlTnVtYmVyKG51bSkge1xuICAgIGlmIChudW0uc3RvcHMpIG51bSA9IHN0b3BzRm4obnVtKTtcbiAgICBjb25zdCB2YWx1ZSA9ICtudW07XG4gICAgcmV0dXJuICFpc05hTih2YWx1ZSkgPyB2YWx1ZSA6IG51bTtcbn1cblxuXG5mdW5jdGlvbiBzdG9wc0ZuKHBhcmFtcykge1xuICAgIGNvbnN0IHN0b3BzID0gcGFyYW1zLnN0b3BzO1xuICAgIGNvbnN0IGJhc2UgPSBwYXJhbXMuYmFzZSB8fCByZWYuZnVuY3Rpb24uYmFzZS5kZWZhdWx0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHopIHtcblxuICAgICAgICAvLyBmaW5kIHRoZSB0d28gc3RvcHMgd2hpY2ggdGhlIGN1cnJlbnQgeiBpcyBiZXR3ZWVuXG4gICAgICAgIGxldCBsb3csIGhpZ2g7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdG9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc3RvcCA9IHN0b3BzW2ldO1xuICAgICAgICAgICAgaWYgKHN0b3BbMF0gPD0geikgbG93ID0gc3RvcDtcbiAgICAgICAgICAgIGlmIChzdG9wWzBdID4geikge1xuICAgICAgICAgICAgICAgIGhpZ2ggPSBzdG9wO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvdyAmJiBoaWdoKSB7XG4gICAgICAgICAgICBjb25zdCB6b29tRGlmZiA9IGhpZ2hbMF0gLSBsb3dbMF07XG4gICAgICAgICAgICBjb25zdCB6b29tUHJvZ3Jlc3MgPSB6IC0gbG93WzBdO1xuICAgICAgICAgICAgY29uc3QgdCA9IGJhc2UgPT09IDEgP1xuICAgICAgICAgICAgICAgIHpvb21Qcm9ncmVzcyAvIHpvb21EaWZmIDpcbiAgICAgICAgICAgICAgICAoTWF0aC5wb3coYmFzZSwgem9vbVByb2dyZXNzKSAtIDEpIC8gKE1hdGgucG93KGJhc2UsIHpvb21EaWZmKSAtIDEpO1xuXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJwKGxvd1sxXSwgaGlnaFsxXSwgdCk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChsb3cpIHtcbiAgICAgICAgICAgIHJldHVybiBsb3dbMV07XG5cbiAgICAgICAgfSBlbHNlIGlmIChoaWdoKSB7XG4gICAgICAgICAgICByZXR1cm4gaGlnaFsxXTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBpbnRlcnAoYSwgYiwgdCkge1xuICAgIHJldHVybiAoYSAqICgxIC0gdCkpICsgKGIgKiB0KTtcbn1cbiIsIlxuY29uc3QgUmVmZXJlbmNlID0gcmVxdWlyZSgnLi4vcmVmZXJlbmNlL3Y4Lmpzb24nKTtcbmNvbnN0IFVSTCA9IHJlcXVpcmUoJ3VybCcpO1xuXG5mdW5jdGlvbiBnZXRQcm9wZXJ0eVJlZmVyZW5jZShwcm9wZXJ0eU5hbWUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IFJlZmVyZW5jZS5sYXlvdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gUmVmZXJlbmNlW1JlZmVyZW5jZS5sYXlvdXRbaV1dKSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBwcm9wZXJ0eU5hbWUpIHJldHVybiBSZWZlcmVuY2VbUmVmZXJlbmNlLmxheW91dFtpXV1ba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IFJlZmVyZW5jZS5wYWludC5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBSZWZlcmVuY2VbUmVmZXJlbmNlLnBhaW50W2ldXSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gcHJvcGVydHlOYW1lKSByZXR1cm4gUmVmZXJlbmNlW1JlZmVyZW5jZS5wYWludFtpXV1ba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZWFjaFNvdXJjZShzdHlsZSwgY2FsbGJhY2spIHtcbiAgICBmb3IgKGNvbnN0IGsgaW4gc3R5bGUuc291cmNlcykge1xuICAgICAgICBjYWxsYmFjayhzdHlsZS5zb3VyY2VzW2tdKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGVhY2hMYXllcihzdHlsZSwgY2FsbGJhY2spIHtcbiAgICBmb3IgKGNvbnN0IGsgaW4gc3R5bGUubGF5ZXJzKSB7XG4gICAgICAgIGNhbGxiYWNrKHN0eWxlLmxheWVyc1trXSk7XG4gICAgICAgIGVhY2hMYXllcihzdHlsZS5sYXllcnNba10sIGNhbGxiYWNrKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGVhY2hMYXlvdXQobGF5ZXIsIGNhbGxiYWNrKSB7XG4gICAgZm9yIChjb25zdCBrIGluIGxheWVyKSB7XG4gICAgICAgIGlmIChrLmluZGV4T2YoJ2xheW91dCcpID09PSAwKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhsYXllcltrXSwgayk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGVhY2hQYWludChsYXllciwgY2FsbGJhY2spIHtcbiAgICBmb3IgKGNvbnN0IGsgaW4gbGF5ZXIpIHtcbiAgICAgICAgaWYgKGsuaW5kZXhPZigncGFpbnQnKSA9PT0gMCkge1xuICAgICAgICAgICAgY2FsbGJhY2sobGF5ZXJba10sIGspO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQ29uc3RhbnQoc3R5bGUsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWVbMF0gPT09ICdAJykge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZUNvbnN0YW50KHN0eWxlLCBzdHlsZS5jb25zdGFudHNbdmFsdWVdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBlYWNoUHJvcGVydHkoc3R5bGUsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgb3B0aW9ucy5sYXlvdXQgPSBvcHRpb25zLmxheW91dCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdGlvbnMubGF5b3V0O1xuICAgIG9wdGlvbnMucGFpbnQgPSBvcHRpb25zLnBhaW50ID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0aW9ucy5wYWludDtcblxuICAgIGZ1bmN0aW9uIGlubmVyKGxheWVyLCBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBwcm9wZXJ0aWVzW2tleV0sXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlOiBnZXRQcm9wZXJ0eVJlZmVyZW5jZShrZXkpLFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24oeCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzW2tleV0gPSB4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBlYWNoTGF5ZXIoc3R5bGUsIChsYXllcikgPT4ge1xuICAgICAgICBpZiAob3B0aW9ucy5wYWludCkge1xuICAgICAgICAgICAgZWFjaFBhaW50KGxheWVyLCAocGFpbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpbm5lcihsYXllciwgcGFpbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMubGF5b3V0KSB7XG4gICAgICAgICAgICBlYWNoTGF5b3V0KGxheWVyLCAobGF5b3V0KSA9PiB7XG4gICAgICAgICAgICAgICAgaW5uZXIobGF5ZXIsIGxheW91dCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUuc3RvcHMpO1xufVxuXG5mdW5jdGlvbiByZW5hbWVQcm9wZXJ0eShvYmosIGZyb20sIHRvKSB7XG4gICAgb2JqW3RvXSA9IG9ialtmcm9tXTsgZGVsZXRlIG9ialtmcm9tXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzdHlsZSkge1xuICAgIHN0eWxlLnZlcnNpb24gPSA4O1xuXG4gICAgLy8gUmVuYW1lIHByb3BlcnRpZXMsIHJldmVyc2UgY29vcmRpbmF0ZXMgaW4gc291cmNlIGFuZCBsYXllcnNcbiAgICBlYWNoU291cmNlKHN0eWxlLCAoc291cmNlKSA9PiB7XG4gICAgICAgIGlmIChzb3VyY2UudHlwZSA9PT0gJ3ZpZGVvJyAmJiBzb3VyY2UudXJsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlbmFtZVByb3BlcnR5KHNvdXJjZSwgJ3VybCcsICd1cmxzJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvdXJjZS50eXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgICBzb3VyY2UuY29vcmRpbmF0ZXMuZm9yRWFjaCgoY29vcmQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29vcmQucmV2ZXJzZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGVhY2hMYXllcihzdHlsZSwgKGxheWVyKSA9PiB7XG4gICAgICAgIGVhY2hMYXlvdXQobGF5ZXIsIChsYXlvdXQpID0+IHtcbiAgICAgICAgICAgIGlmIChsYXlvdXRbJ3N5bWJvbC1taW4tZGlzdGFuY2UnXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVuYW1lUHJvcGVydHkobGF5b3V0LCAnc3ltYm9sLW1pbi1kaXN0YW5jZScsICdzeW1ib2wtc3BhY2luZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBlYWNoUGFpbnQobGF5ZXIsIChwYWludCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBhaW50WydiYWNrZ3JvdW5kLWltYWdlJ10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlbmFtZVByb3BlcnR5KHBhaW50LCAnYmFja2dyb3VuZC1pbWFnZScsICdiYWNrZ3JvdW5kLXBhdHRlcm4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYWludFsnbGluZS1pbWFnZSddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZW5hbWVQcm9wZXJ0eShwYWludCwgJ2xpbmUtaW1hZ2UnLCAnbGluZS1wYXR0ZXJuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFpbnRbJ2ZpbGwtaW1hZ2UnXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVuYW1lUHJvcGVydHkocGFpbnQsICdmaWxsLWltYWdlJywgJ2ZpbGwtcGF0dGVybicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIElubGluZSBDb25zdGFudHNcbiAgICBlYWNoUHJvcGVydHkoc3R5bGUsIChwcm9wZXJ0eSkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHJlc29sdmVDb25zdGFudChzdHlsZSwgcHJvcGVydHkudmFsdWUpO1xuXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUuc3RvcHMuZm9yRWFjaCgoc3RvcCkgPT4ge1xuICAgICAgICAgICAgICAgIHN0b3BbMV0gPSByZXNvbHZlQ29uc3RhbnQoc3R5bGUsIHN0b3BbMV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9wZXJ0eS5zZXQodmFsdWUpO1xuICAgIH0pO1xuICAgIGRlbGV0ZSBzdHlsZS5jb25zdGFudHM7XG5cbiAgICBlYWNoTGF5ZXIoc3R5bGUsIChsYXllcikgPT4ge1xuICAgICAgICAvLyBnZXQgcmlkIG9mIHRleHQtbWF4LXNpemUsIGljb24tbWF4LXNpemVcbiAgICAgICAgLy8gdHVybiB0ZXh0LXNpemUsIGljb24tc2l6ZSBpbnRvIGxheW91dCBwcm9wZXJ0aWVzXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvbWFwYm94LWdsLXN0eWxlLXNwZWMvaXNzdWVzLzI1NVxuXG4gICAgICAgIGVhY2hMYXlvdXQobGF5ZXIsIChsYXlvdXQpID0+IHtcbiAgICAgICAgICAgIGRlbGV0ZSBsYXlvdXRbJ3RleHQtbWF4LXNpemUnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBsYXlvdXRbJ2ljb24tbWF4LXNpemUnXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZWFjaFBhaW50KGxheWVyLCAocGFpbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChwYWludFsndGV4dC1zaXplJ10pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWxheWVyLmxheW91dCkgbGF5ZXIubGF5b3V0ID0ge307XG4gICAgICAgICAgICAgICAgbGF5ZXIubGF5b3V0Wyd0ZXh0LXNpemUnXSA9IHBhaW50Wyd0ZXh0LXNpemUnXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgcGFpbnRbJ3RleHQtc2l6ZSddO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGFpbnRbJ2ljb24tc2l6ZSddKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFsYXllci5sYXlvdXQpIGxheWVyLmxheW91dCA9IHt9O1xuICAgICAgICAgICAgICAgIGxheWVyLmxheW91dFsnaWNvbi1zaXplJ10gPSBwYWludFsnaWNvbi1zaXplJ107XG4gICAgICAgICAgICAgICAgZGVsZXRlIHBhaW50WydpY29uLXNpemUnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBtaWdyYXRlRm9udHN0YWNrVVJMKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IGlucHV0UGFyc2VkID0gVVJMLnBhcnNlKGlucHV0KTtcbiAgICAgICAgY29uc3QgaW5wdXRQYXRobmFtZVBhcnRzID0gaW5wdXRQYXJzZWQucGF0aG5hbWUuc3BsaXQoJy8nKTtcblxuICAgICAgICBpZiAoaW5wdXRQYXJzZWQucHJvdG9jb2wgIT09ICdtYXBib3g6Jykge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuXG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXRQYXJzZWQuaG9zdG5hbWUgPT09ICdmb250c3RhY2snKSB7XG4gICAgICAgICAgICBhc3NlcnQoZGVjb2RlVVJJKGlucHV0UGFyc2VkLnBhdGhuYW1lKSA9PT0gJy97Zm9udHN0YWNrfS97cmFuZ2V9LnBiZicpO1xuICAgICAgICAgICAgcmV0dXJuICdtYXBib3g6Ly9mb250cy9tYXBib3gve2ZvbnRzdGFja30ve3JhbmdlfS5wYmYnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXRQYXJzZWQuaG9zdG5hbWUgPT09ICdmb250cycpIHtcbiAgICAgICAgICAgIGFzc2VydChpbnB1dFBhdGhuYW1lUGFydHNbMV0gPT09ICd2MScpO1xuICAgICAgICAgICAgYXNzZXJ0KGRlY29kZVVSSShpbnB1dFBhdGhuYW1lUGFydHNbM10pID09PSAne2ZvbnRzdGFja30nKTtcbiAgICAgICAgICAgIGFzc2VydChkZWNvZGVVUkkoaW5wdXRQYXRobmFtZVBhcnRzWzRdKSA9PT0gJ3tyYW5nZX0ucGJmJyk7XG4gICAgICAgICAgICByZXR1cm4gYG1hcGJveDovL2ZvbnRzLyR7aW5wdXRQYXRobmFtZVBhcnRzWzJdfS97Zm9udHN0YWNrfS97cmFuZ2V9LnBiZmA7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFzc2VydChmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhc3NlcnQocHJlZGljYXRlKSB7XG4gICAgICAgICAgICBpZiAoIXByZWRpY2F0ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBmb250IHVybDogXCIke2lucHV0fVwiYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3R5bGUuZ2x5cGhzKSB7XG4gICAgICAgIHN0eWxlLmdseXBocyA9IG1pZ3JhdGVGb250c3RhY2tVUkwoc3R5bGUuZ2x5cGhzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtaWdyYXRlRm9udFN0YWNrKGZvbnQpIHtcbiAgICAgICAgZnVuY3Rpb24gc3BsaXRBbmRUcmltKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5zcGxpdCgnLCcpLm1hcCgocykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBzLnRyaW0oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZm9udCkpIHtcbiAgICAgICAgICAgIC8vIEFzc3VtZSBpdCdzIGEgcHJldmlvdXNseSBtaWdyYXRlZCBmb250LWFycmF5LlxuICAgICAgICAgICAgcmV0dXJuIGZvbnQ7XG5cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZm9udCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBzcGxpdEFuZFRyaW0oZm9udCk7XG5cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZm9udCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGZvbnQuc3RvcHMuZm9yRWFjaCgoc3RvcCkgPT4ge1xuICAgICAgICAgICAgICAgIHN0b3BbMV0gPSBzcGxpdEFuZFRyaW0oc3RvcFsxXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmb250O1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmV4cGVjdGVkIGZvbnQgdmFsdWVcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBlYWNoTGF5ZXIoc3R5bGUsIChsYXllcikgPT4ge1xuICAgICAgICBlYWNoTGF5b3V0KGxheWVyLCAobGF5b3V0KSA9PiB7XG4gICAgICAgICAgICBpZiAobGF5b3V0Wyd0ZXh0LWZvbnQnXSkge1xuICAgICAgICAgICAgICAgIGxheW91dFsndGV4dC1mb250J10gPSBtaWdyYXRlRm9udFN0YWNrKGxheW91dFsndGV4dC1mb250J10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIFJldmVyc2Ugb3JkZXIgb2Ygc3ltYm9sIGxheWVycy4gVGhpcyBpcyBhbiBpbXBlcmZlY3QgbWlncmF0aW9uLlxuICAgIC8vXG4gICAgLy8gVGhlIG9yZGVyIG9mIGEgc3ltYm9sIGxheWVyIGluIHRoZSBsYXllcnMgbGlzdCBhZmZlY3RzIHR3byB0aGluZ3M6XG4gICAgLy8gLSBob3cgaXQgaXMgZHJhd24gcmVsYXRpdmUgdG8gb3RoZXIgbGF5ZXJzIChsaWtlIG9uZXdheSBhcnJvd3MgYmVsb3cgYnJpZGdlcylcbiAgICAvLyAtIHRoZSBwbGFjZW1lbnQgcHJpb3JpdHkgY29tcGFyZWQgdG8gb3RoZXIgbGF5ZXJzXG4gICAgLy9cbiAgICAvLyBJdCdzIGltcG9zc2libGUgdG8gcmV2ZXJzZSB0aGUgcGxhY2VtZW50IHByaW9yaXR5IHdpdGhvdXQgYnJlYWtpbmcgdGhlIGRyYXcgb3JkZXJcbiAgICAvLyBpbiBzb21lIGNhc2VzLiBUaGlzIG1pZ3JhdGlvbiBvbmx5IHJldmVyc2VzIHRoZSBvcmRlciBvZiBzeW1ib2wgbGF5ZXJzIHRoYXRcbiAgICAvLyBhcmUgYWJvdmUgYWxsIG90aGVyIHR5cGVzIG9mIGxheWVycy5cbiAgICAvL1xuICAgIC8vIFN5bWJvbCBsYXllcnMgdGhhdCBhcmUgYXQgdGhlIHRvcCBvZiB0aGUgbWFwIHByZXNlcnZlIHRoZWlyIHByaW9yaXR5LlxuICAgIC8vIFN5bWJvbCBsYXllcnMgdGhhdCBhcmUgYmVsb3cgYW5vdGhlciB0eXBlIChsaW5lLCBmaWxsKSBvZiBsYXllciBwcmVzZXJ2ZSB0aGVpciBkcmF3IG9yZGVyLlxuXG4gICAgbGV0IGZpcnN0U3ltYm9sTGF5ZXIgPSAwO1xuICAgIGZvciAobGV0IGkgPSBzdHlsZS5sYXllcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgbGF5ZXIgPSBzdHlsZS5sYXllcnNbaV07XG4gICAgICAgIGlmIChsYXllci50eXBlICE9PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgZmlyc3RTeW1ib2xMYXllciA9IGkgKyAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzeW1ib2xMYXllcnMgPSBzdHlsZS5sYXllcnMuc3BsaWNlKGZpcnN0U3ltYm9sTGF5ZXIpO1xuICAgIHN5bWJvbExheWVycy5yZXZlcnNlKCk7XG4gICAgc3R5bGUubGF5ZXJzID0gc3R5bGUubGF5ZXJzLmNvbmNhdChzeW1ib2xMYXllcnMpO1xuXG4gICAgcmV0dXJuIHN0eWxlO1xufTtcbiIsIlxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3Y4Lmpzb24nKTtcbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkdmVyc2lvblwiOiA2LFxuICBcIiRyb290XCI6IHtcbiAgICBcInZlcnNpb25cIjoge1xuICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICA2XG4gICAgICBdLFxuICAgICAgXCJkb2NcIjogXCJTdHlsZXNoZWV0IHZlcnNpb24gbnVtYmVyLiBNdXN0IGJlIDYuXCJcbiAgICB9LFxuICAgIFwiY29uc3RhbnRzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImNvbnN0YW50c1wiLFxuICAgICAgXCJkb2NcIjogXCJBbiBvYmplY3Qgb2YgY29uc3RhbnRzIHRvIGJlIHJlZmVyZW5jZWQgaW4gbGF5ZXJzLlwiXG4gICAgfSxcbiAgICBcInNvdXJjZXNcIjoge1xuICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgXCJ0eXBlXCI6IFwic291cmNlc1wiLFxuICAgICAgXCJkb2NcIjogXCJEYXRhIHNvdXJjZSBzcGVjaWZpY2F0aW9ucy5cIlxuICAgIH0sXG4gICAgXCJzcHJpdGVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImRvY1wiOiBcIkEgYmFzZSBVUkwgZm9yIHJldHJpZXZpbmcgdGhlIHNwcml0ZSBpbWFnZSBhbmQgbWV0YWRhdGEuIFRoZSBleHRlbnNpb25zIGAucG5nYCwgYC5qc29uYCBhbmQgc2NhbGUgZmFjdG9yIGBAMngucG5nYCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgYXBwZW5kZWQuXCJcbiAgICB9LFxuICAgIFwiZ2x5cGhzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkb2NcIjogXCJBIFVSTCB0ZW1wbGF0ZSBmb3IgbG9hZGluZyBzaWduZWQtZGlzdGFuY2UtZmllbGQgZ2x5cGggc2V0cyBpbiBQQkYgZm9ybWF0LiBWYWxpZCB0b2tlbnMgYXJlIHtmb250c3RhY2t9IGFuZCB7cmFuZ2V9LlwiXG4gICAgfSxcbiAgICBcInRyYW5zaXRpb25cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwidHJhbnNpdGlvblwiLFxuICAgICAgXCJkb2NcIjogXCJBIGdsb2JhbCB0cmFuc2l0aW9uIGRlZmluaXRpb24gdG8gdXNlIGFzIGEgZGVmYXVsdCBhY3Jvc3MgcHJvcGVydGllcy5cIlxuICAgIH0sXG4gICAgXCJsYXllcnNcIjoge1xuICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwidmFsdWVcIjogXCJsYXllclwiLFxuICAgICAgXCJkb2NcIjogXCJMYXllcnMgd2lsbCBiZSBkcmF3biBpbiB0aGUgb3JkZXIgb2YgdGhpcyBhcnJheS5cIlxuICAgIH1cbiAgfSxcbiAgXCJjb25zdGFudHNcIjoge1xuICAgIFwiKlwiOiB7XG4gICAgICBcInR5cGVcIjogXCIqXCIsXG4gICAgICBcImRvY1wiOiBcIkEgY29uc3RhbnQgdGhhdCB3aWxsIGJlIHJlcGxhY2VkIHZlcmJhdGltIGluIHRoZSByZWZlcmVuY2luZyBwbGFjZS4gVGhpcyBjYW4gYmUgYW55dGhpbmcsIGluY2x1ZGluZyBvYmplY3RzIGFuZCBhcnJheXMuIEFsbCB2YXJpYWJsZSBuYW1lcyBtdXN0IGJlIHByZWZpeGVkIHdpdGggYW4gYEBgIHN5bWJvbC5cIlxuICAgIH1cbiAgfSxcbiAgXCJzb3VyY2VzXCI6IHtcbiAgICBcIipcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic291cmNlXCIsXG4gICAgICBcImRvY1wiOiBcIlNwZWNpZmljYXRpb24gb2YgYSBkYXRhIHNvdXJjZS4gRm9yIHZlY3RvciBhbmQgcmFzdGVyIHNvdXJjZXMsIGVpdGhlciBUaWxlSlNPTiBvciBhIFVSTCB0byBhIFRpbGVKU09OIG11c3QgYmUgcHJvdmlkZWQuIEZvciBHZW9KU09OIGFuZCB2aWRlbyBzb3VyY2VzLCBhIFVSTCBtdXN0IGJlIHByb3ZpZGVkLlwiXG4gICAgfVxuICB9LFxuICBcInNvdXJjZVwiOiBbXG4gICAgXCJzb3VyY2VfdGlsZVwiLFxuICAgIFwic291cmNlX2dlb2pzb25cIixcbiAgICBcInNvdXJjZV92aWRlb1wiXG4gIF0sXG4gIFwic291cmNlX3RpbGVcIjoge1xuICAgIFwidHlwZVwiOiB7XG4gICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwidmVjdG9yXCIsXG4gICAgICAgIFwicmFzdGVyXCJcbiAgICAgIF0sXG4gICAgICBcImRvY1wiOiBcIlRoZSBkYXRhIHR5cGUgb2YgdGhlIHNvdXJjZS5cIlxuICAgIH0sXG4gICAgXCJ1cmxcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImRvY1wiOiBcIkEgVVJMIHRvIGEgVGlsZUpTT04gcmVzb3VyY2UuIFN1cHBvcnRlZCBwcm90b2NvbHMgYXJlIGBodHRwOmAsIGBodHRwczpgLCBhbmQgYG1hcGJveDovLzxtYXBpZD5gLlwiXG4gICAgfSxcbiAgICBcInRpbGVzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcInZhbHVlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImRvY1wiOiBcIkFuIGFycmF5IG9mIG9uZSBvciBtb3JlIHRpbGUgc291cmNlIFVSTHMsIGFzIGluIHRoZSBUaWxlSlNPTiBzcGVjLlwiXG4gICAgfSxcbiAgICBcIm1pbnpvb21cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwiZG9jXCI6IFwiTWluaW11bSB6b29tIGxldmVsIGZvciB3aGljaCB0aWxlcyBhcmUgYXZhaWxhYmxlLCBhcyBpbiB0aGUgVGlsZUpTT04gc3BlYy5cIlxuICAgIH0sXG4gICAgXCJtYXh6b29tXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDIyLFxuICAgICAgXCJkb2NcIjogXCJNYXhpbXVtIHpvb20gbGV2ZWwgZm9yIHdoaWNoIHRpbGVzIGFyZSBhdmFpbGFibGUsIGFzIGluIHRoZSBUaWxlSlNPTiBzcGVjLiBEYXRhIGZyb20gdGlsZXMgYXQgdGhlIG1heHpvb20gYXJlIHVzZWQgd2hlbiBkaXNwbGF5aW5nIHRoZSBtYXAgYXQgaGlnaGVyIHpvb20gbGV2ZWxzLlwiXG4gICAgfSxcbiAgICBcInRpbGVTaXplXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDUxMixcbiAgICAgIFwidW5pdHNcIjogXCJwaXhlbHNcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIG1pbmltdW0gdmlzdWFsIHNpemUgdG8gZGlzcGxheSB0aWxlcyBmb3IgdGhpcyBsYXllci4gT25seSBjb25maWd1cmFibGUgZm9yIHJhc3RlciBsYXllcnMuXCJcbiAgICB9LFxuICAgIFwiKlwiOiB7XG4gICAgICBcInR5cGVcIjogXCIqXCIsXG4gICAgICBcImRvY1wiOiBcIk90aGVyIGtleXMgdG8gY29uZmlndXJlIHRoZSBkYXRhIHNvdXJjZS5cIlxuICAgIH1cbiAgfSxcbiAgXCJzb3VyY2VfZ2VvanNvblwiOiB7XG4gICAgXCJ0eXBlXCI6IHtcbiAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJnZW9qc29uXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwiZGF0YVwiOiB7XG4gICAgICBcInR5cGVcIjogXCIqXCJcbiAgICB9XG4gIH0sXG4gIFwic291cmNlX3ZpZGVvXCI6IHtcbiAgICBcInR5cGVcIjoge1xuICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcInZpZGVvXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidXJsXCI6IHtcbiAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcInZhbHVlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImRvY1wiOiBcIlVSTHMgdG8gdmlkZW8gY29udGVudCBpbiBvcmRlciBvZiBwcmVmZXJyZWQgZm9ybWF0LlwiXG4gICAgfSxcbiAgICBcImNvb3JkaW5hdGVzXCI6IHtcbiAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcImxlbmd0aFwiOiA0LFxuICAgICAgXCJ2YWx1ZVwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICAgIFwibGVuZ3RoXCI6IDIsXG4gICAgICAgIFwidmFsdWVcIjogXCJudW1iZXJcIlxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgXCJsYXllclwiOiB7XG4gICAgXCJpZFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZG9jXCI6IFwiVW5pcXVlIGxheWVyIG5hbWUuXCJcbiAgICB9LFxuICAgIFwidHlwZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwiZmlsbFwiLFxuICAgICAgICBcImxpbmVcIixcbiAgICAgICAgXCJzeW1ib2xcIixcbiAgICAgICAgXCJyYXN0ZXJcIixcbiAgICAgICAgXCJiYWNrZ3JvdW5kXCJcbiAgICAgIF0sXG4gICAgICBcImRvY1wiOiBcIlJlbmRlcmluZyB0eXBlIG9mIHRoaXMgbGF5ZXIuXCJcbiAgICB9LFxuICAgIFwicmVmXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkb2NcIjogXCJSZWZlcmVuY2VzIGFub3RoZXIgbGF5ZXIgdG8gY29weSBgdHlwZWAsIGBzb3VyY2VgLCBgc291cmNlLWxheWVyYCwgYG1pbnpvb21gLCBgbWF4em9vbWAsIGBmaWx0ZXJgLCBhbmQgYGxheW91dGAgcHJvcGVydGllcyBmcm9tLiBUaGlzIGFsbG93cyB0aGUgbGF5ZXJzIHRvIHNoYXJlIHByb2Nlc3NpbmcgYW5kIGJlIG1vcmUgZWZmaWNpZW50LlwiXG4gICAgfSxcbiAgICBcInNvdXJjZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZG9jXCI6IFwiTmFtZSBvZiBhIHNvdXJjZSBkZXNjcmlwdGlvbiB0byBiZSB1c2VkIGZvciB0aGlzIGxheWVyLlwiXG4gICAgfSxcbiAgICBcInNvdXJjZS1sYXllclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZG9jXCI6IFwiTGF5ZXIgdG8gdXNlIGZyb20gYSB2ZWN0b3IgdGlsZSBzb3VyY2UuIFJlcXVpcmVkIGlmIHRoZSBzb3VyY2Ugc3VwcG9ydHMgbXVsdGlwbGUgbGF5ZXJzLlwiXG4gICAgfSxcbiAgICBcIm1pbnpvb21cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwibWF4aW11bVwiOiAyMixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIG1pbmltdW0gem9vbSBsZXZlbCBvbiB3aGljaCB0aGUgbGF5ZXIgZ2V0cyBwYXJzZWQgYW5kIGFwcGVhcnMgb24uXCJcbiAgICB9LFxuICAgIFwibWF4em9vbVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJtYXhpbXVtXCI6IDIyLFxuICAgICAgXCJkb2NcIjogXCJUaGUgbWF4aW11bSB6b29tIGxldmVsIG9uIHdoaWNoIHRoZSBsYXllciBnZXRzIHBhcnNlZCBhbmQgYXBwZWFycyBvbi5cIlxuICAgIH0sXG4gICAgXCJpbnRlcmFjdGl2ZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImRvY1wiOiBcIkVuYWJsZSBxdWVyeWluZyBvZiBmZWF0dXJlIGRhdGEgZnJvbSB0aGlzIGxheWVyIGZvciBpbnRlcmFjdGl2aXR5LlwiLFxuICAgICAgXCJkZWZhdWx0XCI6IGZhbHNlXG4gICAgfSxcbiAgICBcImZpbHRlclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJmaWx0ZXJcIixcbiAgICAgIFwiZG9jXCI6IFwiQSBleHByZXNzaW9uIHNwZWNpZnlpbmcgY29uZGl0aW9ucyBvbiBzb3VyY2UgZmVhdHVyZXMuIE9ubHkgZmVhdHVyZXMgdGhhdCBtYXRjaCB0aGUgZmlsdGVyIGFyZSBkaXNwbGF5ZWQuXCJcbiAgICB9LFxuICAgIFwibGF5ZXJzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcInZhbHVlXCI6IFwibGF5ZXJcIixcbiAgICAgIFwiZG9jXCI6IFwiSWYgYHR5cGVgIGlzIGByYXN0ZXJgLCB0aGUgY2hpbGQgbGF5ZXJzIGFyZSBjb21wb3NpdGVkIHRvZ2V0aGVyIG9udG8gdGhlIHByZXZpb3VzIGxldmVsIGxheWVyIGxldmVsLlwiXG4gICAgfSxcbiAgICBcImxheW91dFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJsYXlvdXRcIixcbiAgICAgIFwiZG9jXCI6IFwiTGF5b3V0IHByb3BlcnRpZXMgZm9yIHRoZSBsYXllci5cIlxuICAgIH0sXG4gICAgXCJwYWludFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJwYWludFwiLFxuICAgICAgXCJkb2NcIjogXCJEZWZhdWx0IHBhaW50IHByb3BlcnRpZXMgZm9yIHRoaXMgbGF5ZXIuXCJcbiAgICB9LFxuICAgIFwicGFpbnQuKlwiOiB7XG4gICAgICBcInR5cGVcIjogXCJwYWludFwiLFxuICAgICAgXCJkb2NcIjogXCJDbGFzcy1zcGVjaWZpYyBwYWludCBwcm9wZXJ0aWVzIGZvciB0aGlzIGxheWVyLiBUaGUgY2xhc3MgbmFtZSBpcyB0aGUgcGFydCBhZnRlciB0aGUgZmlyc3QgZG90LlwiXG4gICAgfVxuICB9LFxuICBcImxheW91dFwiOiBbXG4gICAgXCJsYXlvdXRfZmlsbFwiLFxuICAgIFwibGF5b3V0X2xpbmVcIixcbiAgICBcImxheW91dF9zeW1ib2xcIixcbiAgICBcImxheW91dF9yYXN0ZXJcIixcbiAgICBcImxheW91dF9iYWNrZ3JvdW5kXCJcbiAgXSxcbiAgXCJsYXlvdXRfYmFja2dyb3VuZFwiOiB7XG4gIH0sXG4gIFwibGF5b3V0X2ZpbGxcIjoge1xuICB9LFxuICBcImxheW91dF9saW5lXCI6IHtcbiAgICBcImxpbmUtY2FwXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJidXR0XCIsXG4gICAgICAgIFwicm91bmRcIixcbiAgICAgICAgXCJzcXVhcmVcIlxuICAgICAgXSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcImJ1dHRcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGRpc3BsYXkgb2YgbGluZSBlbmRpbmdzLlwiXG4gICAgfSxcbiAgICBcImxpbmUtam9pblwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwiYmV2ZWxcIixcbiAgICAgICAgXCJyb3VuZFwiLFxuICAgICAgICBcIm1pdGVyXCJcbiAgICAgIF0sXG4gICAgICBcImRlZmF1bHRcIjogXCJtaXRlclwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgZGlzcGxheSBvZiBsaW5lcyB3aGVuIGpvaW5pbmcuXCJcbiAgICB9LFxuICAgIFwibGluZS1taXRlci1saW1pdFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAyLFxuICAgICAgXCJkb2NcIjogXCJVc2VkIHRvIGF1dG9tYXRpY2FsbHkgY29udmVydCBtaXRlciBqb2lucyB0byBiZXZlbCBqb2lucyBmb3Igc2hhcnAgYW5nbGVzLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBcImxpbmUtam9pblwiOiBcIm1pdGVyXCJcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG4gICAgXCJsaW5lLXJvdW5kLWxpbWl0XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcImRvY1wiOiBcIlVzZWQgdG8gYXV0b21hdGljYWxseSBjb252ZXJ0IHJvdW5kIGpvaW5zIHRvIG1pdGVyIGpvaW5zIGZvciBzaGFsbG93IGFuZ2xlcy5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICB7XG4gICAgICAgICAgXCJsaW5lLWpvaW5cIjogXCJyb3VuZFwiXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9XG4gIH0sXG4gIFwibGF5b3V0X3N5bWJvbFwiOiB7XG4gICAgXCJzeW1ib2wtcGxhY2VtZW50XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgICBcInBvaW50XCIsXG4gICAgICAgICAgXCJsaW5lXCJcbiAgICAgIF0sXG4gICAgICBcImRlZmF1bHRcIjogXCJwb2ludFwiLFxuICAgICAgXCJkb2NcIjogXCJMYWJlbCBwbGFjZW1lbnQgcmVsYXRpdmUgdG8gaXRzIGdlb21ldHJ5LiBgbGluZWAgY2FuIG9ubHkgYmUgdXNlZCBvbiBMaW5lU3RyaW5ncyBhbmQgUG9seWdvbnMuXCJcbiAgICB9LFxuICAgIFwic3ltYm9sLW1pbi1kaXN0YW5jZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAyNTAsXG4gICAgICBcIm1pbmltdW1cIjogMSxcbiAgICAgIFwidW5pdHNcIjogXCJwaXhlbHNcIixcbiAgICAgIFwiZG9jXCI6IFwiTWluaW11bSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBzeW1ib2wgYW5jaG9ycy5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICB7XG4gICAgICAgICAgXCJzeW1ib2wtcGxhY2VtZW50XCI6IFwibGluZVwiXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9LFxuICAgIFwic3ltYm9sLWF2b2lkLWVkZ2VzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZSxcbiAgICAgIFwiZG9jXCI6IFwiSWYgdHJ1ZSwgdGhlIHN5bWJvbHMgd2lsbCBub3QgY3Jvc3MgdGlsZSBlZGdlcyB0byBhdm9pZCBtdXR1YWwgY29sbGlzaW9ucy4gUmVjb21tZW5kZWQgaW4gbGF5ZXJzIHRoYXQgZG9uJ3QgaGF2ZSBlbm91Z2ggcGFkZGluZyBpbiB0aGUgdmVjdG9yIHRpbGUgdG8gcHJldmVudCBjb2xsaXNpb25zLCBvciBpZiBpdCBpcyBhIHBvaW50IHN5bWJvbCBsYXllciBwbGFjZWQgYWZ0ZXIgYSBsaW5lIHN5bWJvbCBsYXllci5cIlxuICAgIH0sXG4gICAgXCJpY29uLWFsbG93LW92ZXJsYXBcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgXCJkZWZhdWx0XCI6IGZhbHNlLFxuICAgICAgXCJkb2NcIjogXCJJZiB0cnVlLCB0aGUgaWNvbiB3aWxsIGJlIHZpc2libGUgZXZlbiBpZiBpdCBjb2xsaWRlcyB3aXRoIG90aGVyIGljb25zIGFuZCB0ZXh0LlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcImljb24taWdub3JlLXBsYWNlbWVudFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImRlZmF1bHRcIjogZmFsc2UsXG4gICAgICBcImRvY1wiOiBcIklmIHRydWUsIHRoZSBpY29uIHdvbid0IGFmZmVjdCBwbGFjZW1lbnQgb2Ygb3RoZXIgaWNvbnMgYW5kIHRleHQuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJpY29uLWltYWdlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwiaWNvbi1vcHRpb25hbFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImRlZmF1bHRcIjogZmFsc2UsXG4gICAgICBcImRvY1wiOiBcIklmIHRydWUsIHRleHQgY2FuIGJlIHNob3duIHdpdGhvdXQgaXRzIGNvcnJlc3BvbmRpbmcgaWNvbi5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImljb24taW1hZ2VcIixcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwiaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcIm1hcFwiLFxuICAgICAgICBcInZpZXdwb3J0XCJcbiAgICAgIF0sXG4gICAgICBcImRlZmF1bHRcIjogXCJ2aWV3cG9ydFwiLFxuICAgICAgXCJkb2NcIjogXCJPcmllbnRhdGlvbiBvZiBpY29uIHdoZW4gbWFwIGlzIHJvdGF0ZWQuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJpY29uLWltYWdlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwiaWNvbi1tYXgtc2l6ZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAxLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcImRvY1wiOiBcIlRoZSBtYXhpbXVtIGZhY3RvciB0byBzY2FsZSB0aGUgaWNvbi5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImljb24taW1hZ2VcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJpY29uLWltYWdlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkb2NcIjogXCJBIHN0cmluZyB3aXRoIHt0b2tlbnN9IHJlcGxhY2VkLCByZWZlcmVuY2luZyB0aGUgZGF0YSBwcm9wZXJ0eSB0byBwdWxsIGZyb20uXCIsXG4gICAgICBcInRva2Vuc1wiOiB0cnVlXG4gICAgfSxcbiAgICBcImljb24tcm90YXRlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcInBlcmlvZFwiOiAzNjAsXG4gICAgICBcInVuaXRzXCI6IFwiZGVncmVlc1wiLFxuICAgICAgXCJkb2NcIjogXCJSb3RhdGVzIHRoZSBpY29uIGNsb2Nrd2lzZS5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImljb24taW1hZ2VcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJpY29uLXBhZGRpbmdcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMixcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJQYWRkaW5nIHZhbHVlIGFyb3VuZCBpY29uIGJvdW5kaW5nIGJveCB0byBhdm9pZCBpY29uIGNvbGxpc2lvbnMuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJpY29uLWltYWdlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwiaWNvbi1rZWVwLXVwcmlnaHRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgXCJkZWZhdWx0XCI6IGZhbHNlLFxuICAgICAgXCJkb2NcIjogXCJJZiB0cnVlLCB0aGUgaWNvbiBtYXkgYmUgZmxpcHBlZCB0byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgcmVuZGVyZWQgdXBzaWRlLWRvd25cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImljb24taW1hZ2VcIixcbiAgICAgICAge1xuICAgICAgICAgIFwiaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnRcIjogXCJtYXBcIlxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSxcbiAgICBcImljb24tb2Zmc2V0XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcInZhbHVlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImxlbmd0aFwiOiAyLFxuICAgICAgXCJkZWZhdWx0XCI6IFtcbiAgICAgICAgMCxcbiAgICAgICAgMFxuICAgICAgXSxcbiAgICAgIFwiZG9jXCI6IFwiSWNvbidzIG9mZnNldCBkaXN0YW5jZS4gVmFsdWVzIGFyZSBbeCwgeV0gd2hlcmUgbmVnYXRpdmVzIGluZGljYXRlIGxlZnQgYW5kIHVwLCByZXNwZWN0aXZlbHkuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJpY29uLWltYWdlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1yb3RhdGlvbi1hbGlnbm1lbnRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcIm1hcFwiLFxuICAgICAgICBcInZpZXdwb3J0XCJcbiAgICAgIF0sXG4gICAgICBcImRlZmF1bHRcIjogXCJ2aWV3cG9ydFwiLFxuICAgICAgXCJkb2NcIjogXCJPcmllbnRhdGlvbiBvZiBpY29uIG9yIHRleHQgd2hlbiBtYXAgaXMgcm90YXRlZC5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LWZpZWxkXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkZWZhdWx0XCI6IFwiXCIsXG4gICAgICBcInRva2Vuc1wiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJWYWx1ZSB0byB1c2UgZm9yIGEgdGV4dCBsYWJlbC4gRmVhdHVyZSBwcm9wZXJ0aWVzIGFyZSBzcGVjaWZpZWQgdXNpbmcgdG9rZW5zIGxpa2Uge2ZpZWxkX25hbWV9LlwiXG4gICAgfSxcbiAgICBcInRleHQtZm9udFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIk9wZW4gU2FucyBSZWd1bGFyLCBBcmlhbCBVbmljb2RlIE1TIFJlZ3VsYXJcIixcbiAgICAgIFwiZG9jXCI6IFwiRm9udCBzdGFjayB0byB1c2UgZm9yIGRpc3BsYXlpbmcgdGV4dC5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LW1heC1zaXplXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDE2LFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBtYXhpbXVtIHNpemUgdGV4dCB3aWxsIGJlIGxhaWQgb3V0LCB0byBjYWxjdWxhdGUgY29sbGlzaW9ucyB3aXRoLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtbWF4LXdpZHRoXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDE1LFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcInVuaXRzXCI6IFwiZW1cIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIG1heGltdW0gbGluZSB3aWR0aCBmb3IgdGV4dCB3cmFwcGluZy5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LWxpbmUtaGVpZ2h0XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEuMixcbiAgICAgIFwidW5pdHNcIjogXCJlbVwiLFxuICAgICAgXCJkb2NcIjogXCJUZXh0IGxlYWRpbmcgdmFsdWUgZm9yIG11bHRpLWxpbmUgdGV4dC5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LWxldHRlci1zcGFjaW5nXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcInVuaXRzXCI6IFwiZW1cIixcbiAgICAgIFwiZG9jXCI6IFwiVGV4dCBrZXJuaW5nIHZhbHVlLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtanVzdGlmeVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwibGVmdFwiLFxuICAgICAgICBcImNlbnRlclwiLFxuICAgICAgICBcInJpZ2h0XCJcbiAgICAgIF0sXG4gICAgICBcImRlZmF1bHRcIjogXCJjZW50ZXJcIixcbiAgICAgIFwiZG9jXCI6IFwiVGV4dCBqdXN0aWZpY2F0aW9uIG9wdGlvbnMuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1hbmNob3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcImNlbnRlclwiLFxuICAgICAgICBcImxlZnRcIixcbiAgICAgICAgXCJyaWdodFwiLFxuICAgICAgICBcInRvcFwiLFxuICAgICAgICBcImJvdHRvbVwiLFxuICAgICAgICBcInRvcC1sZWZ0XCIsXG4gICAgICAgIFwidG9wLXJpZ2h0XCIsXG4gICAgICAgIFwiYm90dG9tLWxlZnRcIixcbiAgICAgICAgXCJib3R0b20tcmlnaHRcIlxuICAgICAgXSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcImNlbnRlclwiLFxuICAgICAgXCJkb2NcIjogXCJXaGljaCBwYXJ0IG9mIHRoZSB0ZXh0IHRvIHBsYWNlIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LW1heC1hbmdsZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiA0NSxcbiAgICAgIFwidW5pdHNcIjogXCJkZWdyZWVzXCIsXG4gICAgICBcImRvY1wiOiBcIk1heGltdW0gYW5nbGUgY2hhbmdlIGJldHdlZW4gYWRqYWNlbnQgY2hhcmFjdGVycy5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIixcbiAgICAgICAge1xuICAgICAgICAgIFwic3ltYm9sLXBsYWNlbWVudFwiOiBcImxpbmVcIlxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtcm90YXRlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcInBlcmlvZFwiOiAzNjAsXG4gICAgICBcInVuaXRzXCI6IFwiZGVncmVlc1wiLFxuICAgICAgXCJkb2NcIjogXCJSb3RhdGVzIHRoZSB0ZXh0IGNsb2Nrd2lzZS5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LXBhZGRpbmdcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMixcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJQYWRkaW5nIHZhbHVlIGFyb3VuZCB0ZXh0IGJvdW5kaW5nIGJveCB0byBhdm9pZCBsYWJlbCBjb2xsaXNpb25zLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQta2VlcC11cHJpZ2h0XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJJZiB0cnVlLCB0aGUgdGV4dCBtYXkgYmUgZmxpcHBlZCB2ZXJ0aWNhbGx5IHRvIHByZXZlbnQgaXQgZnJvbSBiZWluZyByZW5kZXJlZCB1cHNpZGUtZG93bi5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIixcbiAgICAgICAge1xuICAgICAgICAgIFwidGV4dC1yb3RhdGlvbi1hbGlnbm1lbnRcIjogXCJtYXBcIlxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtdHJhbnNmb3JtXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJub25lXCIsXG4gICAgICAgIFwidXBwZXJjYXNlXCIsXG4gICAgICAgIFwibG93ZXJjYXNlXCJcbiAgICAgIF0sXG4gICAgICBcImRlZmF1bHRcIjogXCJub25lXCIsXG4gICAgICBcImRvY1wiOiBcIlNwZWNpZmllcyBob3cgdG8gY2FwaXRhbGl6ZSB0ZXh0LCBzaW1pbGFyIHRvIHRoZSBDU1MgYHRleHQtdHJhbnNmb3JtYCBwcm9wZXJ0eS5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LW9mZnNldFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJkb2NcIjogXCJTcGVjaWZpZXMgdGhlIGRpc3RhbmNlIHRoYXQgdGV4dCBpcyBvZmZzZXQgZnJvbSBpdHMgYW5jaG9yIGhvcml6b250YWxseSBhbmQgdmVydGljYWxseS5cIixcbiAgICAgIFwidmFsdWVcIjogXCJudW1iZXJcIixcbiAgICAgIFwidW5pdHNcIjogXCJlbXNcIixcbiAgICAgIFwibGVuZ3RoXCI6IDIsXG4gICAgICBcImRlZmF1bHRcIjogW1xuICAgICAgICAwLFxuICAgICAgICAwXG4gICAgICBdLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtYWxsb3ctb3ZlcmxhcFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImRlZmF1bHRcIjogZmFsc2UsXG4gICAgICBcImRvY1wiOiBcIklmIHRydWUsIHRoZSB0ZXh0IHdpbGwgYmUgdmlzaWJsZSBldmVuIGlmIGl0IGNvbGxpZGVzIHdpdGggb3RoZXIgaWNvbnMgYW5kIGxhYmVscy5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LWlnbm9yZS1wbGFjZW1lbnRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgXCJkZWZhdWx0XCI6IGZhbHNlLFxuICAgICAgXCJkb2NcIjogXCJJZiB0cnVlLCB0aGUgdGV4dCB3b24ndCBhZmZlY3QgcGxhY2VtZW50IG9mIG90aGVyIGljb25zIGFuZCBsYWJlbHMuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1vcHRpb25hbFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImRlZmF1bHRcIjogZmFsc2UsXG4gICAgICBcImRvY1wiOiBcIklmIHRydWUsIGljb25zIGNhbiBiZSBzaG93biB3aXRob3V0IHRoZWlyIGNvcnJlc3BvbmRpbmcgdGV4dC5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIixcbiAgICAgICAgXCJpY29uLWltYWdlXCJcbiAgICAgIF1cbiAgICB9XG4gIH0sXG4gIFwibGF5b3V0X3Jhc3RlclwiOiB7XG4gICAgXCJyYXN0ZXItc2l6ZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAyNTYsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwibWF4aW11bVwiOiAzODU1LFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgdGV4dHVyZSBpbWFnZSBzaXplIGF0IHdoaWNoIHZlY3RvciBsYXllcnMgd2lsbCBiZSByYXN0ZXJpemVkLiBXaWxsIHNjYWxlIHRvIG1hdGNoIHRoZSB2aXN1YWwgdGlsZSBzaXplLlwiXG4gICAgfSxcbiAgICBcInJhc3Rlci1ibHVyXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwidW5pdHNcIjogXCJwaXhlbHNcIixcbiAgICAgIFwiZG9jXCI6IFwiQmx1ciByYWRpdXMgYXBwbGllZCB0byB0aGUgcmFzdGVyIHRleHR1cmUgYmVmb3JlIGRpc3BsYXkuXCJcbiAgICB9XG4gIH0sXG4gIFwiZmlsdGVyXCI6IHtcbiAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgIFwidmFsdWVcIjogXCIqXCJcbiAgfSxcbiAgXCJmaWx0ZXJfb3BlcmF0b3JcIjoge1xuICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICBcInZhbHVlc1wiOiBbXG4gICAgICBcIj09XCIsXG4gICAgICBcIiE9XCIsXG4gICAgICBcIj5cIixcbiAgICAgIFwiPj1cIixcbiAgICAgIFwiPFwiLFxuICAgICAgXCI8PVwiLFxuICAgICAgXCJpblwiLFxuICAgICAgXCIhaW5cIixcbiAgICAgIFwiYWxsXCIsXG4gICAgICBcImFueVwiLFxuICAgICAgXCJub25lXCJcbiAgICBdXG4gIH0sXG4gIFwiZ2VvbWV0cnlfdHlwZVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgIFwidmFsdWVzXCI6IFtcbiAgICAgIFwiUG9pbnRcIixcbiAgICAgIFwiTGluZVN0cmluZ1wiLFxuICAgICAgXCJQb2x5Z29uXCJcbiAgICBdXG4gIH0sXG4gIFwiZnVuY3Rpb25cIjoge1xuICAgIFwic3RvcHNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiQW4gYXJyYXkgb2Ygc3RvcHMuXCIsXG4gICAgICBcInZhbHVlXCI6IFwiZnVuY3Rpb25fc3RvcFwiXG4gICAgfSxcbiAgICBcImJhc2VcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMSxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJkb2NcIjogXCJUaGUgZXhwb25lbnRpYWwgYmFzZSBvZiB0aGUgaW50ZXJwb2xhdGlvbiBjdXJ2ZS4gSXQgY29udHJvbHMgdGhlIHJhdGUgYXQgd2hpY2ggdGhlIHJlc3VsdCBpbmNyZWFzZXMuIEhpZ2hlciB2YWx1ZXMgbWFrZSB0aGUgcmVzdWx0IGluY3JlYXNlIG1vcmUgdG93YXJkcyB0aGUgaGlnaCBlbmQgb2YgdGhlIHJhbmdlLiBXaXRoIGAxYCB0aGUgc3RvcHMgYXJlIGludGVycG9sYXRlZCBsaW5lYXJseS5cIlxuICAgIH1cbiAgfSxcbiAgXCJmdW5jdGlvbl9zdG9wXCI6IHtcbiAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgIFwibWluaW11bVwiOiAwLFxuICAgIFwibWF4aW11bVwiOiAyMixcbiAgICBcInZhbHVlXCI6IFtcbiAgICAgIFwibnVtYmVyXCIsXG4gICAgICBcImNvbG9yXCJcbiAgICBdLFxuICAgIFwibGVuZ3RoXCI6IDIsXG4gICAgXCJkb2NcIjogXCJab29tIGxldmVsIGFuZCB2YWx1ZSBwYWlyLlwiXG4gIH0sXG4gIFwicGFpbnRcIjogW1xuICAgIFwicGFpbnRfZmlsbFwiLFxuICAgIFwicGFpbnRfbGluZVwiLFxuICAgIFwicGFpbnRfc3ltYm9sXCIsXG4gICAgXCJwYWludF9yYXN0ZXJcIixcbiAgICBcInBhaW50X2JhY2tncm91bmRcIlxuICBdLFxuICBcInBhaW50X2ZpbGxcIjoge1xuICAgIFwiZmlsbC1hbnRpYWxpYXNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgXCJkZWZhdWx0XCI6IHRydWUsXG4gICAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcImRvY1wiOiBcIldoZXRoZXIgb3Igbm90IHRoZSBmaWxsIHNob3VsZCBiZSBhbnRpYWxpYXNlZC5cIlxuICAgIH0sXG4gICAgXCJmaWxsLW9wYWNpdHlcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcImRlZmF1bHRcIjogMSxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJtYXhpbXVtXCI6IDEsXG4gICAgICBcImRvY1wiOiBcIlRoZSBvcGFjaXR5IGdpdmVuIHRvIHRoZSBmaWxsIGNvbG9yLlwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWVcbiAgICB9LFxuICAgIFwiZmlsbC1jb2xvclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJjb2xvclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IFwiIzAwMDAwMFwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgY29sb3Igb2YgdGhlIGZpbGwuXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICB7XG4gICAgICAgICAgXCIhXCI6IFwiZmlsbC1pbWFnZVwiXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9LFxuICAgIFwiZmlsbC1vdXRsaW5lLWNvbG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBvdXRsaW5lIGNvbG9yIG9mIHRoZSBmaWxsLiBNYXRjaGVzIHRoZSB2YWx1ZSBvZiBgZmlsbC1jb2xvcmAgaWYgdW5zcGVjaWZpZWQuXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICB7XG4gICAgICAgICAgXCIhXCI6IFwiZmlsbC1pbWFnZVwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBcImZpbGwtYW50aWFsaWFzXCI6IHRydWVcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG4gICAgXCJmaWxsLXRyYW5zbGF0ZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJ2YWx1ZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJsZW5ndGhcIjogMixcbiAgICAgIFwiZGVmYXVsdFwiOiBbXG4gICAgICAgIDAsXG4gICAgICAgIDBcbiAgICAgIF0sXG4gICAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwidW5pdHNcIjogXCJwaXhlbHNcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGdlb21ldHJ5J3Mgb2Zmc2V0LiBWYWx1ZXMgYXJlIFt4LCB5XSB3aGVyZSBuZWdhdGl2ZXMgaW5kaWNhdGUgbGVmdCBhbmQgdXAsIHJlc3BlY3RpdmVseS5cIlxuICAgIH0sXG4gICAgXCJmaWxsLXRyYW5zbGF0ZS1hbmNob3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcIm1hcFwiLFxuICAgICAgICBcInZpZXdwb3J0XCJcbiAgICAgIF0sXG4gICAgICBcImRvY1wiOiBcIkNvbnRyb2wgd2hldGhlciB0aGUgdHJhbnNsYXRpb24gaXMgcmVsYXRpdmUgdG8gdGhlIG1hcCAobm9ydGgpIG9yIHZpZXdwb3J0IChzY3JlZW4pXCIsXG4gICAgICBcImRlZmF1bHRcIjogXCJtYXBcIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImZpbGwtdHJhbnNsYXRlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwiZmlsbC1pbWFnZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZG9jXCI6IFwiTmFtZSBvZiBpbWFnZSBpbiBzcHJpdGUgdG8gdXNlIGZvciBkcmF3aW5nIGltYWdlIGZpbGxzLlwiXG4gICAgfVxuICB9LFxuICBcInBhaW50X2xpbmVcIjoge1xuICAgIFwibGluZS1vcGFjaXR5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgb3BhY2l0eSBhdCB3aGljaCB0aGUgbGluZSB3aWxsIGJlIGRyYXduLlwiLFxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwibWF4aW11bVwiOiAxLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWVcbiAgICB9LFxuICAgIFwibGluZS1jb2xvclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJjb2xvclwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgY29sb3Igd2l0aCB3aGljaCB0aGUgbGluZSB3aWxsIGJlIGRyYXduLlwiLFxuICAgICAgXCJkZWZhdWx0XCI6IFwiIzAwMDAwMFwiLFxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgIFwiIVwiOiBcImxpbmUtaW1hZ2VcIlxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSxcbiAgICBcImxpbmUtdHJhbnNsYXRlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcInZhbHVlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImxlbmd0aFwiOiAyLFxuICAgICAgXCJkZWZhdWx0XCI6IFtcbiAgICAgICAgMCxcbiAgICAgICAgMFxuICAgICAgXSxcbiAgICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgZ2VvbWV0cnkncyBvZmZzZXQuIFZhbHVlcyBhcmUgW3gsIHldIHdoZXJlIG5lZ2F0aXZlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cCwgcmVzcGVjdGl2ZWx5LlwiXG4gICAgfSxcbiAgICBcImxpbmUtdHJhbnNsYXRlLWFuY2hvclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwibWFwXCIsXG4gICAgICAgIFwidmlld3BvcnRcIlxuICAgICAgXSxcbiAgICAgIFwiZG9jXCI6IFwiQ29udHJvbCB3aGV0aGVyIHRoZSB0cmFuc2xhdGlvbiBpcyByZWxhdGl2ZSB0byB0aGUgbWFwIChub3J0aCkgb3Igdmlld3BvcnQgKHNjcmVlbilcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIm1hcFwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwibGluZS10cmFuc2xhdGVcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJsaW5lLXdpZHRoXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJTdHJva2UgdGhpY2tuZXNzLlwiXG4gICAgfSxcbiAgICBcImxpbmUtZ2FwLXdpZHRoXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwiZG9jXCI6IFwiRHJhd3MgYSBsaW5lIGNhc2luZyBvdXRzaWRlIG9mIGEgbGluZSdzIGFjdHVhbCBwYXRoLiBWYWx1ZSBpbmRpY2F0ZXMgdGhlIHdpZHRoIG9mIHRoZSBpbm5lciBnYXAuXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwidW5pdHNcIjogXCJwaXhlbHNcIlxuICAgIH0sXG4gICAgXCJsaW5lLWJsdXJcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCIsXG4gICAgICBcImRvY1wiOiBcIkJsdXIgYXBwbGllZCB0byB0aGUgbGluZSwgaW4gcGl4ZWxzLlwiXG4gICAgfSxcbiAgICBcImxpbmUtZGFzaGFycmF5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcInZhbHVlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRvY1wiOiBcIlNwZWNpZmllcyB0aGUgc2l6ZSBhbmQgZ2FwIGJldHdlZW4gZGFzaGVzIGluIGEgbGluZS5cIixcbiAgICAgIFwibGVuZ3RoXCI6IDIsXG4gICAgICBcImRlZmF1bHRcIjogW1xuICAgICAgICAxLFxuICAgICAgICAtMVxuICAgICAgXSxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgIFwiIVwiOiBcImxpbmUtaW1hZ2VcIlxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSxcbiAgICBcImxpbmUtaW1hZ2VcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImRvY1wiOiBcIk5hbWUgb2YgaW1hZ2UgaW4gc3ByaXRlIHRvIHVzZSBmb3IgZHJhd2luZyBpbWFnZSBsaW5lcy5cIlxuICAgIH1cbiAgfSxcbiAgXCJwYWludF9zeW1ib2xcIjoge1xuICAgIFwiaWNvbi1vcGFjaXR5XCI6IHtcbiAgICAgIFwiZG9jXCI6IFwiVGhlIG9wYWNpdHkgYXQgd2hpY2ggdGhlIGljb24gd2lsbCBiZSBkcmF3bi5cIixcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwibWF4aW11bVwiOiAxLFxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJpY29uLWltYWdlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwiaWNvbi1zaXplXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiU2NhbGUgZmFjdG9yIGZvciBpY29uLiAxIGlzIG9yaWdpbmFsIHNpemUsIDMgdHJpcGxlcyB0aGUgc2l6ZS5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImljb24taW1hZ2VcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJpY29uLWNvbG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXG4gICAgICBcImRlZmF1bHRcIjogXCIjMDAwMDAwXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGNvbG9yIG9mIHRoZSBpY29uLiBUaGlzIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBzZGYgaWNvbnMuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJpY29uLWltYWdlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwiaWNvbi1oYWxvLWNvbG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXG4gICAgICBcImRlZmF1bHRcIjogXCJyZ2JhKDAsIDAsIDAsIDApXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGNvbG9yIG9mIHRoZSBpY29uJ3MgaGFsby4gSWNvbiBoYWxvcyBjYW4gb25seSBiZSB1c2VkIHdpdGggc2RmIGljb25zLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcImljb24taGFsby13aWR0aFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwidW5pdHNcIjogXCJwaXhlbHNcIixcbiAgICAgIFwiZG9jXCI6IFwiRGlzdGFuY2Ugb2YgaGFsbyB0byB0aGUgaWNvbiBvdXRsaW5lLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcImljb24taGFsby1ibHVyXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJGYWRlIG91dCB0aGUgaGFsbyB0b3dhcmRzIHRoZSBvdXRzaWRlLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcImljb24tdHJhbnNsYXRlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcInZhbHVlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImxlbmd0aFwiOiAyLFxuICAgICAgXCJkZWZhdWx0XCI6IFtcbiAgICAgICAgMCxcbiAgICAgICAgMFxuICAgICAgXSxcbiAgICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJBbiBpY29uJ3Mgb2Zmc2V0IGRpc3RhbmNlLiBWYWx1ZXMgYXJlIFt4LCB5XSB3aGVyZSBuZWdhdGl2ZXMgaW5kaWNhdGUgbGVmdCBhbmQgdXAsIHJlc3BlY3RpdmVseS5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImljb24taW1hZ2VcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJpY29uLXRyYW5zbGF0ZS1hbmNob3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcIm1hcFwiLFxuICAgICAgICBcInZpZXdwb3J0XCJcbiAgICAgIF0sXG4gICAgICBcImRvY1wiOiBcIkNvbnRyb2wgd2hldGhlciB0aGUgdHJhbnNsYXRpb24gaXMgcmVsYXRpdmUgdG8gdGhlIG1hcCAobm9ydGgpIG9yIHZpZXdwb3J0IChzY3JlZW4pXCIsXG4gICAgICBcImRlZmF1bHRcIjogXCJtYXBcIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImljb24taW1hZ2VcIixcbiAgICAgICAgXCJpY29uLXRyYW5zbGF0ZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtb3BhY2l0eVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIG9wYWNpdHkgYXQgd2hpY2ggdGhlIHRleHQgd2lsbCBiZSBkcmF3bi5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiAxLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcIm1heGltdW1cIjogMSxcbiAgICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtc2l6ZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAxNixcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCIsXG4gICAgICBcImRvY1wiOiBcIkZvbnQgc2l6ZS4gSWYgdW5zcGVjaWZpZWQsIHRoZSB0ZXh0IHdpbGwgYmUgYXMgYmlnIGFzIGFsbG93ZWQgYnkgdGhlIGxheWVyIGRlZmluaXRpb24uXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1jb2xvclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJjb2xvclwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgY29sb3Igd2l0aCB3aGljaCB0aGUgdGV4dCB3aWxsIGJlIGRyYXduLlwiLFxuICAgICAgXCJkZWZhdWx0XCI6IFwiIzAwMDAwMFwiLFxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1oYWxvLWNvbG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXG4gICAgICBcImRlZmF1bHRcIjogXCJyZ2JhKDAsIDAsIDAsIDApXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGNvbG9yIG9mIHRoZSB0ZXh0J3MgaGFsbywgd2hpY2ggaGVscHMgaXQgc3RhbmQgb3V0IGZyb20gYmFja2dyb3VuZHMuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1oYWxvLXdpZHRoXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJEaXN0YW5jZSBvZiBoYWxvIHRvIHRoZSBmb250IG91dGxpbmUuIE1heCB0ZXh0IGhhbG8gd2lkdGggaXMgMS80IG9mIHRoZSBmb250LXNpemUuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1oYWxvLWJsdXJcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBoYWxvJ3MgZmFkZW91dCBkaXN0YW5jZSB0b3dhcmRzIHRoZSBvdXRzaWRlLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtdHJhbnNsYXRlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcInZhbHVlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImxlbmd0aFwiOiAyLFxuICAgICAgXCJkZWZhdWx0XCI6IFtcbiAgICAgICAgMCxcbiAgICAgICAgMFxuICAgICAgXSxcbiAgICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJMYWJlbCBvZmZzZXQuIFZhbHVlcyBhcmUgW3gsIHldIHdoZXJlIG5lZ2F0aXZlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cCwgcmVzcGVjdGl2ZWx5LlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtdHJhbnNsYXRlLWFuY2hvclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwibWFwXCIsXG4gICAgICAgIFwidmlld3BvcnRcIlxuICAgICAgXSxcbiAgICAgIFwiZG9jXCI6IFwiQ29udHJvbCB3aGV0aGVyIHRoZSB0cmFuc2xhdGlvbiBpcyByZWxhdGl2ZSB0byB0aGUgbWFwIChub3J0aCkgb3Igdmlld3BvcnQgKHNjcmVlbilcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIm1hcFwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiLFxuICAgICAgICBcInRleHQtdHJhbnNsYXRlXCJcbiAgICAgIF1cbiAgICB9XG4gIH0sXG4gIFwicGFpbnRfcmFzdGVyXCI6IHtcbiAgICBcInJhc3Rlci1vcGFjaXR5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgb3BhY2l0eSBhdCB3aGljaCB0aGUgaW1hZ2Ugd2lsbCBiZSBkcmF3bi5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiAxLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcIm1heGltdW1cIjogMSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlXG4gICAgfSxcbiAgICBcInJhc3Rlci1odWUtcm90YXRlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcInBlcmlvZFwiOiAzNjAsXG4gICAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwidW5pdHNcIjogXCJkZWdyZWVzXCIsXG4gICAgICBcImRvY1wiOiBcIlJvdGF0ZXMgaHVlcyBhcm91bmQgdGhlIGNvbG9yIHdoZWVsLlwiXG4gICAgfSxcbiAgICBcInJhc3Rlci1icmlnaHRuZXNzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcInZhbHVlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRvY1wiOiBcIkluY3JlYXNlIG9yIHJlZHVjZSB0aGUgYnJpZ2h0bmVzcyBvZiB0aGUgaW1hZ2UuIEZpcnN0IHZhbHVlIGlzIHRoZSBtaW5pbXVtLCBzZWNvbmQgaXMgdGhlIG1heGltdW0gYnJpZ2h0bmVzcy5cIixcbiAgICAgIFwibGVuZ3RoXCI6IDIsXG4gICAgICBcImRlZmF1bHRcIjogW1xuICAgICAgICAwLFxuICAgICAgICAxXG4gICAgICBdLFxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWVcbiAgICB9LFxuICAgIFwicmFzdGVyLXNhdHVyYXRpb25cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRvY1wiOiBcIkluY3JlYXNlIG9yIHJlZHVjZSB0aGUgc2F0dXJhdGlvbiBvZiB0aGUgaW1hZ2UuXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwibWluaW11bVwiOiAtMSxcbiAgICAgIFwibWF4aW11bVwiOiAxLFxuICAgICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWVcbiAgICB9LFxuICAgIFwicmFzdGVyLWNvbnRyYXN0XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkb2NcIjogXCJJbmNyZWFzZSBvciByZWR1Y2UgdGhlIGNvbnRyYXN0IG9mIHRoZSBpbWFnZS5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJtaW5pbXVtXCI6IC0xLFxuICAgICAgXCJtYXhpbXVtXCI6IDEsXG4gICAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJyYXN0ZXItZmFkZS1kdXJhdGlvblwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAzMDAsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcIm1pbGxpc2Vjb25kc1wiLFxuICAgICAgXCJkb2NcIjogXCJGYWRlIGR1cmF0aW9uIHdoZW4gYSBuZXcgdGlsZSBpcyBhZGRlZC5cIlxuICAgIH1cbiAgfSxcbiAgXCJwYWludF9iYWNrZ3JvdW5kXCI6IHtcbiAgICBcImJhY2tncm91bmQtY29sb3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGNvbG9yIHdpdGggd2hpY2ggdGhlIGJhY2tncm91bmQgd2lsbCBiZSBkcmF3bi5cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBcIiFcIjogXCJiYWNrZ3JvdW5kLWltYWdlXCJcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG4gICAgXCJiYWNrZ3JvdW5kLWltYWdlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkb2NcIjogXCJPcHRpb25hbGx5IGFuIGltYWdlIHdoaWNoIGlzIGRyYXduIGFzIHRoZSBiYWNrZ3JvdW5kLlwiXG4gICAgfSxcbiAgICBcImJhY2tncm91bmQtb3BhY2l0eVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAxLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcIm1heGltdW1cIjogMSxcbiAgICAgIFwiZG9jXCI6IFwiVGhlIG9wYWNpdHkgYXQgd2hpY2ggdGhlIGJhY2tncm91bmQgd2lsbCBiZSBkcmF3bi5cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlXG4gICAgfVxuICB9LFxuICBcInRyYW5zaXRpb25cIjoge1xuICAgIFwiZHVyYXRpb25cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMzAwLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcInVuaXRzXCI6IFwibWlsbGlzZWNvbmRzXCIsXG4gICAgICBcImRvY1wiOiBcIlRpbWUgYWxsb3R0ZWQgZm9yIHRyYW5zaXRpb25zIHRvIGNvbXBsZXRlLlwiXG4gICAgfSxcbiAgICBcImRlbGF5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwidW5pdHNcIjogXCJtaWxsaXNlY29uZHNcIixcbiAgICAgIFwiZG9jXCI6IFwiTGVuZ3RoIG9mIHRpbWUgYmVmb3JlIGEgdHJhbnNpdGlvbiBiZWdpbnMuXCJcbiAgICB9XG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkdmVyc2lvblwiOiA3LFxuICBcIiRyb290XCI6IHtcbiAgICBcInZlcnNpb25cIjoge1xuICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICA3XG4gICAgICBdLFxuICAgICAgXCJkb2NcIjogXCJTdHlsZXNoZWV0IHZlcnNpb24gbnVtYmVyLiBNdXN0IGJlIDcuXCJcbiAgICB9LFxuICAgIFwibmFtZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZG9jXCI6IFwiQSBodW1hbi1yZWFkYWJsZSBuYW1lIGZvciB0aGUgc3R5bGUuXCJcbiAgICB9LFxuICAgIFwiY29uc3RhbnRzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImNvbnN0YW50c1wiLFxuICAgICAgXCJkb2NcIjogXCJBbiBvYmplY3Qgb2YgY29uc3RhbnRzIHRvIGJlIHJlZmVyZW5jZWQgaW4gbGF5ZXJzLlwiXG4gICAgfSxcbiAgICBcInNvdXJjZXNcIjoge1xuICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgXCJ0eXBlXCI6IFwic291cmNlc1wiLFxuICAgICAgXCJkb2NcIjogXCJEYXRhIHNvdXJjZSBzcGVjaWZpY2F0aW9ucy5cIlxuICAgIH0sXG4gICAgXCJzcHJpdGVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImRvY1wiOiBcIkEgYmFzZSBVUkwgZm9yIHJldHJpZXZpbmcgdGhlIHNwcml0ZSBpbWFnZSBhbmQgbWV0YWRhdGEuIFRoZSBleHRlbnNpb25zIGAucG5nYCwgYC5qc29uYCBhbmQgc2NhbGUgZmFjdG9yIGBAMngucG5nYCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgYXBwZW5kZWQuXCJcbiAgICB9LFxuICAgIFwiZ2x5cGhzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkb2NcIjogXCJBIFVSTCB0ZW1wbGF0ZSBmb3IgbG9hZGluZyBzaWduZWQtZGlzdGFuY2UtZmllbGQgZ2x5cGggc2V0cyBpbiBQQkYgZm9ybWF0LiBWYWxpZCB0b2tlbnMgYXJlIHtmb250c3RhY2t9IGFuZCB7cmFuZ2V9LlwiXG4gICAgfSxcbiAgICBcInRyYW5zaXRpb25cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwidHJhbnNpdGlvblwiLFxuICAgICAgXCJkb2NcIjogXCJBIGdsb2JhbCB0cmFuc2l0aW9uIGRlZmluaXRpb24gdG8gdXNlIGFzIGEgZGVmYXVsdCBhY3Jvc3MgcHJvcGVydGllcy5cIlxuICAgIH0sXG4gICAgXCJsYXllcnNcIjoge1xuICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwidmFsdWVcIjogXCJsYXllclwiLFxuICAgICAgXCJkb2NcIjogXCJMYXllcnMgd2lsbCBiZSBkcmF3biBpbiB0aGUgb3JkZXIgb2YgdGhpcyBhcnJheS5cIlxuICAgIH1cbiAgfSxcbiAgXCJjb25zdGFudHNcIjoge1xuICAgIFwiKlwiOiB7XG4gICAgICBcInR5cGVcIjogXCIqXCIsXG4gICAgICBcImRvY1wiOiBcIkEgY29uc3RhbnQgdGhhdCB3aWxsIGJlIHJlcGxhY2VkIHZlcmJhdGltIGluIHRoZSByZWZlcmVuY2luZyBwbGFjZS4gVGhpcyBjYW4gYmUgYW55dGhpbmcsIGluY2x1ZGluZyBvYmplY3RzIGFuZCBhcnJheXMuIEFsbCB2YXJpYWJsZSBuYW1lcyBtdXN0IGJlIHByZWZpeGVkIHdpdGggYW4gYEBgIHN5bWJvbC5cIlxuICAgIH1cbiAgfSxcbiAgXCJzb3VyY2VzXCI6IHtcbiAgICBcIipcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic291cmNlXCIsXG4gICAgICBcImRvY1wiOiBcIlNwZWNpZmljYXRpb24gb2YgYSBkYXRhIHNvdXJjZS4gRm9yIHZlY3RvciBhbmQgcmFzdGVyIHNvdXJjZXMsIGVpdGhlciBUaWxlSlNPTiBvciBhIFVSTCB0byBhIFRpbGVKU09OIG11c3QgYmUgcHJvdmlkZWQuIEZvciBHZW9KU09OIGFuZCB2aWRlbyBzb3VyY2VzLCBhIFVSTCBtdXN0IGJlIHByb3ZpZGVkLlwiXG4gICAgfVxuICB9LFxuICBcInNvdXJjZVwiOiBbXG4gICAgXCJzb3VyY2VfdGlsZVwiLFxuICAgIFwic291cmNlX2dlb2pzb25cIixcbiAgICBcInNvdXJjZV92aWRlb1wiXG4gIF0sXG4gIFwic291cmNlX3RpbGVcIjoge1xuICAgIFwidHlwZVwiOiB7XG4gICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwidmVjdG9yXCIsXG4gICAgICAgIFwicmFzdGVyXCJcbiAgICAgIF0sXG4gICAgICBcImRvY1wiOiBcIlRoZSBkYXRhIHR5cGUgb2YgdGhlIHNvdXJjZS5cIlxuICAgIH0sXG4gICAgXCJ1cmxcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImRvY1wiOiBcIkEgVVJMIHRvIGEgVGlsZUpTT04gcmVzb3VyY2UuIFN1cHBvcnRlZCBwcm90b2NvbHMgYXJlIGBodHRwOmAsIGBodHRwczpgLCBhbmQgYG1hcGJveDovLzxtYXBpZD5gLlwiXG4gICAgfSxcbiAgICBcInRpbGVzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcInZhbHVlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImRvY1wiOiBcIkFuIGFycmF5IG9mIG9uZSBvciBtb3JlIHRpbGUgc291cmNlIFVSTHMsIGFzIGluIHRoZSBUaWxlSlNPTiBzcGVjLlwiXG4gICAgfSxcbiAgICBcIm1pbnpvb21cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwiZG9jXCI6IFwiTWluaW11bSB6b29tIGxldmVsIGZvciB3aGljaCB0aWxlcyBhcmUgYXZhaWxhYmxlLCBhcyBpbiB0aGUgVGlsZUpTT04gc3BlYy5cIlxuICAgIH0sXG4gICAgXCJtYXh6b29tXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDIyLFxuICAgICAgXCJkb2NcIjogXCJNYXhpbXVtIHpvb20gbGV2ZWwgZm9yIHdoaWNoIHRpbGVzIGFyZSBhdmFpbGFibGUsIGFzIGluIHRoZSBUaWxlSlNPTiBzcGVjLiBEYXRhIGZyb20gdGlsZXMgYXQgdGhlIG1heHpvb20gYXJlIHVzZWQgd2hlbiBkaXNwbGF5aW5nIHRoZSBtYXAgYXQgaGlnaGVyIHpvb20gbGV2ZWxzLlwiXG4gICAgfSxcbiAgICBcInRpbGVTaXplXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDUxMixcbiAgICAgIFwidW5pdHNcIjogXCJwaXhlbHNcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIG1pbmltdW0gdmlzdWFsIHNpemUgdG8gZGlzcGxheSB0aWxlcyBmb3IgdGhpcyBsYXllci4gT25seSBjb25maWd1cmFibGUgZm9yIHJhc3RlciBsYXllcnMuXCJcbiAgICB9LFxuICAgIFwiKlwiOiB7XG4gICAgICBcInR5cGVcIjogXCIqXCIsXG4gICAgICBcImRvY1wiOiBcIk90aGVyIGtleXMgdG8gY29uZmlndXJlIHRoZSBkYXRhIHNvdXJjZS5cIlxuICAgIH1cbiAgfSxcbiAgXCJzb3VyY2VfZ2VvanNvblwiOiB7XG4gICAgXCJ0eXBlXCI6IHtcbiAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJnZW9qc29uXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwiZGF0YVwiOiB7XG4gICAgICBcInR5cGVcIjogXCIqXCJcbiAgICB9XG4gIH0sXG4gIFwic291cmNlX3ZpZGVvXCI6IHtcbiAgICBcInR5cGVcIjoge1xuICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcInZpZGVvXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidXJsXCI6IHtcbiAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcInZhbHVlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImRvY1wiOiBcIlVSTHMgdG8gdmlkZW8gY29udGVudCBpbiBvcmRlciBvZiBwcmVmZXJyZWQgZm9ybWF0LlwiXG4gICAgfSxcbiAgICBcImNvb3JkaW5hdGVzXCI6IHtcbiAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcImxlbmd0aFwiOiA0LFxuICAgICAgXCJ2YWx1ZVwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICAgIFwibGVuZ3RoXCI6IDIsXG4gICAgICAgIFwidmFsdWVcIjogXCJudW1iZXJcIlxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgXCJsYXllclwiOiB7XG4gICAgXCJpZFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZG9jXCI6IFwiVW5pcXVlIGxheWVyIG5hbWUuXCJcbiAgICB9LFxuICAgIFwidHlwZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwiZmlsbFwiLFxuICAgICAgICBcImxpbmVcIixcbiAgICAgICAgXCJzeW1ib2xcIixcbiAgICAgICAgXCJyYXN0ZXJcIixcbiAgICAgICAgXCJiYWNrZ3JvdW5kXCJcbiAgICAgIF0sXG4gICAgICBcImRvY1wiOiBcIlJlbmRlcmluZyB0eXBlIG9mIHRoaXMgbGF5ZXIuXCJcbiAgICB9LFxuICAgIFwicmVmXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkb2NcIjogXCJSZWZlcmVuY2VzIGFub3RoZXIgbGF5ZXIgdG8gY29weSBgdHlwZWAsIGBzb3VyY2VgLCBgc291cmNlLWxheWVyYCwgYG1pbnpvb21gLCBgbWF4em9vbWAsIGBmaWx0ZXJgLCBhbmQgYGxheW91dGAgcHJvcGVydGllcyBmcm9tLiBUaGlzIGFsbG93cyB0aGUgbGF5ZXJzIHRvIHNoYXJlIHByb2Nlc3NpbmcgYW5kIGJlIG1vcmUgZWZmaWNpZW50LlwiXG4gICAgfSxcbiAgICBcInNvdXJjZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZG9jXCI6IFwiTmFtZSBvZiBhIHNvdXJjZSBkZXNjcmlwdGlvbiB0byBiZSB1c2VkIGZvciB0aGlzIGxheWVyLlwiXG4gICAgfSxcbiAgICBcInNvdXJjZS1sYXllclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZG9jXCI6IFwiTGF5ZXIgdG8gdXNlIGZyb20gYSB2ZWN0b3IgdGlsZSBzb3VyY2UuIFJlcXVpcmVkIGlmIHRoZSBzb3VyY2Ugc3VwcG9ydHMgbXVsdGlwbGUgbGF5ZXJzLlwiXG4gICAgfSxcbiAgICBcIm1pbnpvb21cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwibWF4aW11bVwiOiAyMixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIG1pbmltdW0gem9vbSBsZXZlbCBvbiB3aGljaCB0aGUgbGF5ZXIgZ2V0cyBwYXJzZWQgYW5kIGFwcGVhcnMgb24uXCJcbiAgICB9LFxuICAgIFwibWF4em9vbVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJtYXhpbXVtXCI6IDIyLFxuICAgICAgXCJkb2NcIjogXCJUaGUgbWF4aW11bSB6b29tIGxldmVsIG9uIHdoaWNoIHRoZSBsYXllciBnZXRzIHBhcnNlZCBhbmQgYXBwZWFycyBvbi5cIlxuICAgIH0sXG4gICAgXCJpbnRlcmFjdGl2ZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImRvY1wiOiBcIkVuYWJsZSBxdWVyeWluZyBvZiBmZWF0dXJlIGRhdGEgZnJvbSB0aGlzIGxheWVyIGZvciBpbnRlcmFjdGl2aXR5LlwiLFxuICAgICAgXCJkZWZhdWx0XCI6IGZhbHNlXG4gICAgfSxcbiAgICBcImZpbHRlclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJmaWx0ZXJcIixcbiAgICAgIFwiZG9jXCI6IFwiQSBleHByZXNzaW9uIHNwZWNpZnlpbmcgY29uZGl0aW9ucyBvbiBzb3VyY2UgZmVhdHVyZXMuIE9ubHkgZmVhdHVyZXMgdGhhdCBtYXRjaCB0aGUgZmlsdGVyIGFyZSBkaXNwbGF5ZWQuXCJcbiAgICB9LFxuICAgIFwibGF5b3V0XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImxheW91dFwiLFxuICAgICAgXCJkb2NcIjogXCJMYXlvdXQgcHJvcGVydGllcyBmb3IgdGhlIGxheWVyLlwiXG4gICAgfSxcbiAgICBcInBhaW50XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInBhaW50XCIsXG4gICAgICBcImRvY1wiOiBcIkRlZmF1bHQgcGFpbnQgcHJvcGVydGllcyBmb3IgdGhpcyBsYXllci5cIlxuICAgIH0sXG4gICAgXCJwYWludC4qXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInBhaW50XCIsXG4gICAgICBcImRvY1wiOiBcIkNsYXNzLXNwZWNpZmljIHBhaW50IHByb3BlcnRpZXMgZm9yIHRoaXMgbGF5ZXIuIFRoZSBjbGFzcyBuYW1lIGlzIHRoZSBwYXJ0IGFmdGVyIHRoZSBmaXJzdCBkb3QuXCJcbiAgICB9XG4gIH0sXG4gIFwibGF5b3V0XCI6IFtcbiAgICBcImxheW91dF9maWxsXCIsXG4gICAgXCJsYXlvdXRfbGluZVwiLFxuICAgIFwibGF5b3V0X3N5bWJvbFwiLFxuICAgIFwibGF5b3V0X3Jhc3RlclwiLFxuICAgIFwibGF5b3V0X2JhY2tncm91bmRcIlxuICBdLFxuICBcImxheW91dF9iYWNrZ3JvdW5kXCI6IHtcbiAgICBcInZpc2liaWxpdHlcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcInZpc2libGVcIixcbiAgICAgICAgXCJub25lXCJcbiAgICAgIF0sXG4gICAgICBcImRlZmF1bHRcIjogXCJ2aXNpYmxlXCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBkaXNwbGF5IG9mIHRoaXMgbGF5ZXIuIGBub25lYCBoaWRlcyB0aGlzIGxheWVyLlwiXG4gICAgfVxuICB9LFxuICBcImxheW91dF9maWxsXCI6IHtcbiAgICBcInZpc2liaWxpdHlcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcInZpc2libGVcIixcbiAgICAgICAgXCJub25lXCJcbiAgICAgIF0sXG4gICAgICBcImRlZmF1bHRcIjogXCJ2aXNpYmxlXCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBkaXNwbGF5IG9mIHRoaXMgbGF5ZXIuIGBub25lYCBoaWRlcyB0aGlzIGxheWVyLlwiXG4gICAgfVxuICB9LFxuICBcImxheW91dF9saW5lXCI6IHtcbiAgICBcImxpbmUtY2FwXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJidXR0XCIsXG4gICAgICAgIFwicm91bmRcIixcbiAgICAgICAgXCJzcXVhcmVcIlxuICAgICAgXSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcImJ1dHRcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGRpc3BsYXkgb2YgbGluZSBlbmRpbmdzLlwiXG4gICAgfSxcbiAgICBcImxpbmUtam9pblwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwiYmV2ZWxcIixcbiAgICAgICAgXCJyb3VuZFwiLFxuICAgICAgICBcIm1pdGVyXCJcbiAgICAgIF0sXG4gICAgICBcImRlZmF1bHRcIjogXCJtaXRlclwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgZGlzcGxheSBvZiBsaW5lcyB3aGVuIGpvaW5pbmcuXCJcbiAgICB9LFxuICAgIFwibGluZS1taXRlci1saW1pdFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAyLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJkb2NcIjogXCJVc2VkIHRvIGF1dG9tYXRpY2FsbHkgY29udmVydCBtaXRlciBqb2lucyB0byBiZXZlbCBqb2lucyBmb3Igc2hhcnAgYW5nbGVzLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBcImxpbmUtam9pblwiOiBcIm1pdGVyXCJcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG4gICAgXCJsaW5lLXJvdW5kLWxpbWl0XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcImRvY1wiOiBcIlVzZWQgdG8gYXV0b21hdGljYWxseSBjb252ZXJ0IHJvdW5kIGpvaW5zIHRvIG1pdGVyIGpvaW5zIGZvciBzaGFsbG93IGFuZ2xlcy5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICB7XG4gICAgICAgICAgXCJsaW5lLWpvaW5cIjogXCJyb3VuZFwiXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9LFxuICAgIFwidmlzaWJpbGl0eVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwidmlzaWJsZVwiLFxuICAgICAgICBcIm5vbmVcIlxuICAgICAgXSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcInZpc2libGVcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGRpc3BsYXkgb2YgdGhpcyBsYXllci4gYG5vbmVgIGhpZGVzIHRoaXMgbGF5ZXIuXCJcbiAgICB9XG4gIH0sXG4gIFwibGF5b3V0X3N5bWJvbFwiOiB7XG4gICAgXCJzeW1ib2wtcGxhY2VtZW50XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgICBcInBvaW50XCIsXG4gICAgICAgICAgXCJsaW5lXCJcbiAgICAgIF0sXG4gICAgICBcImRlZmF1bHRcIjogXCJwb2ludFwiLFxuICAgICAgXCJkb2NcIjogXCJMYWJlbCBwbGFjZW1lbnQgcmVsYXRpdmUgdG8gaXRzIGdlb21ldHJ5LiBgbGluZWAgY2FuIG9ubHkgYmUgdXNlZCBvbiBMaW5lU3RyaW5ncyBhbmQgUG9seWdvbnMuXCJcbiAgICB9LFxuICAgIFwic3ltYm9sLW1pbi1kaXN0YW5jZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAyNTAsXG4gICAgICBcIm1pbmltdW1cIjogMSxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidW5pdHNcIjogXCJwaXhlbHNcIixcbiAgICAgIFwiZG9jXCI6IFwiTWluaW11bSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBzeW1ib2wgYW5jaG9ycy5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICB7XG4gICAgICAgICAgXCJzeW1ib2wtcGxhY2VtZW50XCI6IFwibGluZVwiXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9LFxuICAgIFwic3ltYm9sLWF2b2lkLWVkZ2VzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZSxcbiAgICAgIFwiZG9jXCI6IFwiSWYgdHJ1ZSwgdGhlIHN5bWJvbHMgd2lsbCBub3QgY3Jvc3MgdGlsZSBlZGdlcyB0byBhdm9pZCBtdXR1YWwgY29sbGlzaW9ucy4gUmVjb21tZW5kZWQgaW4gbGF5ZXJzIHRoYXQgZG9uJ3QgaGF2ZSBlbm91Z2ggcGFkZGluZyBpbiB0aGUgdmVjdG9yIHRpbGUgdG8gcHJldmVudCBjb2xsaXNpb25zLCBvciBpZiBpdCBpcyBhIHBvaW50IHN5bWJvbCBsYXllciBwbGFjZWQgYWZ0ZXIgYSBsaW5lIHN5bWJvbCBsYXllci5cIlxuICAgIH0sXG4gICAgXCJpY29uLWFsbG93LW92ZXJsYXBcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJkZWZhdWx0XCI6IGZhbHNlLFxuICAgICAgXCJkb2NcIjogXCJJZiB0cnVlLCB0aGUgaWNvbiB3aWxsIGJlIHZpc2libGUgZXZlbiBpZiBpdCBjb2xsaWRlcyB3aXRoIG90aGVyIGljb25zIGFuZCB0ZXh0LlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcImljb24taWdub3JlLXBsYWNlbWVudFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcImRlZmF1bHRcIjogZmFsc2UsXG4gICAgICBcImRvY1wiOiBcIklmIHRydWUsIHRoZSBpY29uIHdvbid0IGFmZmVjdCBwbGFjZW1lbnQgb2Ygb3RoZXIgaWNvbnMgYW5kIHRleHQuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJpY29uLWltYWdlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwiaWNvbi1vcHRpb25hbFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcImRlZmF1bHRcIjogZmFsc2UsXG4gICAgICBcImRvY1wiOiBcIklmIHRydWUsIHRoZSBzeW1ib2wgd2lsbCBhcHBlYXIgd2l0aG91dCBpdHMgaWNvbiwgaW4gc3BhY2VzIHdoZXJlIHRoZSBpY29uIHdvdWxkIG1ha2UgaXQgdG9vIGxhcmdlIHRvIGZpdC5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImljb24taW1hZ2VcIixcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwiaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcIm1hcFwiLFxuICAgICAgICBcInZpZXdwb3J0XCJcbiAgICAgIF0sXG4gICAgICBcImRlZmF1bHRcIjogXCJ2aWV3cG9ydFwiLFxuICAgICAgXCJkb2NcIjogXCJPcmllbnRhdGlvbiBvZiBpY29uIHdoZW4gbWFwIGlzIHJvdGF0ZWQuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJpY29uLWltYWdlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwiaWNvbi1tYXgtc2l6ZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAxLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBtYXhpbXVtIGZhY3RvciB0byBzY2FsZSB0aGUgaWNvbi5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImljb24taW1hZ2VcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJpY29uLWltYWdlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJkb2NcIjogXCJBIHN0cmluZyB3aXRoIHt0b2tlbnN9IHJlcGxhY2VkLCByZWZlcmVuY2luZyB0aGUgZGF0YSBwcm9wZXJ0eSB0byBwdWxsIGZyb20uXCIsXG4gICAgICBcInRva2Vuc1wiOiB0cnVlXG4gICAgfSxcbiAgICBcImljb24tcm90YXRlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcInBlcmlvZFwiOiAzNjAsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInVuaXRzXCI6IFwiZGVncmVlc1wiLFxuICAgICAgXCJkb2NcIjogXCJSb3RhdGVzIHRoZSBpY29uIGNsb2Nrd2lzZS5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImljb24taW1hZ2VcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJpY29uLXBhZGRpbmdcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMixcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJQYWRkaW5nIHZhbHVlIGFyb3VuZCBpY29uIGJvdW5kaW5nIGJveCB0byBhdm9pZCBpY29uIGNvbGxpc2lvbnMuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJpY29uLWltYWdlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwiaWNvbi1rZWVwLXVwcmlnaHRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJkZWZhdWx0XCI6IGZhbHNlLFxuICAgICAgXCJkb2NcIjogXCJJZiB0cnVlLCB0aGUgaWNvbiBtYXkgYmUgZmxpcHBlZCB0byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgcmVuZGVyZWQgdXBzaWRlLWRvd25cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImljb24taW1hZ2VcIixcbiAgICAgICAge1xuICAgICAgICAgIFwiaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnRcIjogXCJtYXBcIlxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSxcbiAgICBcImljb24tb2Zmc2V0XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcInZhbHVlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImxlbmd0aFwiOiAyLFxuICAgICAgXCJkZWZhdWx0XCI6IFtcbiAgICAgICAgMCxcbiAgICAgICAgMFxuICAgICAgXSxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiZG9jXCI6IFwiSWNvbidzIG9mZnNldCBkaXN0YW5jZS4gVmFsdWVzIGFyZSBbeCwgeV0gd2hlcmUgbmVnYXRpdmVzIGluZGljYXRlIGxlZnQgYW5kIHVwLCByZXNwZWN0aXZlbHkuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJpY29uLWltYWdlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1yb3RhdGlvbi1hbGlnbm1lbnRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcIm1hcFwiLFxuICAgICAgICBcInZpZXdwb3J0XCJcbiAgICAgIF0sXG4gICAgICBcImRlZmF1bHRcIjogXCJ2aWV3cG9ydFwiLFxuICAgICAgXCJkb2NcIjogXCJPcmllbnRhdGlvbiBvZiBpY29uIG9yIHRleHQgd2hlbiBtYXAgaXMgcm90YXRlZC5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LWZpZWxkXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJkZWZhdWx0XCI6IFwiXCIsXG4gICAgICBcInRva2Vuc1wiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJWYWx1ZSB0byB1c2UgZm9yIGEgdGV4dCBsYWJlbC4gRmVhdHVyZSBwcm9wZXJ0aWVzIGFyZSBzcGVjaWZpZWQgdXNpbmcgdG9rZW5zIGxpa2Uge2ZpZWxkX25hbWV9LlwiXG4gICAgfSxcbiAgICBcInRleHQtZm9udFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIk9wZW4gU2FucyBSZWd1bGFyLCBBcmlhbCBVbmljb2RlIE1TIFJlZ3VsYXJcIixcbiAgICAgIFwiZG9jXCI6IFwiRm9udCBzdGFjayB0byB1c2UgZm9yIGRpc3BsYXlpbmcgdGV4dC5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LW1heC1zaXplXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDE2LFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBtYXhpbXVtIHNpemUgdGV4dCB3aWxsIGJlIGxhaWQgb3V0LCB0byBjYWxjdWxhdGUgY29sbGlzaW9ucyB3aXRoLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtbWF4LXdpZHRoXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDE1LFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcInVuaXRzXCI6IFwiZW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIG1heGltdW0gbGluZSB3aWR0aCBmb3IgdGV4dCB3cmFwcGluZy5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LWxpbmUtaGVpZ2h0XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEuMixcbiAgICAgIFwidW5pdHNcIjogXCJlbVwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJkb2NcIjogXCJUZXh0IGxlYWRpbmcgdmFsdWUgZm9yIG11bHRpLWxpbmUgdGV4dC5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LWxldHRlci1zcGFjaW5nXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcInVuaXRzXCI6IFwiZW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiZG9jXCI6IFwiVGV4dCBrZXJuaW5nIHZhbHVlLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtanVzdGlmeVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwibGVmdFwiLFxuICAgICAgICBcImNlbnRlclwiLFxuICAgICAgICBcInJpZ2h0XCJcbiAgICAgIF0sXG4gICAgICBcImRlZmF1bHRcIjogXCJjZW50ZXJcIixcbiAgICAgIFwiZG9jXCI6IFwiVGV4dCBqdXN0aWZpY2F0aW9uIG9wdGlvbnMuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1hbmNob3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcImNlbnRlclwiLFxuICAgICAgICBcImxlZnRcIixcbiAgICAgICAgXCJyaWdodFwiLFxuICAgICAgICBcInRvcFwiLFxuICAgICAgICBcImJvdHRvbVwiLFxuICAgICAgICBcInRvcC1sZWZ0XCIsXG4gICAgICAgIFwidG9wLXJpZ2h0XCIsXG4gICAgICAgIFwiYm90dG9tLWxlZnRcIixcbiAgICAgICAgXCJib3R0b20tcmlnaHRcIlxuICAgICAgXSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcImNlbnRlclwiLFxuICAgICAgXCJkb2NcIjogXCJXaGljaCBwYXJ0IG9mIHRoZSB0ZXh0IHRvIHBsYWNlIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LW1heC1hbmdsZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiA0NSxcbiAgICAgIFwidW5pdHNcIjogXCJkZWdyZWVzXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcImRvY1wiOiBcIk1heGltdW0gYW5nbGUgY2hhbmdlIGJldHdlZW4gYWRqYWNlbnQgY2hhcmFjdGVycy5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIixcbiAgICAgICAge1xuICAgICAgICAgIFwic3ltYm9sLXBsYWNlbWVudFwiOiBcImxpbmVcIlxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtcm90YXRlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcInBlcmlvZFwiOiAzNjAsXG4gICAgICBcInVuaXRzXCI6IFwiZGVncmVlc1wiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJkb2NcIjogXCJSb3RhdGVzIHRoZSB0ZXh0IGNsb2Nrd2lzZS5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LXBhZGRpbmdcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMixcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJkb2NcIjogXCJQYWRkaW5nIHZhbHVlIGFyb3VuZCB0ZXh0IGJvdW5kaW5nIGJveCB0byBhdm9pZCBsYWJlbCBjb2xsaXNpb25zLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQta2VlcC11cHJpZ2h0XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwiZGVmYXVsdFwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJJZiB0cnVlLCB0aGUgdGV4dCBtYXkgYmUgZmxpcHBlZCB2ZXJ0aWNhbGx5IHRvIHByZXZlbnQgaXQgZnJvbSBiZWluZyByZW5kZXJlZCB1cHNpZGUtZG93bi5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIixcbiAgICAgICAge1xuICAgICAgICAgIFwidGV4dC1yb3RhdGlvbi1hbGlnbm1lbnRcIjogXCJtYXBcIlxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtdHJhbnNmb3JtXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJub25lXCIsXG4gICAgICAgIFwidXBwZXJjYXNlXCIsXG4gICAgICAgIFwibG93ZXJjYXNlXCJcbiAgICAgIF0sXG4gICAgICBcImRlZmF1bHRcIjogXCJub25lXCIsXG4gICAgICBcImRvY1wiOiBcIlNwZWNpZmllcyBob3cgdG8gY2FwaXRhbGl6ZSB0ZXh0LCBzaW1pbGFyIHRvIHRoZSBDU1MgYHRleHQtdHJhbnNmb3JtYCBwcm9wZXJ0eS5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LW9mZnNldFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJkb2NcIjogXCJTcGVjaWZpZXMgdGhlIGRpc3RhbmNlIHRoYXQgdGV4dCBpcyBvZmZzZXQgZnJvbSBpdHMgYW5jaG9yIGhvcml6b250YWxseSBhbmQgdmVydGljYWxseS5cIixcbiAgICAgIFwidmFsdWVcIjogXCJudW1iZXJcIixcbiAgICAgIFwidW5pdHNcIjogXCJlbXNcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwibGVuZ3RoXCI6IDIsXG4gICAgICBcImRlZmF1bHRcIjogW1xuICAgICAgICAwLFxuICAgICAgICAwXG4gICAgICBdLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtYWxsb3ctb3ZlcmxhcFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcImRlZmF1bHRcIjogZmFsc2UsXG4gICAgICBcImRvY1wiOiBcIklmIHRydWUsIHRoZSB0ZXh0IHdpbGwgYmUgdmlzaWJsZSBldmVuIGlmIGl0IGNvbGxpZGVzIHdpdGggb3RoZXIgaWNvbnMgYW5kIGxhYmVscy5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LWlnbm9yZS1wbGFjZW1lbnRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJkZWZhdWx0XCI6IGZhbHNlLFxuICAgICAgXCJkb2NcIjogXCJJZiB0cnVlLCB0aGUgdGV4dCB3b24ndCBhZmZlY3QgcGxhY2VtZW50IG9mIG90aGVyIGljb25zIGFuZCBsYWJlbHMuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1vcHRpb25hbFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcImRlZmF1bHRcIjogZmFsc2UsXG4gICAgICBcImRvY1wiOiBcIklmIHRydWUsIHRoZSBzeW1ib2wgd2lsbCBhcHBlYXIgd2l0aG91dCBpdHMgdGV4dCwgaW4gc3BhY2VzIHdoZXJlIHRoZSB0ZXh0IHdvdWxkIG1ha2UgaXQgdG9vIGxhcmdlIHRvIGZpdC5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIixcbiAgICAgICAgXCJpY29uLWltYWdlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidmlzaWJpbGl0eVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwidmlzaWJsZVwiLFxuICAgICAgICBcIm5vbmVcIlxuICAgICAgXSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcInZpc2libGVcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGRpc3BsYXkgb2YgdGhpcyBsYXllci4gYG5vbmVgIGhpZGVzIHRoaXMgbGF5ZXIuXCJcbiAgICB9XG4gIH0sXG4gIFwibGF5b3V0X3Jhc3RlclwiOiB7XG4gICAgXCJ2aXNpYmlsaXR5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJ2aXNpYmxlXCIsXG4gICAgICAgIFwibm9uZVwiXG4gICAgICBdLFxuICAgICAgXCJkZWZhdWx0XCI6IFwidmlzaWJsZVwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgZGlzcGxheSBvZiB0aGlzIGxheWVyLiBgbm9uZWAgaGlkZXMgdGhpcyBsYXllci5cIlxuICAgIH1cbiAgfSxcbiAgXCJmaWx0ZXJcIjoge1xuICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgXCJ2YWx1ZVwiOiBcIipcIlxuICB9LFxuICBcImZpbHRlcl9vcGVyYXRvclwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgIFwidmFsdWVzXCI6IFtcbiAgICAgIFwiPT1cIixcbiAgICAgIFwiIT1cIixcbiAgICAgIFwiPlwiLFxuICAgICAgXCI+PVwiLFxuICAgICAgXCI8XCIsXG4gICAgICBcIjw9XCIsXG4gICAgICBcImluXCIsXG4gICAgICBcIiFpblwiLFxuICAgICAgXCJhbGxcIixcbiAgICAgIFwiYW55XCIsXG4gICAgICBcIm5vbmVcIlxuICAgIF1cbiAgfSxcbiAgXCJnZW9tZXRyeV90eXBlXCI6IHtcbiAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgXCJQb2ludFwiLFxuICAgICAgXCJMaW5lU3RyaW5nXCIsXG4gICAgICBcIlBvbHlnb25cIlxuICAgIF1cbiAgfSxcbiAgXCJmdW5jdGlvblwiOiB7XG4gICAgXCJzdG9wc1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJBbiBhcnJheSBvZiBzdG9wcy5cIixcbiAgICAgIFwidmFsdWVcIjogXCJmdW5jdGlvbl9zdG9wXCJcbiAgICB9LFxuICAgIFwiYmFzZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAxLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcImRvY1wiOiBcIlRoZSBleHBvbmVudGlhbCBiYXNlIG9mIHRoZSBpbnRlcnBvbGF0aW9uIGN1cnZlLiBJdCBjb250cm9scyB0aGUgcmF0ZSBhdCB3aGljaCB0aGUgcmVzdWx0IGluY3JlYXNlcy4gSGlnaGVyIHZhbHVlcyBtYWtlIHRoZSByZXN1bHQgaW5jcmVhc2UgbW9yZSB0b3dhcmRzIHRoZSBoaWdoIGVuZCBvZiB0aGUgcmFuZ2UuIFdpdGggYDFgIHRoZSBzdG9wcyBhcmUgaW50ZXJwb2xhdGVkIGxpbmVhcmx5LlwiXG4gICAgfVxuICB9LFxuICBcImZ1bmN0aW9uX3N0b3BcIjoge1xuICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgXCJtYXhpbXVtXCI6IDIyLFxuICAgIFwidmFsdWVcIjogW1xuICAgICAgXCJudW1iZXJcIixcbiAgICAgIFwiY29sb3JcIlxuICAgIF0sXG4gICAgXCJsZW5ndGhcIjogMixcbiAgICBcImRvY1wiOiBcIlpvb20gbGV2ZWwgYW5kIHZhbHVlIHBhaXIuXCJcbiAgfSxcbiAgXCJwYWludFwiOiBbXG4gICAgXCJwYWludF9maWxsXCIsXG4gICAgXCJwYWludF9saW5lXCIsXG4gICAgXCJwYWludF9zeW1ib2xcIixcbiAgICBcInBhaW50X3Jhc3RlclwiLFxuICAgIFwicGFpbnRfYmFja2dyb3VuZFwiXG4gIF0sXG4gIFwicGFpbnRfZmlsbFwiOiB7XG4gICAgXCJmaWxsLWFudGlhbGlhc1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcImRlZmF1bHRcIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiV2hldGhlciBvciBub3QgdGhlIGZpbGwgc2hvdWxkIGJlIGFudGlhbGlhc2VkLlwiXG4gICAgfSxcbiAgICBcImZpbGwtb3BhY2l0eVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAxLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcIm1heGltdW1cIjogMSxcbiAgICAgIFwiZG9jXCI6IFwiVGhlIG9wYWNpdHkgZ2l2ZW4gdG8gdGhlIGZpbGwgY29sb3IuXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJmaWxsLWNvbG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXG4gICAgICBcImRlZmF1bHRcIjogXCIjMDAwMDAwXCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBjb2xvciBvZiB0aGUgZmlsbC5cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBcIiFcIjogXCJmaWxsLWltYWdlXCJcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG4gICAgXCJmaWxsLW91dGxpbmUtY29sb3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIG91dGxpbmUgY29sb3Igb2YgdGhlIGZpbGwuIE1hdGNoZXMgdGhlIHZhbHVlIG9mIGBmaWxsLWNvbG9yYCBpZiB1bnNwZWNpZmllZC5cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBcIiFcIjogXCJmaWxsLWltYWdlXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIFwiZmlsbC1hbnRpYWxpYXNcIjogdHJ1ZVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSxcbiAgICBcImZpbGwtdHJhbnNsYXRlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcInZhbHVlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImxlbmd0aFwiOiAyLFxuICAgICAgXCJkZWZhdWx0XCI6IFtcbiAgICAgICAgMCxcbiAgICAgICAgMFxuICAgICAgXSxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgZ2VvbWV0cnkncyBvZmZzZXQuIFZhbHVlcyBhcmUgW3gsIHldIHdoZXJlIG5lZ2F0aXZlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cCwgcmVzcGVjdGl2ZWx5LlwiXG4gICAgfSxcbiAgICBcImZpbGwtdHJhbnNsYXRlLWFuY2hvclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwibWFwXCIsXG4gICAgICAgIFwidmlld3BvcnRcIlxuICAgICAgXSxcbiAgICAgIFwiZG9jXCI6IFwiQ29udHJvbCB3aGV0aGVyIHRoZSB0cmFuc2xhdGlvbiBpcyByZWxhdGl2ZSB0byB0aGUgbWFwIChub3J0aCkgb3Igdmlld3BvcnQgKHNjcmVlbilcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIm1hcFwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiZmlsbC10cmFuc2xhdGVcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJmaWxsLWltYWdlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcImRvY1wiOiBcIk5hbWUgb2YgaW1hZ2UgaW4gc3ByaXRlIHRvIHVzZSBmb3IgZHJhd2luZyBpbWFnZSBmaWxscy5cIlxuICAgIH1cbiAgfSxcbiAgXCJwYWludF9saW5lXCI6IHtcbiAgICBcImxpbmUtb3BhY2l0eVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIG9wYWNpdHkgYXQgd2hpY2ggdGhlIGxpbmUgd2lsbCBiZSBkcmF3bi5cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAxLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcIm1heGltdW1cIjogMSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlXG4gICAgfSxcbiAgICBcImxpbmUtY29sb3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGNvbG9yIHdpdGggd2hpY2ggdGhlIGxpbmUgd2lsbCBiZSBkcmF3bi5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBcIiFcIjogXCJsaW5lLWltYWdlXCJcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG4gICAgXCJsaW5lLXRyYW5zbGF0ZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJ2YWx1ZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJsZW5ndGhcIjogMixcbiAgICAgIFwiZGVmYXVsdFwiOiBbXG4gICAgICAgIDAsXG4gICAgICAgIDBcbiAgICAgIF0sXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwidW5pdHNcIjogXCJwaXhlbHNcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGdlb21ldHJ5J3Mgb2Zmc2V0LiBWYWx1ZXMgYXJlIFt4LCB5XSB3aGVyZSBuZWdhdGl2ZXMgaW5kaWNhdGUgbGVmdCBhbmQgdXAsIHJlc3BlY3RpdmVseS5cIlxuICAgIH0sXG4gICAgXCJsaW5lLXRyYW5zbGF0ZS1hbmNob3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcIm1hcFwiLFxuICAgICAgICBcInZpZXdwb3J0XCJcbiAgICAgIF0sXG4gICAgICBcImRvY1wiOiBcIkNvbnRyb2wgd2hldGhlciB0aGUgdHJhbnNsYXRpb24gaXMgcmVsYXRpdmUgdG8gdGhlIG1hcCAobm9ydGgpIG9yIHZpZXdwb3J0IChzY3JlZW4pXCIsXG4gICAgICBcImRlZmF1bHRcIjogXCJtYXBcIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImxpbmUtdHJhbnNsYXRlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwibGluZS13aWR0aFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAxLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwidW5pdHNcIjogXCJwaXhlbHNcIixcbiAgICAgIFwiZG9jXCI6IFwiU3Ryb2tlIHRoaWNrbmVzcy5cIlxuICAgIH0sXG4gICAgXCJsaW5lLWdhcC13aWR0aFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcImRvY1wiOiBcIkRyYXdzIGEgbGluZSBjYXNpbmcgb3V0c2lkZSBvZiBhIGxpbmUncyBhY3R1YWwgcGF0aC4gVmFsdWUgaW5kaWNhdGVzIHRoZSB3aWR0aCBvZiB0aGUgaW5uZXIgZ2FwLlwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCJcbiAgICB9LFxuICAgIFwibGluZS1ibHVyXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJCbHVyIGFwcGxpZWQgdG8gdGhlIGxpbmUsIGluIHBpeGVscy5cIlxuICAgIH0sXG4gICAgXCJsaW5lLWRhc2hhcnJheVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ2YWx1ZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkb2NcIjogXCJTcGVjaWZpZXMgdGhlIGxlbmd0aHMgb2YgdGhlIGFsdGVybmF0aW5nIGRhc2hlcyBhbmQgZ2FwcyB0aGF0IGZvcm0gdGhlIGRhc2ggcGF0dGVybi4gVGhlIGxlbmd0aHMgYXJlIGxhdGVyIHNjYWxlZCBieSB0aGUgbGluZSB3aWR0aC4gVG8gY29udmVydCBhIGRhc2ggbGVuZ3RoIHRvIHBpeGVscywgbXVsdGlwbHkgdGhlIGxlbmd0aCBieSB0aGUgY3VycmVudCBsaW5lIHdpZHRoLlwiLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwidW5pdHNcIjogXCJsaW5lIHdpZHRoc1wiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBcIiFcIjogXCJsaW5lLWltYWdlXCJcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG4gICAgXCJsaW5lLWltYWdlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcImRvY1wiOiBcIk5hbWUgb2YgaW1hZ2UgaW4gc3ByaXRlIHRvIHVzZSBmb3IgZHJhd2luZyBpbWFnZSBsaW5lcy5cIlxuICAgIH1cbiAgfSxcbiAgXCJwYWludF9zeW1ib2xcIjoge1xuICAgIFwiaWNvbi1vcGFjaXR5XCI6IHtcbiAgICAgIFwiZG9jXCI6IFwiVGhlIG9wYWNpdHkgYXQgd2hpY2ggdGhlIGljb24gd2lsbCBiZSBkcmF3bi5cIixcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwibWF4aW11bVwiOiAxLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJpY29uLWltYWdlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwiaWNvbi1zaXplXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiU2NhbGUgZmFjdG9yIGZvciBpY29uLiAxIGlzIG9yaWdpbmFsIHNpemUsIDMgdHJpcGxlcyB0aGUgc2l6ZS5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImljb24taW1hZ2VcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJpY29uLWNvbG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXG4gICAgICBcImRlZmF1bHRcIjogXCIjMDAwMDAwXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGNvbG9yIG9mIHRoZSBpY29uLiBUaGlzIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBzZGYgaWNvbnMuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJpY29uLWltYWdlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwiaWNvbi1oYWxvLWNvbG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXG4gICAgICBcImRlZmF1bHRcIjogXCJyZ2JhKDAsIDAsIDAsIDApXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGNvbG9yIG9mIHRoZSBpY29uJ3MgaGFsby4gSWNvbiBoYWxvcyBjYW4gb25seSBiZSB1c2VkIHdpdGggc2RmIGljb25zLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcImljb24taGFsby13aWR0aFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwidW5pdHNcIjogXCJwaXhlbHNcIixcbiAgICAgIFwiZG9jXCI6IFwiRGlzdGFuY2Ugb2YgaGFsbyB0byB0aGUgaWNvbiBvdXRsaW5lLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcImljb24taGFsby1ibHVyXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJGYWRlIG91dCB0aGUgaGFsbyB0b3dhcmRzIHRoZSBvdXRzaWRlLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcImljb24tdHJhbnNsYXRlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcInZhbHVlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImxlbmd0aFwiOiAyLFxuICAgICAgXCJkZWZhdWx0XCI6IFtcbiAgICAgICAgMCxcbiAgICAgICAgMFxuICAgICAgXSxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJBbiBpY29uJ3Mgb2Zmc2V0IGRpc3RhbmNlLiBWYWx1ZXMgYXJlIFt4LCB5XSB3aGVyZSBuZWdhdGl2ZXMgaW5kaWNhdGUgbGVmdCBhbmQgdXAsIHJlc3BlY3RpdmVseS5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImljb24taW1hZ2VcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJpY29uLXRyYW5zbGF0ZS1hbmNob3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcIm1hcFwiLFxuICAgICAgICBcInZpZXdwb3J0XCJcbiAgICAgIF0sXG4gICAgICBcImRvY1wiOiBcIkNvbnRyb2wgd2hldGhlciB0aGUgdHJhbnNsYXRpb24gaXMgcmVsYXRpdmUgdG8gdGhlIG1hcCAobm9ydGgpIG9yIHZpZXdwb3J0IChzY3JlZW4pXCIsXG4gICAgICBcImRlZmF1bHRcIjogXCJtYXBcIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImljb24taW1hZ2VcIixcbiAgICAgICAgXCJpY29uLXRyYW5zbGF0ZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtb3BhY2l0eVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIG9wYWNpdHkgYXQgd2hpY2ggdGhlIHRleHQgd2lsbCBiZSBkcmF3bi5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiAxLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcIm1heGltdW1cIjogMSxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtc2l6ZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAxNixcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCIsXG4gICAgICBcImRvY1wiOiBcIkZvbnQgc2l6ZS4gSWYgdW5zcGVjaWZpZWQsIHRoZSB0ZXh0IHdpbGwgYmUgYXMgYmlnIGFzIGFsbG93ZWQgYnkgdGhlIGxheWVyIGRlZmluaXRpb24uXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1jb2xvclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJjb2xvclwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgY29sb3Igd2l0aCB3aGljaCB0aGUgdGV4dCB3aWxsIGJlIGRyYXduLlwiLFxuICAgICAgXCJkZWZhdWx0XCI6IFwiIzAwMDAwMFwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1oYWxvLWNvbG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXG4gICAgICBcImRlZmF1bHRcIjogXCJyZ2JhKDAsIDAsIDAsIDApXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGNvbG9yIG9mIHRoZSB0ZXh0J3MgaGFsbywgd2hpY2ggaGVscHMgaXQgc3RhbmQgb3V0IGZyb20gYmFja2dyb3VuZHMuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1oYWxvLXdpZHRoXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJEaXN0YW5jZSBvZiBoYWxvIHRvIHRoZSBmb250IG91dGxpbmUuIE1heCB0ZXh0IGhhbG8gd2lkdGggaXMgMS80IG9mIHRoZSBmb250LXNpemUuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1oYWxvLWJsdXJcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBoYWxvJ3MgZmFkZW91dCBkaXN0YW5jZSB0b3dhcmRzIHRoZSBvdXRzaWRlLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtdHJhbnNsYXRlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcInZhbHVlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImxlbmd0aFwiOiAyLFxuICAgICAgXCJkZWZhdWx0XCI6IFtcbiAgICAgICAgMCxcbiAgICAgICAgMFxuICAgICAgXSxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJMYWJlbCBvZmZzZXQuIFZhbHVlcyBhcmUgW3gsIHldIHdoZXJlIG5lZ2F0aXZlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cCwgcmVzcGVjdGl2ZWx5LlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtdHJhbnNsYXRlLWFuY2hvclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwibWFwXCIsXG4gICAgICAgIFwidmlld3BvcnRcIlxuICAgICAgXSxcbiAgICAgIFwiZG9jXCI6IFwiQ29udHJvbCB3aGV0aGVyIHRoZSB0cmFuc2xhdGlvbiBpcyByZWxhdGl2ZSB0byB0aGUgbWFwIChub3J0aCkgb3Igdmlld3BvcnQgKHNjcmVlbilcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIm1hcFwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiLFxuICAgICAgICBcInRleHQtdHJhbnNsYXRlXCJcbiAgICAgIF1cbiAgICB9XG4gIH0sXG4gIFwicGFpbnRfcmFzdGVyXCI6IHtcbiAgICBcInJhc3Rlci1vcGFjaXR5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgb3BhY2l0eSBhdCB3aGljaCB0aGUgaW1hZ2Ugd2lsbCBiZSBkcmF3bi5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiAxLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcIm1heGltdW1cIjogMSxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlXG4gICAgfSxcbiAgICBcInJhc3Rlci1odWUtcm90YXRlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcInBlcmlvZFwiOiAzNjAsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwidW5pdHNcIjogXCJkZWdyZWVzXCIsXG4gICAgICBcImRvY1wiOiBcIlJvdGF0ZXMgaHVlcyBhcm91bmQgdGhlIGNvbG9yIHdoZWVsLlwiXG4gICAgfSxcbiAgICBcInJhc3Rlci1icmlnaHRuZXNzLW1pblwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiZG9jXCI6IFwiSW5jcmVhc2Ugb3IgcmVkdWNlIHRoZSBicmlnaHRuZXNzIG9mIHRoZSBpbWFnZS4gVGhlIHZhbHVlIGlzIHRoZSBtaW5pbXVtIGJyaWdodG5lc3MuXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJtYXhpbXVtXCI6IDEsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJyYXN0ZXItYnJpZ2h0bmVzcy1tYXhcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcImRvY1wiOiBcIkluY3JlYXNlIG9yIHJlZHVjZSB0aGUgYnJpZ2h0bmVzcyBvZiB0aGUgaW1hZ2UuIFRoZSB2YWx1ZSBpcyB0aGUgbWF4aW11bSBicmlnaHRuZXNzLlwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwibWF4aW11bVwiOiAxLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWVcbiAgICB9LFxuICAgIFwicmFzdGVyLXNhdHVyYXRpb25cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRvY1wiOiBcIkluY3JlYXNlIG9yIHJlZHVjZSB0aGUgc2F0dXJhdGlvbiBvZiB0aGUgaW1hZ2UuXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwibWluaW11bVwiOiAtMSxcbiAgICAgIFwibWF4aW11bVwiOiAxLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWVcbiAgICB9LFxuICAgIFwicmFzdGVyLWNvbnRyYXN0XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkb2NcIjogXCJJbmNyZWFzZSBvciByZWR1Y2UgdGhlIGNvbnRyYXN0IG9mIHRoZSBpbWFnZS5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJtaW5pbXVtXCI6IC0xLFxuICAgICAgXCJtYXhpbXVtXCI6IDEsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJyYXN0ZXItZmFkZS1kdXJhdGlvblwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAzMDAsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcIm1pbGxpc2Vjb25kc1wiLFxuICAgICAgXCJkb2NcIjogXCJGYWRlIGR1cmF0aW9uIHdoZW4gYSBuZXcgdGlsZSBpcyBhZGRlZC5cIlxuICAgIH1cbiAgfSxcbiAgXCJwYWludF9iYWNrZ3JvdW5kXCI6IHtcbiAgICBcImJhY2tncm91bmQtY29sb3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGNvbG9yIHdpdGggd2hpY2ggdGhlIGJhY2tncm91bmQgd2lsbCBiZSBkcmF3bi5cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBcIiFcIjogXCJiYWNrZ3JvdW5kLWltYWdlXCJcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG4gICAgXCJiYWNrZ3JvdW5kLWltYWdlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcImRvY1wiOiBcIk9wdGlvbmFsbHkgYW4gaW1hZ2Ugd2hpY2ggaXMgZHJhd24gYXMgdGhlIGJhY2tncm91bmQuXCJcbiAgICB9LFxuICAgIFwiYmFja2dyb3VuZC1vcGFjaXR5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwibWF4aW11bVwiOiAxLFxuICAgICAgXCJkb2NcIjogXCJUaGUgb3BhY2l0eSBhdCB3aGljaCB0aGUgYmFja2dyb3VuZCB3aWxsIGJlIGRyYXduLlwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWVcbiAgICB9XG4gIH0sXG4gIFwidHJhbnNpdGlvblwiOiB7XG4gICAgXCJkdXJhdGlvblwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAzMDAsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwidW5pdHNcIjogXCJtaWxsaXNlY29uZHNcIixcbiAgICAgIFwiZG9jXCI6IFwiVGltZSBhbGxvdHRlZCBmb3IgdHJhbnNpdGlvbnMgdG8gY29tcGxldGUuXCJcbiAgICB9LFxuICAgIFwiZGVsYXlcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJ1bml0c1wiOiBcIm1pbGxpc2Vjb25kc1wiLFxuICAgICAgXCJkb2NcIjogXCJMZW5ndGggb2YgdGltZSBiZWZvcmUgYSB0cmFuc2l0aW9uIGJlZ2lucy5cIlxuICAgIH1cbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIiR2ZXJzaW9uXCI6IDgsXG4gIFwiJHJvb3RcIjoge1xuICAgIFwidmVyc2lvblwiOiB7XG4gICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcInZhbHVlc1wiOiBbOF0sXG4gICAgICBcImRvY1wiOiBcIlN0eWxlIHNwZWNpZmljYXRpb24gdmVyc2lvbiBudW1iZXIuIE11c3QgYmUgOC5cIixcbiAgICAgIFwiZXhhbXBsZVwiOiA4XG4gICAgfSxcbiAgICBcIm5hbWVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImRvY1wiOiBcIkEgaHVtYW4tcmVhZGFibGUgbmFtZSBmb3IgdGhlIHN0eWxlLlwiLFxuICAgICAgXCJleGFtcGxlXCI6IFwiQnJpZ2h0XCJcbiAgICB9LFxuICAgIFwibWV0YWRhdGFcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiKlwiLFxuICAgICAgXCJkb2NcIjogXCJBcmJpdHJhcnkgcHJvcGVydGllcyB1c2VmdWwgdG8gdHJhY2sgd2l0aCB0aGUgc3R5bGVzaGVldCwgYnV0IGRvIG5vdCBpbmZsdWVuY2UgcmVuZGVyaW5nLiBQcm9wZXJ0aWVzIHNob3VsZCBiZSBwcmVmaXhlZCB0byBhdm9pZCBjb2xsaXNpb25zLCBsaWtlICdtYXBib3g6Jy5cIlxuICAgIH0sXG4gICAgXCJjZW50ZXJcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwidmFsdWVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZG9jXCI6IFwiRGVmYXVsdCBtYXAgY2VudGVyIGluIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUuICBUaGUgc3R5bGUgY2VudGVyIHdpbGwgYmUgdXNlZCBvbmx5IGlmIHRoZSBtYXAgaGFzIG5vdCBiZWVuIHBvc2l0aW9uZWQgYnkgb3RoZXIgbWVhbnMgKGUuZy4gbWFwIG9wdGlvbnMgb3IgdXNlciBpbnRlcmFjdGlvbikuXCIsXG4gICAgICBcImV4YW1wbGVcIjogWy03My45NzQ5LCA0MC43NzM2XVxuICAgIH0sXG4gICAgXCJ6b29tXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkb2NcIjogXCJEZWZhdWx0IHpvb20gbGV2ZWwuICBUaGUgc3R5bGUgem9vbSB3aWxsIGJlIHVzZWQgb25seSBpZiB0aGUgbWFwIGhhcyBub3QgYmVlbiBwb3NpdGlvbmVkIGJ5IG90aGVyIG1lYW5zIChlLmcuIG1hcCBvcHRpb25zIG9yIHVzZXIgaW50ZXJhY3Rpb24pLlwiLFxuICAgICAgXCJleGFtcGxlXCI6IDEyLjVcbiAgICB9LFxuICAgIFwiYmVhcmluZ1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJwZXJpb2RcIjogMzYwLFxuICAgICAgXCJ1bml0c1wiOiBcImRlZ3JlZXNcIixcbiAgICAgIFwiZG9jXCI6IFwiRGVmYXVsdCBiZWFyaW5nLCBpbiBkZWdyZWVzIGNsb2Nrd2lzZSBmcm9tIHRydWUgbm9ydGguICBUaGUgc3R5bGUgYmVhcmluZyB3aWxsIGJlIHVzZWQgb25seSBpZiB0aGUgbWFwIGhhcyBub3QgYmVlbiBwb3NpdGlvbmVkIGJ5IG90aGVyIG1lYW5zIChlLmcuIG1hcCBvcHRpb25zIG9yIHVzZXIgaW50ZXJhY3Rpb24pLlwiLFxuICAgICAgXCJleGFtcGxlXCI6IDI5XG4gICAgfSxcbiAgICBcInBpdGNoXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcInVuaXRzXCI6IFwiZGVncmVlc1wiLFxuICAgICAgXCJkb2NcIjogXCJEZWZhdWx0IHBpdGNoLCBpbiBkZWdyZWVzLiBaZXJvIGlzIHBlcnBlbmRpY3VsYXIgdG8gdGhlIHN1cmZhY2UsIGZvciBhIGxvb2sgc3RyYWlnaHQgZG93biBhdCB0aGUgbWFwLCB3aGlsZSBhIGdyZWF0ZXIgdmFsdWUgbGlrZSA2MCBsb29rcyBhaGVhZCB0b3dhcmRzIHRoZSBob3Jpem9uLiBUaGUgc3R5bGUgcGl0Y2ggd2lsbCBiZSB1c2VkIG9ubHkgaWYgdGhlIG1hcCBoYXMgbm90IGJlZW4gcG9zaXRpb25lZCBieSBvdGhlciBtZWFucyAoZS5nLiBtYXAgb3B0aW9ucyBvciB1c2VyIGludGVyYWN0aW9uKS5cIixcbiAgICAgIFwiZXhhbXBsZVwiOiA1MFxuICAgIH0sXG4gICAgXCJsaWdodFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJsaWdodFwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgZ2xvYmFsIGxpZ2h0IHNvdXJjZS5cIixcbiAgICAgIFwiZXhhbXBsZVwiOiB7XG4gICAgICAgIFwiYW5jaG9yXCI6IFwidmlld3BvcnRcIixcbiAgICAgICAgXCJjb2xvclwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwiaW50ZW5zaXR5XCI6IDAuNFxuICAgICAgfVxuICAgIH0sXG4gICAgXCJzb3VyY2VzXCI6IHtcbiAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgIFwidHlwZVwiOiBcInNvdXJjZXNcIixcbiAgICAgIFwiZG9jXCI6IFwiRGF0YSBzb3VyY2Ugc3BlY2lmaWNhdGlvbnMuXCIsXG4gICAgICBcImV4YW1wbGVcIjoge1xuICAgICAgICBcIm1hcGJveC1zdHJlZXRzXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJ2ZWN0b3JcIixcbiAgICAgICAgICBcInVybFwiOiBcIm1hcGJveDovL21hcGJveC5tYXBib3gtc3RyZWV0cy12NlwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwic3ByaXRlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkb2NcIjogXCJBIGJhc2UgVVJMIGZvciByZXRyaWV2aW5nIHRoZSBzcHJpdGUgaW1hZ2UgYW5kIG1ldGFkYXRhLiBUaGUgZXh0ZW5zaW9ucyBgLnBuZ2AsIGAuanNvbmAgYW5kIHNjYWxlIGZhY3RvciBgQDJ4LnBuZ2Agd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGFwcGVuZGVkLiBUaGlzIHByb3BlcnR5IGlzIHJlcXVpcmVkIGlmIGFueSBsYXllciB1c2VzIHRoZSBgYmFja2dyb3VuZC1wYXR0ZXJuYCwgYGZpbGwtcGF0dGVybmAsIGBsaW5lLXBhdHRlcm5gLCBgZmlsbC1leHRydXNpb24tcGF0dGVybmAsIG9yIGBpY29uLWltYWdlYCBwcm9wZXJ0aWVzLlwiLFxuICAgICAgXCJleGFtcGxlXCI6IFwibWFwYm94Oi8vc3ByaXRlcy9tYXBib3gvYnJpZ2h0LXY4XCJcbiAgICB9LFxuICAgIFwiZ2x5cGhzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkb2NcIjogXCJBIFVSTCB0ZW1wbGF0ZSBmb3IgbG9hZGluZyBzaWduZWQtZGlzdGFuY2UtZmllbGQgZ2x5cGggc2V0cyBpbiBQQkYgZm9ybWF0LiBUaGUgVVJMIG11c3QgaW5jbHVkZSBge2ZvbnRzdGFja31gIGFuZCBge3JhbmdlfWAgdG9rZW5zLiBUaGlzIHByb3BlcnR5IGlzIHJlcXVpcmVkIGlmIGFueSBsYXllciB1c2VzIHRoZSBgdGV4dC1maWVsZGAgbGF5b3V0IHByb3BlcnR5LlwiLFxuICAgICAgXCJleGFtcGxlXCI6IFwibWFwYm94Oi8vZm9udHMvbWFwYm94L3tmb250c3RhY2t9L3tyYW5nZX0ucGJmXCJcbiAgICB9LFxuICAgIFwidHJhbnNpdGlvblwiOiB7XG4gICAgICBcInR5cGVcIjogXCJ0cmFuc2l0aW9uXCIsXG4gICAgICBcImRvY1wiOiBcIkEgZ2xvYmFsIHRyYW5zaXRpb24gZGVmaW5pdGlvbiB0byB1c2UgYXMgYSBkZWZhdWx0IGFjcm9zcyBwcm9wZXJ0aWVzLlwiLFxuICAgICAgXCJleGFtcGxlXCI6IHtcbiAgICAgICAgXCJkdXJhdGlvblwiOiAzMDAsXG4gICAgICAgIFwiZGVsYXlcIjogMFxuICAgICAgfVxuICAgIH0sXG4gICAgXCJsYXllcnNcIjoge1xuICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwidmFsdWVcIjogXCJsYXllclwiLFxuICAgICAgXCJkb2NcIjogXCJMYXllcnMgd2lsbCBiZSBkcmF3biBpbiB0aGUgb3JkZXIgb2YgdGhpcyBhcnJheS5cIixcbiAgICAgIFwiZXhhbXBsZVwiOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBcImlkXCI6IFwid2F0ZXJcIixcbiAgICAgICAgICBcInNvdXJjZVwiOiBcIm1hcGJveC1zdHJlZXRzXCIsXG4gICAgICAgICAgXCJzb3VyY2UtbGF5ZXJcIjogXCJ3YXRlclwiLFxuICAgICAgICAgIFwidHlwZVwiOiBcImZpbGxcIixcbiAgICAgICAgICBcInBhaW50XCI6IHtcbiAgICAgICAgICAgIFwiZmlsbC1jb2xvclwiOiBcIiMwMGZmZmZcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgXVxuICAgIH1cbiAgfSxcbiAgXCJzb3VyY2VzXCI6IHtcbiAgICBcIipcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic291cmNlXCIsXG4gICAgICBcImRvY1wiOiBcIlNwZWNpZmljYXRpb24gb2YgYSBkYXRhIHNvdXJjZS4gRm9yIHZlY3RvciBhbmQgcmFzdGVyIHNvdXJjZXMsIGVpdGhlciBUaWxlSlNPTiBvciBhIFVSTCB0byBhIFRpbGVKU09OIG11c3QgYmUgcHJvdmlkZWQuIEZvciBpbWFnZSBhbmQgdmlkZW8gc291cmNlcywgYSBVUkwgbXVzdCBiZSBwcm92aWRlZC4gRm9yIEdlb0pTT04gc291cmNlcywgYSBVUkwgb3IgaW5saW5lIEdlb0pTT04gbXVzdCBiZSBwcm92aWRlZC5cIlxuICAgIH1cbiAgfSxcbiAgXCJzb3VyY2VcIjogW1xuICAgIFwic291cmNlX3RpbGVcIixcbiAgICBcInNvdXJjZV9nZW9qc29uXCIsXG4gICAgXCJzb3VyY2VfdmlkZW9cIixcbiAgICBcInNvdXJjZV9pbWFnZVwiLFxuICAgIFwic291cmNlX2NhbnZhc1wiXG4gIF0sXG4gIFwic291cmNlX3RpbGVcIjoge1xuICAgIFwidHlwZVwiOiB7XG4gICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcInZhbHVlc1wiOiB7XG4gICAgICAgIFwidmVjdG9yXCI6IHtcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiQSB2ZWN0b3IgdGlsZSBzb3VyY2UuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJyYXN0ZXJcIjoge1xuICAgICAgICAgICAgXCJkb2NcIjogXCJBIHJhc3RlciB0aWxlIHNvdXJjZS5cIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJkb2NcIjogXCJUaGUgZGF0YSB0eXBlIG9mIHRoZSB0aWxlIHNvdXJjZS5cIlxuICAgIH0sXG4gICAgXCJ1cmxcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImRvY1wiOiBcIkEgVVJMIHRvIGEgVGlsZUpTT04gcmVzb3VyY2UuIFN1cHBvcnRlZCBwcm90b2NvbHMgYXJlIGBodHRwOmAsIGBodHRwczpgLCBhbmQgYG1hcGJveDovLzxtYXBpZD5gLlwiXG4gICAgfSxcbiAgICBcInRpbGVzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcInZhbHVlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImRvY1wiOiBcIkFuIGFycmF5IG9mIG9uZSBvciBtb3JlIHRpbGUgc291cmNlIFVSTHMsIGFzIGluIHRoZSBUaWxlSlNPTiBzcGVjLlwiXG4gICAgfSxcbiAgICBcImJvdW5kc1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJ2YWx1ZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJsZW5ndGhcIjogNCxcbiAgICAgIFwiZGVmYXVsdFwiOiBbLTE4MCwgLTg1LjA1MTEsIDE4MCwgODUuMDUxMV0sXG4gICAgICBcImRvY1wiOiBcIkFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUgb2YgdGhlIHNvdXRod2VzdCBhbmQgbm9ydGhlYXN0IGNvcm5lcnMgb2YgdGhlIHNvdXJjZSdzIGJvdW5kaW5nIGJveCBpbiB0aGUgZm9sbG93aW5nIG9yZGVyOiBgW3N3LmxuZywgc3cubGF0LCBuZS5sbmcsIG5lLmxhdF1gLiBXaGVuIHRoaXMgcHJvcGVydHkgaXMgaW5jbHVkZWQgaW4gYSBzb3VyY2UsIG5vIHRpbGVzIG91dHNpZGUgb2YgdGhlIGdpdmVuIGJvdW5kcyBhcmUgcmVxdWVzdGVkIGJ5IE1hcGJveCBHTC5cIlxuICAgIH0sXG4gICAgXCJtaW56b29tXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcImRvY1wiOiBcIk1pbmltdW0gem9vbSBsZXZlbCBmb3Igd2hpY2ggdGlsZXMgYXJlIGF2YWlsYWJsZSwgYXMgaW4gdGhlIFRpbGVKU09OIHNwZWMuXCJcbiAgICB9LFxuICAgIFwibWF4em9vbVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAyMixcbiAgICAgIFwiZG9jXCI6IFwiTWF4aW11bSB6b29tIGxldmVsIGZvciB3aGljaCB0aWxlcyBhcmUgYXZhaWxhYmxlLCBhcyBpbiB0aGUgVGlsZUpTT04gc3BlYy4gRGF0YSBmcm9tIHRpbGVzIGF0IHRoZSBtYXh6b29tIGFyZSB1c2VkIHdoZW4gZGlzcGxheWluZyB0aGUgbWFwIGF0IGhpZ2hlciB6b29tIGxldmVscy5cIlxuICAgIH0sXG4gICAgXCJ0aWxlU2l6ZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiA1MTIsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBtaW5pbXVtIHZpc3VhbCBzaXplIHRvIGRpc3BsYXkgdGlsZXMgZm9yIHRoaXMgbGF5ZXIuIE9ubHkgY29uZmlndXJhYmxlIGZvciByYXN0ZXIgbGF5ZXJzLlwiXG4gICAgfSxcbiAgICBcIipcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiKlwiLFxuICAgICAgXCJkb2NcIjogXCJPdGhlciBrZXlzIHRvIGNvbmZpZ3VyZSB0aGUgZGF0YSBzb3VyY2UuXCJcbiAgICB9XG4gIH0sXG4gIFwic291cmNlX2dlb2pzb25cIjoge1xuICAgIFwidHlwZVwiOiB7XG4gICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcInZhbHVlc1wiOiB7XG4gICAgICAgIFwiZ2VvanNvblwiOiB7XG4gICAgICAgICAgICBcImRvY1wiOiBcIkEgR2VvSlNPTiBkYXRhIHNvdXJjZS5cIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJkb2NcIjogXCJUaGUgZGF0YSB0eXBlIG9mIHRoZSBHZW9KU09OIHNvdXJjZS5cIlxuICAgIH0sXG4gICAgXCJkYXRhXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIipcIixcbiAgICAgIFwiZG9jXCI6IFwiQSBVUkwgdG8gYSBHZW9KU09OIGZpbGUsIG9yIGlubGluZSBHZW9KU09OLlwiXG4gICAgfSxcbiAgICBcIm1heHpvb21cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMTgsXG4gICAgICBcImRvY1wiOiBcIk1heGltdW0gem9vbSBsZXZlbCBhdCB3aGljaCB0byBjcmVhdGUgdmVjdG9yIHRpbGVzIChoaWdoZXIgbWVhbnMgZ3JlYXRlciBkZXRhaWwgYXQgaGlnaCB6b29tIGxldmVscykuXCJcbiAgICB9LFxuICAgIFwiYnVmZmVyXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEyOCxcbiAgICAgIFwibWF4aW11bVwiOiA1MTIsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwiZG9jXCI6IFwiU2l6ZSBvZiB0aGUgdGlsZSBidWZmZXIgb24gZWFjaCBzaWRlLiBBIHZhbHVlIG9mIDAgcHJvZHVjZXMgbm8gYnVmZmVyLiBBIHZhbHVlIG9mIDUxMiBwcm9kdWNlcyBhIGJ1ZmZlciBhcyB3aWRlIGFzIHRoZSB0aWxlIGl0c2VsZi4gTGFyZ2VyIHZhbHVlcyBwcm9kdWNlIGZld2VyIHJlbmRlcmluZyBhcnRpZmFjdHMgbmVhciB0aWxlIGVkZ2VzIGFuZCBzbG93ZXIgcGVyZm9ybWFuY2UuXCJcbiAgICB9LFxuICAgIFwidG9sZXJhbmNlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAuMzc1LFxuICAgICAgXCJkb2NcIjogXCJEb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb24gdG9sZXJhbmNlIChoaWdoZXIgbWVhbnMgc2ltcGxlciBnZW9tZXRyaWVzIGFuZCBmYXN0ZXIgcGVyZm9ybWFuY2UpLlwiXG4gICAgfSxcbiAgICBcImNsdXN0ZXJcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgXCJkZWZhdWx0XCI6IGZhbHNlLFxuICAgICAgXCJkb2NcIjogXCJJZiB0aGUgZGF0YSBpcyBhIGNvbGxlY3Rpb24gb2YgcG9pbnQgZmVhdHVyZXMsIHNldHRpbmcgdGhpcyB0byB0cnVlIGNsdXN0ZXJzIHRoZSBwb2ludHMgYnkgcmFkaXVzIGludG8gZ3JvdXBzLlwiXG4gICAgfSxcbiAgICBcImNsdXN0ZXJSYWRpdXNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogNTAsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwiZG9jXCI6IFwiUmFkaXVzIG9mIGVhY2ggY2x1c3RlciBpZiBjbHVzdGVyaW5nIGlzIGVuYWJsZWQuIEEgdmFsdWUgb2YgNTEyIGluZGljYXRlcyBhIHJhZGl1cyBlcXVhbCB0byB0aGUgd2lkdGggb2YgYSB0aWxlLlwiXG4gICAgfSxcbiAgICBcImNsdXN0ZXJNYXhab29tXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkb2NcIjogXCJNYXggem9vbSBvbiB3aGljaCB0byBjbHVzdGVyIHBvaW50cyBpZiBjbHVzdGVyaW5nIGlzIGVuYWJsZWQuIERlZmF1bHRzIHRvIG9uZSB6b29tIGxlc3MgdGhhbiBtYXh6b29tIChzbyB0aGF0IGxhc3Qgem9vbSBmZWF0dXJlcyBhcmUgbm90IGNsdXN0ZXJlZCkuXCJcbiAgICB9XG4gIH0sXG4gIFwic291cmNlX3ZpZGVvXCI6IHtcbiAgICBcInR5cGVcIjoge1xuICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJ2YWx1ZXNcIjoge1xuICAgICAgICBcInZpZGVvXCI6IHtcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiQSB2aWRlbyBkYXRhIHNvdXJjZS5cIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJkb2NcIjogXCJUaGUgZGF0YSB0eXBlIG9mIHRoZSB2aWRlbyBzb3VyY2UuXCJcbiAgICB9LFxuICAgIFwidXJsc1wiOiB7XG4gICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJ2YWx1ZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkb2NcIjogXCJVUkxzIHRvIHZpZGVvIGNvbnRlbnQgaW4gb3JkZXIgb2YgcHJlZmVycmVkIGZvcm1hdC5cIlxuICAgIH0sXG4gICAgXCJjb29yZGluYXRlc1wiOiB7XG4gICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICBcImRvY1wiOiBcIkNvcm5lcnMgb2YgdmlkZW8gc3BlY2lmaWVkIGluIGxvbmdpdHVkZSwgbGF0aXR1ZGUgcGFpcnMuXCIsXG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJsZW5ndGhcIjogNCxcbiAgICAgIFwidmFsdWVcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgICBcImxlbmd0aFwiOiAyLFxuICAgICAgICBcInZhbHVlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiZG9jXCI6IFwiQSBzaW5nbGUgbG9uZ2l0dWRlLCBsYXRpdHVkZSBwYWlyLlwiXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBcInNvdXJjZV9pbWFnZVwiOiB7XG4gICAgXCJ0eXBlXCI6IHtcbiAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwidmFsdWVzXCI6IHtcbiAgICAgICAgXCJpbWFnZVwiOiB7XG4gICAgICAgICAgICBcImRvY1wiOiBcIkFuIGltYWdlIGRhdGEgc291cmNlLlwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcImRvY1wiOiBcIlRoZSBkYXRhIHR5cGUgb2YgdGhlIGltYWdlIHNvdXJjZS5cIlxuICAgIH0sXG4gICAgXCJ1cmxcIjoge1xuICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImRvY1wiOiBcIlVSTCB0aGF0IHBvaW50cyB0byBhbiBpbWFnZS5cIlxuICAgIH0sXG4gICAgXCJjb29yZGluYXRlc1wiOiB7XG4gICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICBcImRvY1wiOiBcIkNvcm5lcnMgb2YgaW1hZ2Ugc3BlY2lmaWVkIGluIGxvbmdpdHVkZSwgbGF0aXR1ZGUgcGFpcnMuXCIsXG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJsZW5ndGhcIjogNCxcbiAgICAgIFwidmFsdWVcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgICBcImxlbmd0aFwiOiAyLFxuICAgICAgICBcInZhbHVlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiZG9jXCI6IFwiQSBzaW5nbGUgbG9uZ2l0dWRlLCBsYXRpdHVkZSBwYWlyLlwiXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBcInNvdXJjZV9jYW52YXNcIjoge1xuICAgIFwidHlwZVwiOiB7XG4gICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcInZhbHVlc1wiOiB7XG4gICAgICAgIFwiY2FudmFzXCI6IHtcbiAgICAgICAgICBcImRvY1wiOiBcIkEgY2FudmFzIGRhdGEgc291cmNlLlwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcImRvY1wiOiBcIlRoZSBkYXRhIHR5cGUgb2YgdGhlIGNhbnZhcyBzb3VyY2UuXCJcbiAgICB9LFxuICAgIFwiY29vcmRpbmF0ZXNcIjoge1xuICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJDb3JuZXJzIG9mIGNhbnZhcyBzcGVjaWZpZWQgaW4gbG9uZ2l0dWRlLCBsYXRpdHVkZSBwYWlycy5cIixcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcImxlbmd0aFwiOiA0LFxuICAgICAgXCJ2YWx1ZVwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICAgIFwibGVuZ3RoXCI6IDIsXG4gICAgICAgIFwidmFsdWVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJkb2NcIjogXCJBIHNpbmdsZSBsb25naXR1ZGUsIGxhdGl0dWRlIHBhaXIuXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiYW5pbWF0ZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImRlZmF1bHRcIjogXCJ0cnVlXCIsXG4gICAgICBcImRvY1wiOiBcIldoZXRoZXIgdGhlIGNhbnZhcyBzb3VyY2UgaXMgYW5pbWF0ZWQuIElmIHRoZSBjYW52YXMgaXMgc3RhdGljLCBgYW5pbWF0ZWAgc2hvdWxkIGJlIHNldCB0byBgZmFsc2VgIHRvIGltcHJvdmUgcGVyZm9ybWFuY2UuXCJcbiAgICB9LFxuICAgIFwiY2FudmFzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJIVE1MIElEIG9mIHRoZSBjYW52YXMgZnJvbSB3aGljaCB0byByZWFkIHBpeGVscy5cIlxuICAgIH1cbiAgfSxcbiAgXCJsYXllclwiOiB7XG4gICAgXCJpZFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZG9jXCI6IFwiVW5pcXVlIGxheWVyIG5hbWUuXCIsXG4gICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICB9LFxuICAgIFwidHlwZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcInZhbHVlc1wiOiB7XG4gICAgICAgIFwiZmlsbFwiOiB7XG4gICAgICAgICAgXCJkb2NcIjogXCJBIGZpbGxlZCBwb2x5Z29uIHdpdGggYW4gb3B0aW9uYWwgc3Ryb2tlZCBib3JkZXIuXCIsXG4gICAgICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgICAgICBcImpzXCI6IFwiMC4xMC4wXCIsXG4gICAgICAgICAgICAgIFwiYW5kcm9pZFwiOiBcIjIuMC4xXCIsXG4gICAgICAgICAgICAgIFwiaW9zXCI6IFwiMi4wLjBcIixcbiAgICAgICAgICAgICAgXCJtYWNvc1wiOiBcIjAuMS4wXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwibGluZVwiOiB7XG4gICAgICAgICAgXCJkb2NcIjogXCJBIHN0cm9rZWQgbGluZS5cIixcbiAgICAgICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAgICAgIFwianNcIjogXCIwLjEwLjBcIixcbiAgICAgICAgICAgICAgXCJhbmRyb2lkXCI6IFwiMi4wLjFcIixcbiAgICAgICAgICAgICAgXCJpb3NcIjogXCIyLjAuMFwiLFxuICAgICAgICAgICAgICBcIm1hY29zXCI6IFwiMC4xLjBcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJzeW1ib2xcIjoge1xuICAgICAgICAgIFwiZG9jXCI6IFwiQW4gaWNvbiBvciBhIHRleHQgbGFiZWwuXCIsXG4gICAgICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgICAgICBcImpzXCI6IFwiMC4xMC4wXCIsXG4gICAgICAgICAgICAgIFwiYW5kcm9pZFwiOiBcIjIuMC4xXCIsXG4gICAgICAgICAgICAgIFwiaW9zXCI6IFwiMi4wLjBcIixcbiAgICAgICAgICAgICAgXCJtYWNvc1wiOiBcIjAuMS4wXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiY2lyY2xlXCI6IHtcbiAgICAgICAgICBcImRvY1wiOiBcIkEgZmlsbGVkIGNpcmNsZS5cIixcbiAgICAgICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAgICAgIFwianNcIjogXCIwLjEwLjBcIixcbiAgICAgICAgICAgICAgXCJhbmRyb2lkXCI6IFwiMi4wLjFcIixcbiAgICAgICAgICAgICAgXCJpb3NcIjogXCIyLjAuMFwiLFxuICAgICAgICAgICAgICBcIm1hY29zXCI6IFwiMC4xLjBcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJoZWF0bWFwXCI6IHtcbiAgICAgICAgICBcImRvY1wiOiBcIkEgaGVhdG1hcC5cIixcbiAgICAgICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAgICAgIFwianNcIjogXCIwLjQxLjBcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJmaWxsLWV4dHJ1c2lvblwiOiB7XG4gICAgICAgICAgXCJkb2NcIjogXCJBbiBleHRydWRlZCAoM0QpIHBvbHlnb24uXCIsXG4gICAgICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgICAgICBcImpzXCI6IFwiMC4yNy4wXCIsXG4gICAgICAgICAgICAgIFwiYW5kcm9pZFwiOiBcIjUuMS4wXCIsXG4gICAgICAgICAgICAgIFwiaW9zXCI6IFwiMy42LjBcIixcbiAgICAgICAgICAgICAgXCJtYWNvc1wiOiBcIjAuNS4wXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicmFzdGVyXCI6IHtcbiAgICAgICAgICBcImRvY1wiOiBcIlJhc3RlciBtYXAgdGV4dHVyZXMgc3VjaCBhcyBzYXRlbGxpdGUgaW1hZ2VyeS5cIixcbiAgICAgICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAgICAgIFwianNcIjogXCIwLjEwLjBcIixcbiAgICAgICAgICAgICAgXCJhbmRyb2lkXCI6IFwiMi4wLjFcIixcbiAgICAgICAgICAgICAgXCJpb3NcIjogXCIyLjAuMFwiLFxuICAgICAgICAgICAgICBcIm1hY29zXCI6IFwiMC4xLjBcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJiYWNrZ3JvdW5kXCI6IHtcbiAgICAgICAgICBcImRvY1wiOiBcIlRoZSBiYWNrZ3JvdW5kIGNvbG9yIG9yIHBhdHRlcm4gb2YgdGhlIG1hcC5cIixcbiAgICAgICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAgICAgIFwianNcIjogXCIwLjEwLjBcIixcbiAgICAgICAgICAgICAgXCJhbmRyb2lkXCI6IFwiMi4wLjFcIixcbiAgICAgICAgICAgICAgXCJpb3NcIjogXCIyLjAuMFwiLFxuICAgICAgICAgICAgICBcIm1hY29zXCI6IFwiMC4xLjBcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiZG9jXCI6IFwiUmVuZGVyaW5nIHR5cGUgb2YgdGhpcyBsYXllci5cIlxuICAgIH0sXG4gICAgXCJtZXRhZGF0YVwiOiB7XG4gICAgICBcInR5cGVcIjogXCIqXCIsXG4gICAgICBcImRvY1wiOiBcIkFyYml0cmFyeSBwcm9wZXJ0aWVzIHVzZWZ1bCB0byB0cmFjayB3aXRoIHRoZSBsYXllciwgYnV0IGRvIG5vdCBpbmZsdWVuY2UgcmVuZGVyaW5nLiBQcm9wZXJ0aWVzIHNob3VsZCBiZSBwcmVmaXhlZCB0byBhdm9pZCBjb2xsaXNpb25zLCBsaWtlICdtYXBib3g6Jy5cIlxuICAgIH0sXG4gICAgXCJzb3VyY2VcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImRvY1wiOiBcIk5hbWUgb2YgYSBzb3VyY2UgZGVzY3JpcHRpb24gdG8gYmUgdXNlZCBmb3IgdGhpcyBsYXllci5cIlxuICAgIH0sXG4gICAgXCJzb3VyY2UtbGF5ZXJcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImRvY1wiOiBcIkxheWVyIHRvIHVzZSBmcm9tIGEgdmVjdG9yIHRpbGUgc291cmNlLiBSZXF1aXJlZCBpZiB0aGUgc291cmNlIHN1cHBvcnRzIG11bHRpcGxlIGxheWVycy5cIlxuICAgIH0sXG4gICAgXCJtaW56b29tXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcIm1heGltdW1cIjogMjQsXG4gICAgICBcImRvY1wiOiBcIlRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgb24gd2hpY2ggdGhlIGxheWVyIGdldHMgcGFyc2VkIGFuZCBhcHBlYXJzIG9uLlwiXG4gICAgfSxcbiAgICBcIm1heHpvb21cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwibWF4aW11bVwiOiAyNCxcbiAgICAgIFwiZG9jXCI6IFwiVGhlIG1heGltdW0gem9vbSBsZXZlbCBvbiB3aGljaCB0aGUgbGF5ZXIgZ2V0cyBwYXJzZWQgYW5kIGFwcGVhcnMgb24uXCJcbiAgICB9LFxuICAgIFwiZmlsdGVyXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImZpbHRlclwiLFxuICAgICAgXCJkb2NcIjogXCJBIGV4cHJlc3Npb24gc3BlY2lmeWluZyBjb25kaXRpb25zIG9uIHNvdXJjZSBmZWF0dXJlcy4gT25seSBmZWF0dXJlcyB0aGF0IG1hdGNoIHRoZSBmaWx0ZXIgYXJlIGRpc3BsYXllZC5cIlxuICAgIH0sXG4gICAgXCJsYXlvdXRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibGF5b3V0XCIsXG4gICAgICBcImRvY1wiOiBcIkxheW91dCBwcm9wZXJ0aWVzIGZvciB0aGUgbGF5ZXIuXCJcbiAgICB9LFxuICAgIFwicGFpbnRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwicGFpbnRcIixcbiAgICAgIFwiZG9jXCI6IFwiRGVmYXVsdCBwYWludCBwcm9wZXJ0aWVzIGZvciB0aGlzIGxheWVyLlwiXG4gICAgfSxcbiAgICBcInBhaW50LipcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwicGFpbnRcIixcbiAgICAgIFwiZG9jXCI6IFwiW0RlcHJlY2F0ZWRdIENsYXNzLXNwZWNpZmljIHBhaW50IHByb3BlcnRpZXMgZm9yIHRoaXMgbGF5ZXIuIFRoZSBjbGFzcyBuYW1lIGlzIHRoZSBwYXJ0IGFmdGVyIHRoZSBmaXJzdCBkb3QuIE5vdGU6IHN0eWxlIGNsYXNzZXMgYXJlIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCB2ZXJzaW9uIG9mIHRoaXMgc3BlYy5cIlxuICAgIH1cbiAgfSxcbiAgXCJsYXlvdXRcIjogW1xuICAgIFwibGF5b3V0X2ZpbGxcIixcbiAgICBcImxheW91dF9saW5lXCIsXG4gICAgXCJsYXlvdXRfY2lyY2xlXCIsXG4gICAgXCJsYXlvdXRfaGVhdG1hcFwiLFxuICAgIFwibGF5b3V0X2ZpbGwtZXh0cnVzaW9uXCIsXG4gICAgXCJsYXlvdXRfc3ltYm9sXCIsXG4gICAgXCJsYXlvdXRfcmFzdGVyXCIsXG4gICAgXCJsYXlvdXRfYmFja2dyb3VuZFwiXG4gIF0sXG4gIFwibGF5b3V0X2JhY2tncm91bmRcIjoge1xuICAgIFwidmlzaWJpbGl0eVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcInZhbHVlc1wiOiB7XG4gICAgICAgIFwidmlzaWJsZVwiOiB7XG4gICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBsYXllciBpcyBzaG93bi5cIlxuICAgICAgICB9LFxuICAgICAgICBcIm5vbmVcIjoge1xuICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgbGF5ZXIgaXMgbm90IHNob3duLlwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcImRlZmF1bHRcIjogXCJ2aXNpYmxlXCIsXG4gICAgICBcImRvY1wiOiBcIldoZXRoZXIgdGhpcyBsYXllciBpcyBkaXNwbGF5ZWQuXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4xMC4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiMi4wLjFcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjIuMC4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuMS4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgXCJsYXlvdXRfZmlsbFwiOiB7XG4gICAgXCJ2aXNpYmlsaXR5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwidmFsdWVzXCI6IHtcbiAgICAgICAgXCJ2aXNpYmxlXCI6IHtcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIGxheWVyIGlzIHNob3duLlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibm9uZVwiOiB7XG4gICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBsYXllciBpcyBub3Qgc2hvd24uXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcInZpc2libGVcIixcbiAgICAgIFwiZG9jXCI6IFwiV2hldGhlciB0aGlzIGxheWVyIGlzIGRpc3BsYXllZC5cIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjEwLjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCIyLjAuMVwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMi4wLjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC4xLjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBcImxheW91dF9jaXJjbGVcIjoge1xuICAgIFwidmlzaWJpbGl0eVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcInZhbHVlc1wiOiB7XG4gICAgICAgIFwidmlzaWJsZVwiOiB7XG4gICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBsYXllciBpcyBzaG93bi5cIlxuICAgICAgICB9LFxuICAgICAgICBcIm5vbmVcIjoge1xuICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgbGF5ZXIgaXMgbm90IHNob3duLlwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcImRlZmF1bHRcIjogXCJ2aXNpYmxlXCIsXG4gICAgICBcImRvY1wiOiBcIldoZXRoZXIgdGhpcyBsYXllciBpcyBkaXNwbGF5ZWQuXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4xMC4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiMi4wLjFcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjIuMC4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuMS4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgXCJsYXlvdXRfaGVhdG1hcFwiOiB7XG4gICAgXCJ2aXNpYmlsaXR5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwidmFsdWVzXCI6IHtcbiAgICAgICAgXCJ2aXNpYmxlXCI6IHtcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIGxheWVyIGlzIHNob3duLlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibm9uZVwiOiB7XG4gICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBsYXllciBpcyBub3Qgc2hvd24uXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcInZpc2libGVcIixcbiAgICAgIFwiZG9jXCI6IFwiV2hldGhlciB0aGlzIGxheWVyIGlzIGRpc3BsYXllZC5cIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjQxLjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBcImxheW91dF9maWxsLWV4dHJ1c2lvblwiOiB7XG4gICAgXCJ2aXNpYmlsaXR5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwidmFsdWVzXCI6IHtcbiAgICAgICAgXCJ2aXNpYmxlXCI6IHtcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIGxheWVyIGlzIHNob3duLlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibm9uZVwiOiB7XG4gICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBsYXllciBpcyBub3Qgc2hvd24uXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcInZpc2libGVcIixcbiAgICAgIFwiZG9jXCI6IFwiV2hldGhlciB0aGlzIGxheWVyIGlzIGRpc3BsYXllZC5cIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjI3LjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCI1LjEuMFwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMy42LjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC41LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBcImxheW91dF9saW5lXCI6IHtcbiAgICBcImxpbmUtY2FwXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwiem9vbS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ2YWx1ZXNcIjoge1xuICAgICAgICBcImJ1dHRcIjoge1xuICAgICAgICAgICAgXCJkb2NcIjogXCJBIGNhcCB3aXRoIGEgc3F1YXJlZC1vZmYgZW5kIHdoaWNoIGlzIGRyYXduIHRvIHRoZSBleGFjdCBlbmRwb2ludCBvZiB0aGUgbGluZS5cIlxuICAgICAgICB9LFxuICAgICAgICBcInJvdW5kXCI6IHtcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiQSBjYXAgd2l0aCBhIHJvdW5kZWQgZW5kIHdoaWNoIGlzIGRyYXduIGJleW9uZCB0aGUgZW5kcG9pbnQgb2YgdGhlIGxpbmUgYXQgYSByYWRpdXMgb2Ygb25lLWhhbGYgb2YgdGhlIGxpbmUncyB3aWR0aCBhbmQgY2VudGVyZWQgb24gdGhlIGVuZHBvaW50IG9mIHRoZSBsaW5lLlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwic3F1YXJlXCI6IHtcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiQSBjYXAgd2l0aCBhIHNxdWFyZWQtb2ZmIGVuZCB3aGljaCBpcyBkcmF3biBiZXlvbmQgdGhlIGVuZHBvaW50IG9mIHRoZSBsaW5lIGF0IGEgZGlzdGFuY2Ugb2Ygb25lLWhhbGYgb2YgdGhlIGxpbmUncyB3aWR0aC5cIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJkZWZhdWx0XCI6IFwiYnV0dFwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgZGlzcGxheSBvZiBsaW5lIGVuZGluZ3MuXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4xMC4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiMi4wLjFcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjIuMC4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuMS4wXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHt9XG4gICAgICB9XG4gICAgfSxcbiAgICBcImxpbmUtam9pblwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInpvb20tZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwicHJvcGVydHktZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidmFsdWVzXCI6IHtcbiAgICAgICAgXCJiZXZlbFwiOiB7XG4gICAgICAgICAgICBcImRvY1wiOiBcIkEgam9pbiB3aXRoIGEgc3F1YXJlZC1vZmYgZW5kIHdoaWNoIGlzIGRyYXduIGJleW9uZCB0aGUgZW5kcG9pbnQgb2YgdGhlIGxpbmUgYXQgYSBkaXN0YW5jZSBvZiBvbmUtaGFsZiBvZiB0aGUgbGluZSdzIHdpZHRoLlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwicm91bmRcIjoge1xuICAgICAgICAgICAgXCJkb2NcIjogXCJBIGpvaW4gd2l0aCBhIHJvdW5kZWQgZW5kIHdoaWNoIGlzIGRyYXduIGJleW9uZCB0aGUgZW5kcG9pbnQgb2YgdGhlIGxpbmUgYXQgYSByYWRpdXMgb2Ygb25lLWhhbGYgb2YgdGhlIGxpbmUncyB3aWR0aCBhbmQgY2VudGVyZWQgb24gdGhlIGVuZHBvaW50IG9mIHRoZSBsaW5lLlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibWl0ZXJcIjoge1xuICAgICAgICAgICAgXCJkb2NcIjogXCJBIGpvaW4gd2l0aCBhIHNoYXJwLCBhbmdsZWQgY29ybmVyIHdoaWNoIGlzIGRyYXduIHdpdGggdGhlIG91dGVyIHNpZGVzIGJleW9uZCB0aGUgZW5kcG9pbnQgb2YgdGhlIHBhdGggdW50aWwgdGhleSBtZWV0LlwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcImRlZmF1bHRcIjogXCJtaXRlclwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgZGlzcGxheSBvZiBsaW5lcyB3aGVuIGpvaW5pbmcuXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4xMC4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiMi4wLjFcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjIuMC4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuMS4wXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC40MC4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJsaW5lLW1pdGVyLWxpbWl0XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInpvb20tZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiVXNlZCB0byBhdXRvbWF0aWNhbGx5IGNvbnZlcnQgbWl0ZXIgam9pbnMgdG8gYmV2ZWwgam9pbnMgZm9yIHNoYXJwIGFuZ2xlcy5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICB7XG4gICAgICAgICAgXCJsaW5lLWpvaW5cIjogXCJtaXRlclwiXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4xMC4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiMi4wLjFcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjIuMC4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuMS4wXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHt9XG4gICAgICB9XG4gICAgfSxcbiAgICBcImxpbmUtcm91bmQtbGltaXRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMS4wNSxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiem9vbS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJVc2VkIHRvIGF1dG9tYXRpY2FsbHkgY29udmVydCByb3VuZCBqb2lucyB0byBtaXRlciBqb2lucyBmb3Igc2hhbGxvdyBhbmdsZXMuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgIFwibGluZS1qb2luXCI6IFwicm91bmRcIlxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAgXCJqc1wiOiBcIjAuMTAuMFwiLFxuICAgICAgICAgIFwiYW5kcm9pZFwiOiBcIjIuMC4xXCIsXG4gICAgICAgICAgXCJpb3NcIjogXCIyLjAuMFwiLFxuICAgICAgICAgIFwibWFjb3NcIjogXCIwLjEuMFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7fVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJ2aXNpYmlsaXR5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwidmFsdWVzXCI6IHtcbiAgICAgICAgXCJ2aXNpYmxlXCI6IHtcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIGxheWVyIGlzIHNob3duLlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibm9uZVwiOiB7XG4gICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBsYXllciBpcyBub3Qgc2hvd24uXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcInZpc2libGVcIixcbiAgICAgIFwiZG9jXCI6IFwiV2hldGhlciB0aGlzIGxheWVyIGlzIGRpc3BsYXllZC5cIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjEwLjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCIyLjAuMVwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMi4wLjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC4xLjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge31cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIFwibGF5b3V0X3N5bWJvbFwiOiB7XG4gICAgXCJzeW1ib2wtcGxhY2VtZW50XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwiem9vbS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ2YWx1ZXNcIjoge1xuICAgICAgICAgIFwicG9pbnRcIjoge1xuICAgICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBsYWJlbCBpcyBwbGFjZWQgYXQgdGhlIHBvaW50IHdoZXJlIHRoZSBnZW9tZXRyeSBpcyBsb2NhdGVkLlwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImxpbmVcIjoge1xuICAgICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBsYWJlbCBpcyBwbGFjZWQgYWxvbmcgdGhlIGxpbmUgb2YgdGhlIGdlb21ldHJ5LiBDYW4gb25seSBiZSB1c2VkIG9uIGBMaW5lU3RyaW5nYCBhbmQgYFBvbHlnb25gIGdlb21ldHJpZXMuXCJcbiAgICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJkZWZhdWx0XCI6IFwicG9pbnRcIixcbiAgICAgIFwiZG9jXCI6IFwiTGFiZWwgcGxhY2VtZW50IHJlbGF0aXZlIHRvIGl0cyBnZW9tZXRyeS5cIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjEwLjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCIyLjAuMVwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMi4wLjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC4xLjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge31cbiAgICAgIH1cbiAgICB9LFxuICAgIFwic3ltYm9sLXNwYWNpbmdcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMjUwLFxuICAgICAgXCJtaW5pbXVtXCI6IDEsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInpvb20tZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidW5pdHNcIjogXCJwaXhlbHNcIixcbiAgICAgIFwiZG9jXCI6IFwiRGlzdGFuY2UgYmV0d2VlbiB0d28gc3ltYm9sIGFuY2hvcnMuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgIFwic3ltYm9sLXBsYWNlbWVudFwiOiBcImxpbmVcIlxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAgXCJqc1wiOiBcIjAuMTAuMFwiLFxuICAgICAgICAgIFwiYW5kcm9pZFwiOiBcIjIuMC4xXCIsXG4gICAgICAgICAgXCJpb3NcIjogXCIyLjAuMFwiLFxuICAgICAgICAgIFwibWFjb3NcIjogXCIwLjEuMFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7fVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJzeW1ib2wtYXZvaWQtZWRnZXNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ6b29tLWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcImRlZmF1bHRcIjogZmFsc2UsXG4gICAgICBcImRvY1wiOiBcIklmIHRydWUsIHRoZSBzeW1ib2xzIHdpbGwgbm90IGNyb3NzIHRpbGUgZWRnZXMgdG8gYXZvaWQgbXV0dWFsIGNvbGxpc2lvbnMuIFJlY29tbWVuZGVkIGluIGxheWVycyB0aGF0IGRvbid0IGhhdmUgZW5vdWdoIHBhZGRpbmcgaW4gdGhlIHZlY3RvciB0aWxlIHRvIHByZXZlbnQgY29sbGlzaW9ucywgb3IgaWYgaXQgaXMgYSBwb2ludCBzeW1ib2wgbGF5ZXIgcGxhY2VkIGFmdGVyIGEgbGluZSBzeW1ib2wgbGF5ZXIuXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4xMC4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiMi4wLjFcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjIuMC4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuMS4wXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHt9XG4gICAgICB9XG4gICAgfSxcbiAgICBcImljb24tYWxsb3ctb3ZlcmxhcFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInpvb20tZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZSxcbiAgICAgIFwiZG9jXCI6IFwiSWYgdHJ1ZSwgdGhlIGljb24gd2lsbCBiZSB2aXNpYmxlIGV2ZW4gaWYgaXQgY29sbGlkZXMgd2l0aCBvdGhlciBwcmV2aW91c2x5IGRyYXduIHN5bWJvbHMuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJpY29uLWltYWdlXCJcbiAgICAgIF0sXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4xMC4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiMi4wLjFcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjIuMC4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuMS4wXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHt9XG4gICAgICB9XG4gICAgfSxcbiAgICBcImljb24taWdub3JlLXBsYWNlbWVudFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInpvb20tZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZSxcbiAgICAgIFwiZG9jXCI6IFwiSWYgdHJ1ZSwgb3RoZXIgc3ltYm9scyBjYW4gYmUgdmlzaWJsZSBldmVuIGlmIHRoZXkgY29sbGlkZSB3aXRoIHRoZSBpY29uLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgICBdLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAgXCJqc1wiOiBcIjAuMTAuMFwiLFxuICAgICAgICAgIFwiYW5kcm9pZFwiOiBcIjIuMC4xXCIsXG4gICAgICAgICAgXCJpb3NcIjogXCIyLjAuMFwiLFxuICAgICAgICAgIFwibWFjb3NcIjogXCIwLjEuMFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7fVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJpY29uLW9wdGlvbmFsXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwiem9vbS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJkZWZhdWx0XCI6IGZhbHNlLFxuICAgICAgXCJkb2NcIjogXCJJZiB0cnVlLCB0ZXh0IHdpbGwgZGlzcGxheSB3aXRob3V0IHRoZWlyIGNvcnJlc3BvbmRpbmcgaWNvbnMgd2hlbiB0aGUgaWNvbiBjb2xsaWRlcyB3aXRoIG90aGVyIHN5bWJvbHMgYW5kIHRoZSB0ZXh0IGRvZXMgbm90LlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiLFxuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXSxcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjEwLjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCIyLjAuMVwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMi4wLjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC4xLjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge31cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ6b29tLWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInZhbHVlc1wiOiB7XG4gICAgICAgIFwibWFwXCI6IHtcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiV2hlbiBgc3ltYm9sLXBsYWNlbWVudGAgaXMgc2V0IHRvIGBwb2ludGAsIGFsaWducyBpY29ucyBlYXN0LXdlc3QuIFdoZW4gYHN5bWJvbC1wbGFjZW1lbnRgIGlzIHNldCB0byBgbGluZWAsIGFsaWducyBpY29uIHgtYXhlcyB3aXRoIHRoZSBsaW5lLlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwidmlld3BvcnRcIjoge1xuICAgICAgICAgICAgXCJkb2NcIjogXCJQcm9kdWNlcyBpY29ucyB3aG9zZSB4LWF4ZXMgYXJlIGFsaWduZWQgd2l0aCB0aGUgeC1heGlzIG9mIHRoZSB2aWV3cG9ydCwgcmVnYXJkbGVzcyBvZiB0aGUgdmFsdWUgb2YgYHN5bWJvbC1wbGFjZW1lbnRgLlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiYXV0b1wiOiB7XG4gICAgICAgICAgICBcImRvY1wiOiBcIldoZW4gYHN5bWJvbC1wbGFjZW1lbnRgIGlzIHNldCB0byBgcG9pbnRgLCB0aGlzIGlzIGVxdWl2YWxlbnQgdG8gYHZpZXdwb3J0YC4gV2hlbiBgc3ltYm9sLXBsYWNlbWVudGAgaXMgc2V0IHRvIGBsaW5lYCwgdGhpcyBpcyBlcXVpdmFsZW50IHRvIGBtYXBgLlwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcImRlZmF1bHRcIjogXCJhdXRvXCIsXG4gICAgICBcImRvY1wiOiBcIkluIGNvbWJpbmF0aW9uIHdpdGggYHN5bWJvbC1wbGFjZW1lbnRgLCBkZXRlcm1pbmVzIHRoZSByb3RhdGlvbiBiZWhhdmlvciBvZiBpY29ucy5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImljb24taW1hZ2VcIlxuICAgICAgXSxcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjEwLjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCIyLjAuMVwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMi4wLjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC4xLjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImBhdXRvYCB2YWx1ZVwiOiB7XG4gICAgICAgICAgXCJqc1wiOiBcIjAuMjUuMFwiLFxuICAgICAgICAgIFwiYW5kcm9pZFwiOiBcIjQuMi4wXCIsXG4gICAgICAgICAgXCJpb3NcIjogXCIzLjQuMFwiLFxuICAgICAgICAgIFwibWFjb3NcIjogXCIwLjMuMFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7fVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJpY29uLXNpemVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMSxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ6b29tLWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInByb3BlcnR5LWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInVuaXRzXCI6IFwiZmFjdG9yIG9mIHRoZSBvcmlnaW5hbCBpY29uIHNpemVcIixcbiAgICAgIFwiZG9jXCI6IFwiU2NhbGVzIHRoZSBvcmlnaW5hbCBzaXplIG9mIHRoZSBpY29uIGJ5IHRoZSBwcm92aWRlZCBmYWN0b3IuIFRoZSBuZXcgcGl4ZWwgc2l6ZSBvZiB0aGUgaW1hZ2Ugd2lsbCBiZSB0aGUgb3JpZ2luYWwgcGl4ZWwgc2l6ZSBtdWx0aXBsaWVkIGJ5IGBpY29uLXNpemVgLiAxIGlzIHRoZSBvcmlnaW5hbCBzaXplOyAzIHRyaXBsZXMgdGhlIHNpemUgb2YgdGhlIGltYWdlLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgICBdLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAgXCJqc1wiOiBcIjAuMTAuMFwiLFxuICAgICAgICAgIFwiYW5kcm9pZFwiOiBcIjIuMC4xXCIsXG4gICAgICAgICAgXCJpb3NcIjogXCIyLjAuMFwiLFxuICAgICAgICAgIFwibWFjb3NcIjogXCIwLjEuMFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG4gICAgICAgICAgXCJqc1wiOiBcIjAuMzUuMFwiLFxuICAgICAgICAgIFwiYW5kcm9pZFwiOiBcIjUuMS4wXCIsXG4gICAgICAgICAgXCJpb3NcIjogXCIzLjYuMFwiLFxuICAgICAgICAgIFwibWFjb3NcIjogXCIwLjUuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiaWNvbi10ZXh0LWZpdFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInpvb20tZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidmFsdWVzXCI6IHtcbiAgICAgICAgXCJub25lXCI6IHtcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIGljb24gaXMgZGlzcGxheWVkIGF0IGl0cyBpbnRyaW5zaWMgYXNwZWN0IHJhdGlvLlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwid2lkdGhcIjoge1xuICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgaWNvbiBpcyBzY2FsZWQgaW4gdGhlIHgtZGltZW5zaW9uIHRvIGZpdCB0aGUgd2lkdGggb2YgdGhlIHRleHQuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJoZWlnaHRcIjoge1xuICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgaWNvbiBpcyBzY2FsZWQgaW4gdGhlIHktZGltZW5zaW9uIHRvIGZpdCB0aGUgaGVpZ2h0IG9mIHRoZSB0ZXh0LlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiYm90aFwiOiB7XG4gICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBpY29uIGlzIHNjYWxlZCBpbiBib3RoIHgtIGFuZCB5LWRpbWVuc2lvbnMuXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcIm5vbmVcIixcbiAgICAgIFwiZG9jXCI6IFwiU2NhbGVzIHRoZSBpY29uIHRvIGZpdCBhcm91bmQgdGhlIGFzc29jaWF0ZWQgdGV4dC5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImljb24taW1hZ2VcIixcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF0sXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4yMS4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiNC4yLjBcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjMuNC4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuMi4xXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHt9XG4gICAgICB9XG4gICAgfSxcbiAgICBcImljb24tdGV4dC1maXQtcGFkZGluZ1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJ2YWx1ZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJsZW5ndGhcIjogNCxcbiAgICAgIFwiZGVmYXVsdFwiOiBbXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDBcbiAgICAgIF0sXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInpvb20tZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiU2l6ZSBvZiB0aGUgYWRkaXRpb25hbCBhcmVhIGFkZGVkIHRvIGRpbWVuc2lvbnMgZGV0ZXJtaW5lZCBieSBgaWNvbi10ZXh0LWZpdGAsIGluIGNsb2Nrd2lzZSBvcmRlcjogdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0LlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiLFxuICAgICAgICBcInRleHQtZmllbGRcIixcbiAgICAgICAge1xuICAgICAgICAgIFwiaWNvbi10ZXh0LWZpdFwiOiBbXG4gICAgICAgICAgICBcImJvdGhcIixcbiAgICAgICAgICAgIFwid2lkdGhcIixcbiAgICAgICAgICAgIFwiaGVpZ2h0XCJcbiAgICAgICAgICBdXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4yMS4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiNC4yLjBcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjMuNC4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuMi4xXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHt9XG4gICAgICB9XG4gICAgfSxcbiAgICBcImljb24taW1hZ2VcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInpvb20tZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwicHJvcGVydHktZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiTmFtZSBvZiBpbWFnZSBpbiBzcHJpdGUgdG8gdXNlIGZvciBkcmF3aW5nIGFuIGltYWdlIGJhY2tncm91bmQuIEEgc3RyaW5nIHdpdGggYHt0b2tlbnN9YCByZXBsYWNlZCwgcmVmZXJlbmNpbmcgdGhlIGRhdGEgcHJvcGVydHkgdG8gcHVsbCBmcm9tLiAoYHt0b2tlbn1gIHJlcGxhY2VtZW50IGlzIG9ubHkgc3VwcG9ydGVkIGZvciBsaXRlcmFsIGBpY29uLWltYWdlYCB2YWx1ZXM7IG5vdCBmb3IgcHJvcGVydHkgZnVuY3Rpb25zLilcIixcbiAgICAgIFwidG9rZW5zXCI6IHRydWUsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4xMC4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiMi4wLjFcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjIuMC4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuMS4wXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4zNS4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiNS4xLjBcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjMuNi4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuNS4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJpY29uLXJvdGF0ZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJwZXJpb2RcIjogMzYwLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ6b29tLWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInByb3BlcnR5LWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInVuaXRzXCI6IFwiZGVncmVlc1wiLFxuICAgICAgXCJkb2NcIjogXCJSb3RhdGVzIHRoZSBpY29uIGNsb2Nrd2lzZS5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImljb24taW1hZ2VcIlxuICAgICAgXSxcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjEwLjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCIyLjAuMVwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMi4wLjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC4xLjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjIxLjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCI1LjAuMFwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMy41LjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC40LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcImljb24tcGFkZGluZ1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAyLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInpvb20tZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidW5pdHNcIjogXCJwaXhlbHNcIixcbiAgICAgIFwiZG9jXCI6IFwiU2l6ZSBvZiB0aGUgYWRkaXRpb25hbCBhcmVhIGFyb3VuZCB0aGUgaWNvbiBib3VuZGluZyBib3ggdXNlZCBmb3IgZGV0ZWN0aW5nIHN5bWJvbCBjb2xsaXNpb25zLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgICBdLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAgXCJqc1wiOiBcIjAuMTAuMFwiLFxuICAgICAgICAgIFwiYW5kcm9pZFwiOiBcIjIuMC4xXCIsXG4gICAgICAgICAgXCJpb3NcIjogXCIyLjAuMFwiLFxuICAgICAgICAgIFwibWFjb3NcIjogXCIwLjEuMFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7fVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJpY29uLWtlZXAtdXByaWdodFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInpvb20tZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZSxcbiAgICAgIFwiZG9jXCI6IFwiSWYgdHJ1ZSwgdGhlIGljb24gbWF5IGJlIGZsaXBwZWQgdG8gcHJldmVudCBpdCBmcm9tIGJlaW5nIHJlbmRlcmVkIHVwc2lkZS1kb3duLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiLFxuICAgICAgICB7XG4gICAgICAgICAgXCJpY29uLXJvdGF0aW9uLWFsaWdubWVudFwiOiBcIm1hcFwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBcInN5bWJvbC1wbGFjZW1lbnRcIjogXCJsaW5lXCJcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjEwLjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCIyLjAuMVwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMi4wLjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC4xLjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge31cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiaWNvbi1vZmZzZXRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwidmFsdWVcIjogXCJudW1iZXJcIixcbiAgICAgIFwibGVuZ3RoXCI6IDIsXG4gICAgICBcImRlZmF1bHRcIjogW1xuICAgICAgICAwLFxuICAgICAgICAwXG4gICAgICBdLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ6b29tLWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInByb3BlcnR5LWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcImRvY1wiOiBcIk9mZnNldCBkaXN0YW5jZSBvZiBpY29uIGZyb20gaXRzIGFuY2hvci4gUG9zaXRpdmUgdmFsdWVzIGluZGljYXRlIHJpZ2h0IGFuZCBkb3duLCB3aGlsZSBuZWdhdGl2ZSB2YWx1ZXMgaW5kaWNhdGUgbGVmdCBhbmQgdXAuIFdoZW4gY29tYmluZWQgd2l0aCBgaWNvbi1yb3RhdGVgIHRoZSBvZmZzZXQgd2lsbCBiZSBhcyBpZiB0aGUgcm90YXRlZCBkaXJlY3Rpb24gd2FzIHVwLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgICBdLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAgXCJqc1wiOiBcIjAuMTAuMFwiLFxuICAgICAgICAgIFwiYW5kcm9pZFwiOiBcIjIuMC4xXCIsXG4gICAgICAgICAgXCJpb3NcIjogXCIyLjAuMFwiLFxuICAgICAgICAgIFwibWFjb3NcIjogXCIwLjEuMFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG4gICAgICAgICAgXCJqc1wiOiBcIjAuMjkuMFwiLFxuICAgICAgICAgIFwiYW5kcm9pZFwiOiBcIjUuMC4wXCIsXG4gICAgICAgICAgXCJpb3NcIjogXCIzLjUuMFwiLFxuICAgICAgICAgIFwibWFjb3NcIjogXCIwLjQuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiaWNvbi1hbmNob3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ6b29tLWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInByb3BlcnR5LWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInZhbHVlc1wiOiB7XG4gICAgICAgIFwiY2VudGVyXCI6IHtcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIGNlbnRlciBvZiB0aGUgaWNvbiBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibGVmdFwiOiB7XG4gICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBsZWZ0IHNpZGUgb2YgdGhlIGljb24gaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuICAgICAgICB9LFxuICAgICAgICBcInJpZ2h0XCI6IHtcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGljb24gaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuICAgICAgICB9LFxuICAgICAgICBcInRvcFwiOiB7XG4gICAgICAgICAgICBcImRvY1wiOiBcIlRoZSB0b3Agb2YgdGhlIGljb24gaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuICAgICAgICB9LFxuICAgICAgICBcImJvdHRvbVwiOiB7XG4gICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBib3R0b20gb2YgdGhlIGljb24gaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuICAgICAgICB9LFxuICAgICAgICBcInRvcC1sZWZ0XCI6IHtcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgaWNvbiBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwidG9wLXJpZ2h0XCI6IHtcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIHRvcCByaWdodCBjb3JuZXIgb2YgdGhlIGljb24gaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuICAgICAgICB9LFxuICAgICAgICBcImJvdHRvbS1sZWZ0XCI6IHtcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIGJvdHRvbSBsZWZ0IGNvcm5lciBvZiB0aGUgaWNvbiBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiYm90dG9tLXJpZ2h0XCI6IHtcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIGJvdHRvbSByaWdodCBjb3JuZXIgb2YgdGhlIGljb24gaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJkZWZhdWx0XCI6IFwiY2VudGVyXCIsXG4gICAgICBcImRvY1wiOiBcIlBhcnQgb2YgdGhlIGljb24gcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImljb24taW1hZ2VcIlxuICAgICAgXSxcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjQwLjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjQwLjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcImljb24tcGl0Y2gtYWxpZ25tZW50XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwiem9vbS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ2YWx1ZXNcIjoge1xuICAgICAgICBcIm1hcFwiOiB7XG4gICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBpY29uIGlzIGFsaWduZWQgdG8gdGhlIHBsYW5lIG9mIHRoZSBtYXAuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJ2aWV3cG9ydFwiOiB7XG4gICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBpY29uIGlzIGFsaWduZWQgdG8gdGhlIHBsYW5lIG9mIHRoZSB2aWV3cG9ydC5cIlxuICAgICAgICB9LFxuICAgICAgICBcImF1dG9cIjoge1xuICAgICAgICAgICAgXCJkb2NcIjogXCJBdXRvbWF0aWNhbGx5IG1hdGNoZXMgdGhlIHZhbHVlIG9mIGBpY29uLXJvdGF0aW9uLWFsaWdubWVudGAuXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcImF1dG9cIixcbiAgICAgIFwiZG9jXCI6IFwiT3JpZW50YXRpb24gb2YgaWNvbiB3aGVuIG1hcCBpcyBwaXRjaGVkLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgICBdLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAgXCJqc1wiOiBcIjAuMzkuMFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7fVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJ0ZXh0LXBpdGNoLWFsaWdubWVudFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInpvb20tZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidmFsdWVzXCI6IHtcbiAgICAgICAgXCJtYXBcIjoge1xuICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgdGV4dCBpcyBhbGlnbmVkIHRvIHRoZSBwbGFuZSBvZiB0aGUgbWFwLlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwidmlld3BvcnRcIjoge1xuICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgdGV4dCBpcyBhbGlnbmVkIHRvIHRoZSBwbGFuZSBvZiB0aGUgdmlld3BvcnQuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJhdXRvXCI6IHtcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiQXV0b21hdGljYWxseSBtYXRjaGVzIHRoZSB2YWx1ZSBvZiBgdGV4dC1yb3RhdGlvbi1hbGlnbm1lbnRgLlwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcImRlZmF1bHRcIjogXCJhdXRvXCIsXG4gICAgICBcImRvY1wiOiBcIk9yaWVudGF0aW9uIG9mIHRleHQgd2hlbiBtYXAgaXMgcGl0Y2hlZC5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXSxcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjIxLjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCI0LjIuMFwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMy40LjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC4yLjFcIlxuICAgICAgICB9LFxuICAgICAgICBcImBhdXRvYCB2YWx1ZVwiOiB7XG4gICAgICAgICAgXCJqc1wiOiBcIjAuMjUuMFwiLFxuICAgICAgICAgIFwiYW5kcm9pZFwiOiBcIjQuMi4wXCIsXG4gICAgICAgICAgXCJpb3NcIjogXCIzLjQuMFwiLFxuICAgICAgICAgIFwibWFjb3NcIjogXCIwLjMuMFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7fVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJ0ZXh0LXJvdGF0aW9uLWFsaWdubWVudFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInpvb20tZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidmFsdWVzXCI6IHtcbiAgICAgICAgXCJtYXBcIjoge1xuICAgICAgICAgICAgXCJkb2NcIjogXCJXaGVuIGBzeW1ib2wtcGxhY2VtZW50YCBpcyBzZXQgdG8gYHBvaW50YCwgYWxpZ25zIHRleHQgZWFzdC13ZXN0LiBXaGVuIGBzeW1ib2wtcGxhY2VtZW50YCBpcyBzZXQgdG8gYGxpbmVgLCBhbGlnbnMgdGV4dCB4LWF4ZXMgd2l0aCB0aGUgbGluZS5cIlxuICAgICAgICB9LFxuICAgICAgICBcInZpZXdwb3J0XCI6IHtcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiUHJvZHVjZXMgZ2x5cGhzIHdob3NlIHgtYXhlcyBhcmUgYWxpZ25lZCB3aXRoIHRoZSB4LWF4aXMgb2YgdGhlIHZpZXdwb3J0LCByZWdhcmRsZXNzIG9mIHRoZSB2YWx1ZSBvZiBgc3ltYm9sLXBsYWNlbWVudGAuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJhdXRvXCI6IHtcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiV2hlbiBgc3ltYm9sLXBsYWNlbWVudGAgaXMgc2V0IHRvIGBwb2ludGAsIHRoaXMgaXMgZXF1aXZhbGVudCB0byBgdmlld3BvcnRgLiBXaGVuIGBzeW1ib2wtcGxhY2VtZW50YCBpcyBzZXQgdG8gYGxpbmVgLCB0aGlzIGlzIGVxdWl2YWxlbnQgdG8gYG1hcGAuXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcImF1dG9cIixcbiAgICAgIFwiZG9jXCI6IFwiSW4gY29tYmluYXRpb24gd2l0aCBgc3ltYm9sLXBsYWNlbWVudGAsIGRldGVybWluZXMgdGhlIHJvdGF0aW9uIGJlaGF2aW9yIG9mIHRoZSBpbmRpdmlkdWFsIGdseXBocyBmb3JtaW5nIHRoZSB0ZXh0LlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAgXCJqc1wiOiBcIjAuMTAuMFwiLFxuICAgICAgICAgIFwiYW5kcm9pZFwiOiBcIjIuMC4xXCIsXG4gICAgICAgICAgXCJpb3NcIjogXCIyLjAuMFwiLFxuICAgICAgICAgIFwibWFjb3NcIjogXCIwLjEuMFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiYGF1dG9gIHZhbHVlXCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4yNS4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiNC4yLjBcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjMuNC4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuMy4wXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHt9XG4gICAgICB9XG4gICAgfSxcbiAgICBcInRleHQtZmllbGRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInpvb20tZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwicHJvcGVydHktZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcIlwiLFxuICAgICAgXCJ0b2tlbnNcIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiVmFsdWUgdG8gdXNlIGZvciBhIHRleHQgbGFiZWwuIEZlYXR1cmUgcHJvcGVydGllcyBhcmUgc3BlY2lmaWVkIHVzaW5nIHRva2VucyBsaWtlIGB7ZmllbGRfbmFtZX1gLiAoYHt0b2tlbn1gIHJlcGxhY2VtZW50IGlzIG9ubHkgc3VwcG9ydGVkIGZvciBsaXRlcmFsIGB0ZXh0LWZpZWxkYCB2YWx1ZXM7IG5vdCBmb3IgcHJvcGVydHkgZnVuY3Rpb25zLilcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjEwLjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCIyLjAuMVwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMi4wLjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC4xLjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjMzLjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCI1LjAuMFwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMy41LjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC40LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcInRleHQtZm9udFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJ2YWx1ZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ6b29tLWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcImRlZmF1bHRcIjogW1wiT3BlbiBTYW5zIFJlZ3VsYXJcIiwgXCJBcmlhbCBVbmljb2RlIE1TIFJlZ3VsYXJcIl0sXG4gICAgICBcImRvY1wiOiBcIkZvbnQgc3RhY2sgdG8gdXNlIGZvciBkaXNwbGF5aW5nIHRleHQuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF0sXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4xMC4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiMi4wLjFcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjIuMC4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuMS4wXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHt9XG4gICAgICB9XG4gICAgfSxcbiAgICBcInRleHQtc2l6ZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAxNixcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ6b29tLWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInByb3BlcnR5LWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcImRvY1wiOiBcIkZvbnQgc2l6ZS5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXSxcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjEwLjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCIyLjAuMVwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMi4wLjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC4xLjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjM1LjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCI1LjEuMFwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMy42LjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC41LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcInRleHQtbWF4LXdpZHRoXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEwLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcInVuaXRzXCI6IFwiZW1zXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInpvb20tZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwicHJvcGVydHktZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiVGhlIG1heGltdW0gbGluZSB3aWR0aCBmb3IgdGV4dCB3cmFwcGluZy5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXSxcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjEwLjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCIyLjAuMVwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMi4wLjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC4xLjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICAgICAgXCJqc1wiOiBcIjAuNDAuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwidGV4dC1saW5lLWhlaWdodFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAxLjIsXG4gICAgICBcInVuaXRzXCI6IFwiZW1zXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInpvb20tZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiVGV4dCBsZWFkaW5nIHZhbHVlIGZvciBtdWx0aS1saW5lIHRleHQuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF0sXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4xMC4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiMi4wLjFcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjIuMC4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuMS4wXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHt9XG4gICAgICB9XG4gICAgfSxcbiAgICBcInRleHQtbGV0dGVyLXNwYWNpbmdcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwidW5pdHNcIjogXCJlbXNcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiem9vbS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJwcm9wZXJ0eS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJUZXh0IHRyYWNraW5nIGFtb3VudC5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXSxcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjEwLjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCIyLjAuMVwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMi4wLjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC4xLjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICAgICAgXCJqc1wiOiBcIjAuNDAuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwidGV4dC1qdXN0aWZ5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwiem9vbS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJwcm9wZXJ0eS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ2YWx1ZXNcIjoge1xuICAgICAgICBcImxlZnRcIjoge1xuICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgdGV4dCBpcyBhbGlnbmVkIHRvIHRoZSBsZWZ0LlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY2VudGVyXCI6IHtcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIHRleHQgaXMgY2VudGVyZWQuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJyaWdodFwiOiB7XG4gICAgICAgICAgICBcImRvY1wiOiBcIlRoZSB0ZXh0IGlzIGFsaWduZWQgdG8gdGhlIHJpZ2h0LlwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcImRlZmF1bHRcIjogXCJjZW50ZXJcIixcbiAgICAgIFwiZG9jXCI6IFwiVGV4dCBqdXN0aWZpY2F0aW9uIG9wdGlvbnMuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF0sXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4xMC4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiMi4wLjFcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjIuMC4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuMS4wXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAgICAgIFwianNcIjogXCIwLjM5LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcInRleHQtYW5jaG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwiem9vbS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJwcm9wZXJ0eS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ2YWx1ZXNcIjoge1xuICAgICAgICBcImNlbnRlclwiOiB7XG4gICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBjZW50ZXIgb2YgdGhlIHRleHQgaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuICAgICAgICB9LFxuICAgICAgICBcImxlZnRcIjoge1xuICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgbGVmdCBzaWRlIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJyaWdodFwiOiB7XG4gICAgICAgICAgICBcImRvY1wiOiBcIlRoZSByaWdodCBzaWRlIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0b3BcIjoge1xuICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgdG9wIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJib3R0b21cIjoge1xuICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgYm90dG9tIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0b3AtbGVmdFwiOiB7XG4gICAgICAgICAgICBcImRvY1wiOiBcIlRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHRleHQgaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuICAgICAgICB9LFxuICAgICAgICBcInRvcC1yaWdodFwiOiB7XG4gICAgICAgICAgICBcImRvY1wiOiBcIlRoZSB0b3AgcmlnaHQgY29ybmVyIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJib3R0b20tbGVmdFwiOiB7XG4gICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBib3R0b20gbGVmdCBjb3JuZXIgb2YgdGhlIHRleHQgaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuICAgICAgICB9LFxuICAgICAgICBcImJvdHRvbS1yaWdodFwiOiB7XG4gICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcImNlbnRlclwiLFxuICAgICAgXCJkb2NcIjogXCJQYXJ0IG9mIHRoZSB0ZXh0IHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF0sXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4xMC4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiMi4wLjFcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjIuMC4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuMS4wXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAgICAgIFwianNcIjogXCIwLjM5LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcInRleHQtbWF4LWFuZ2xlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDQ1LFxuICAgICAgXCJ1bml0c1wiOiBcImRlZ3JlZXNcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiem9vbS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJNYXhpbXVtIGFuZ2xlIGNoYW5nZSBiZXR3ZWVuIGFkamFjZW50IGNoYXJhY3RlcnMuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCIsXG4gICAgICAgIHtcbiAgICAgICAgICBcInN5bWJvbC1wbGFjZW1lbnRcIjogXCJsaW5lXCJcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjEwLjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCIyLjAuMVwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMi4wLjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC4xLjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge31cbiAgICAgIH1cbiAgICB9LFxuICAgIFwidGV4dC1yb3RhdGVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwicGVyaW9kXCI6IDM2MCxcbiAgICAgIFwidW5pdHNcIjogXCJkZWdyZWVzXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInpvb20tZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwicHJvcGVydHktZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiUm90YXRlcyB0aGUgdGV4dCBjbG9ja3dpc2UuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF0sXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4xMC4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiMi4wLjFcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjIuMC4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuMS4wXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4zNS4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiNS4xLjBcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjMuNi4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuNS4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJ0ZXh0LXBhZGRpbmdcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMixcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ6b29tLWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcImRvY1wiOiBcIlNpemUgb2YgdGhlIGFkZGl0aW9uYWwgYXJlYSBhcm91bmQgdGhlIHRleHQgYm91bmRpbmcgYm94IHVzZWQgZm9yIGRldGVjdGluZyBzeW1ib2wgY29sbGlzaW9ucy5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXSxcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjEwLjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCIyLjAuMVwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMi4wLjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC4xLjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge31cbiAgICAgIH1cbiAgICB9LFxuICAgIFwidGV4dC1rZWVwLXVwcmlnaHRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ6b29tLWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcImRlZmF1bHRcIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiSWYgdHJ1ZSwgdGhlIHRleHQgbWF5IGJlIGZsaXBwZWQgdmVydGljYWxseSB0byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgcmVuZGVyZWQgdXBzaWRlLWRvd24uXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCIsXG4gICAgICAgIHtcbiAgICAgICAgICBcInRleHQtcm90YXRpb24tYWxpZ25tZW50XCI6IFwibWFwXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIFwic3ltYm9sLXBsYWNlbWVudFwiOiBcImxpbmVcIlxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAgXCJqc1wiOiBcIjAuMTAuMFwiLFxuICAgICAgICAgIFwiYW5kcm9pZFwiOiBcIjIuMC4xXCIsXG4gICAgICAgICAgXCJpb3NcIjogXCIyLjAuMFwiLFxuICAgICAgICAgIFwibWFjb3NcIjogXCIwLjEuMFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7fVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJ0ZXh0LXRyYW5zZm9ybVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInpvb20tZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwicHJvcGVydHktZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidmFsdWVzXCI6IHtcbiAgICAgICAgXCJub25lXCI6IHtcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIHRleHQgaXMgbm90IGFsdGVyZWQuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJ1cHBlcmNhc2VcIjoge1xuICAgICAgICAgICAgXCJkb2NcIjogXCJGb3JjZXMgYWxsIGxldHRlcnMgdG8gYmUgZGlzcGxheWVkIGluIHVwcGVyY2FzZS5cIlxuICAgICAgICB9LFxuICAgICAgICBcImxvd2VyY2FzZVwiOiB7XG4gICAgICAgICAgICBcImRvY1wiOiBcIkZvcmNlcyBhbGwgbGV0dGVycyB0byBiZSBkaXNwbGF5ZWQgaW4gbG93ZXJjYXNlLlwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcImRlZmF1bHRcIjogXCJub25lXCIsXG4gICAgICBcImRvY1wiOiBcIlNwZWNpZmllcyBob3cgdG8gY2FwaXRhbGl6ZSB0ZXh0LCBzaW1pbGFyIHRvIHRoZSBDU1MgYHRleHQtdHJhbnNmb3JtYCBwcm9wZXJ0eS5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXSxcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjEwLjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCIyLjAuMVwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMi4wLjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC4xLjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjMzLjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCI1LjAuMFwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMy41LjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC40LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcInRleHQtb2Zmc2V0XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcImRvY1wiOiBcIk9mZnNldCBkaXN0YW5jZSBvZiB0ZXh0IGZyb20gaXRzIGFuY2hvci4gUG9zaXRpdmUgdmFsdWVzIGluZGljYXRlIHJpZ2h0IGFuZCBkb3duLCB3aGlsZSBuZWdhdGl2ZSB2YWx1ZXMgaW5kaWNhdGUgbGVmdCBhbmQgdXAuXCIsXG4gICAgICBcInZhbHVlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcInVuaXRzXCI6IFwiZW1zXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInpvb20tZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwicHJvcGVydHktZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwibGVuZ3RoXCI6IDIsXG4gICAgICBcImRlZmF1bHRcIjogW1xuICAgICAgICAwLFxuICAgICAgICAwXG4gICAgICBdLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAgXCJqc1wiOiBcIjAuMTAuMFwiLFxuICAgICAgICAgIFwiYW5kcm9pZFwiOiBcIjIuMC4xXCIsXG4gICAgICAgICAgXCJpb3NcIjogXCIyLjAuMFwiLFxuICAgICAgICAgIFwibWFjb3NcIjogXCIwLjEuMFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG4gICAgICAgICAgXCJqc1wiOiBcIjAuMzUuMFwiLFxuICAgICAgICAgIFwiYW5kcm9pZFwiOiBcIjUuMS4wXCIsXG4gICAgICAgICAgXCJpb3NcIjogXCIzLjYuMFwiLFxuICAgICAgICAgIFwibWFjb3NcIjogXCIwLjUuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwidGV4dC1hbGxvdy1vdmVybGFwXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwiem9vbS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJkZWZhdWx0XCI6IGZhbHNlLFxuICAgICAgXCJkb2NcIjogXCJJZiB0cnVlLCB0aGUgdGV4dCB3aWxsIGJlIHZpc2libGUgZXZlbiBpZiBpdCBjb2xsaWRlcyB3aXRoIG90aGVyIHByZXZpb3VzbHkgZHJhd24gc3ltYm9scy5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXSxcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjEwLjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCIyLjAuMVwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMi4wLjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC4xLjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge31cbiAgICAgIH1cbiAgICB9LFxuICAgIFwidGV4dC1pZ25vcmUtcGxhY2VtZW50XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwiem9vbS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJkZWZhdWx0XCI6IGZhbHNlLFxuICAgICAgXCJkb2NcIjogXCJJZiB0cnVlLCBvdGhlciBzeW1ib2xzIGNhbiBiZSB2aXNpYmxlIGV2ZW4gaWYgdGhleSBjb2xsaWRlIHdpdGggdGhlIHRleHQuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF0sXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4xMC4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiMi4wLjFcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjIuMC4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuMS4wXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHt9XG4gICAgICB9XG4gICAgfSxcbiAgICBcInRleHQtb3B0aW9uYWxcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ6b29tLWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcImRlZmF1bHRcIjogZmFsc2UsXG4gICAgICBcImRvY1wiOiBcIklmIHRydWUsIGljb25zIHdpbGwgZGlzcGxheSB3aXRob3V0IHRoZWlyIGNvcnJlc3BvbmRpbmcgdGV4dCB3aGVuIHRoZSB0ZXh0IGNvbGxpZGVzIHdpdGggb3RoZXIgc3ltYm9scyBhbmQgdGhlIGljb24gZG9lcyBub3QuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCIsXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgICBdLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAgXCJqc1wiOiBcIjAuMTAuMFwiLFxuICAgICAgICAgIFwiYW5kcm9pZFwiOiBcIjIuMC4xXCIsXG4gICAgICAgICAgXCJpb3NcIjogXCIyLjAuMFwiLFxuICAgICAgICAgIFwibWFjb3NcIjogXCIwLjEuMFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7fVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJ2aXNpYmlsaXR5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwidmFsdWVzXCI6IHtcbiAgICAgICAgXCJ2aXNpYmxlXCI6IHtcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIGxheWVyIGlzIHNob3duLlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibm9uZVwiOiB7XG4gICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBsYXllciBpcyBub3Qgc2hvd24uXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcInZpc2libGVcIixcbiAgICAgIFwiZG9jXCI6IFwiV2hldGhlciB0aGlzIGxheWVyIGlzIGRpc3BsYXllZC5cIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjEwLjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCIyLjAuMVwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMi4wLjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC4xLjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge31cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIFwibGF5b3V0X3Jhc3RlclwiOiB7XG4gICAgXCJ2aXNpYmlsaXR5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwidmFsdWVzXCI6IHtcbiAgICAgICAgXCJ2aXNpYmxlXCI6IHtcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIGxheWVyIGlzIHNob3duLlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibm9uZVwiOiB7XG4gICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBsYXllciBpcyBub3Qgc2hvd24uXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcInZpc2libGVcIixcbiAgICAgIFwiZG9jXCI6IFwiV2hldGhlciB0aGlzIGxheWVyIGlzIGRpc3BsYXllZC5cIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjEwLjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCIyLjAuMVwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMi4wLjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC4xLjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge31cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIFwiZmlsdGVyXCI6IHtcbiAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgIFwidmFsdWVcIjogXCIqXCIsXG4gICAgXCJkb2NcIjogXCJBIGZpbHRlciBzZWxlY3RzIHNwZWNpZmljIGZlYXR1cmVzIGZyb20gYSBsYXllci5cIlxuICB9LFxuICBcImZpbHRlcl9vcGVyYXRvclwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgIFwidmFsdWVzXCI6IHtcbiAgICAgIFwiPT1cIjoge1xuICAgICAgICAgIFwiZG9jXCI6IFwiYFtcXFwiPT1cXFwiLCBrZXksIHZhbHVlXWAgZXF1YWxpdHk6IGBmZWF0dXJlW2tleV0gPSB2YWx1ZWBcIlxuICAgICAgfSxcbiAgICAgIFwiIT1cIjoge1xuICAgICAgICAgIFwiZG9jXCI6IFwiYFtcXFwiIT1cXFwiLCBrZXksIHZhbHVlXWAgaW5lcXVhbGl0eTogYGZlYXR1cmVba2V5XSDiiaAgdmFsdWVgXCJcbiAgICAgIH0sXG4gICAgICBcIj5cIjoge1xuICAgICAgICAgIFwiZG9jXCI6IFwiYFtcXFwiPlxcXCIsIGtleSwgdmFsdWVdYCBncmVhdGVyIHRoYW46IGBmZWF0dXJlW2tleV0gPiB2YWx1ZWBcIlxuICAgICAgfSxcbiAgICAgIFwiPj1cIjoge1xuICAgICAgICAgIFwiZG9jXCI6IFwiYFtcXFwiPj1cXFwiLCBrZXksIHZhbHVlXWAgZ3JlYXRlciB0aGFuIG9yIGVxdWFsOiBgZmVhdHVyZVtrZXldIOKJpSB2YWx1ZWBcIlxuICAgICAgfSxcbiAgICAgIFwiPFwiOiB7XG4gICAgICAgICAgXCJkb2NcIjogXCJgW1xcXCI8XFxcIiwga2V5LCB2YWx1ZV1gIGxlc3MgdGhhbjogYGZlYXR1cmVba2V5XSA8IHZhbHVlYFwiXG4gICAgICB9LFxuICAgICAgXCI8PVwiOiB7XG4gICAgICAgICAgXCJkb2NcIjogXCJgW1xcXCI8PVxcXCIsIGtleSwgdmFsdWVdYCBsZXNzIHRoYW4gb3IgZXF1YWw6IGBmZWF0dXJlW2tleV0g4omkIHZhbHVlYFwiXG4gICAgICB9LFxuICAgICAgXCJpblwiOiB7XG4gICAgICAgICAgXCJkb2NcIjogXCJgW1xcXCJpblxcXCIsIGtleSwgdjAsIC4uLiwgdm5dYCBzZXQgaW5jbHVzaW9uOiBgZmVhdHVyZVtrZXldIOKIiCB7djAsIC4uLiwgdm59YFwiXG4gICAgICB9LFxuICAgICAgXCIhaW5cIjoge1xuICAgICAgICAgIFwiZG9jXCI6IFwiYFtcXFwiIWluXFxcIiwga2V5LCB2MCwgLi4uLCB2bl1gIHNldCBleGNsdXNpb246IGBmZWF0dXJlW2tleV0g4oiJIHt2MCwgLi4uLCB2bn1gXCJcbiAgICAgIH0sXG4gICAgICBcImFsbFwiOiB7XG4gICAgICAgICAgXCJkb2NcIjogXCJgW1xcXCJhbGxcXFwiLCBmMCwgLi4uLCBmbl1gIGxvZ2ljYWwgYEFORGA6IGBmMCDiiKcgLi4uIOKIpyBmbmBcIlxuICAgICAgfSxcbiAgICAgIFwiYW55XCI6IHtcbiAgICAgICAgICBcImRvY1wiOiBcImBbXFxcImFueVxcXCIsIGYwLCAuLi4sIGZuXWAgbG9naWNhbCBgT1JgOiBgZjAg4oioIC4uLiDiiKggZm5gXCJcbiAgICAgIH0sXG4gICAgICBcIm5vbmVcIjoge1xuICAgICAgICAgIFwiZG9jXCI6IFwiYFtcXFwibm9uZVxcXCIsIGYwLCAuLi4sIGZuXWAgbG9naWNhbCBgTk9SYDogYMKsZjAg4oinIC4uLiDiiKcgwqxmbmBcIlxuICAgICAgfSxcbiAgICAgIFwiaGFzXCI6IHtcbiAgICAgICAgICBcImRvY1wiOiBcImBbXFxcImhhc1xcXCIsIGtleV1gIGBmZWF0dXJlW2tleV1gIGV4aXN0c1wiXG4gICAgICB9LFxuICAgICAgXCIhaGFzXCI6IHtcbiAgICAgICAgICBcImRvY1wiOiBcImBbXFxcIiFoYXNcXFwiLCBrZXldYCBgZmVhdHVyZVtrZXldYCBkb2VzIG5vdCBleGlzdFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcImRvY1wiOiBcIlRoZSBmaWx0ZXIgb3BlcmF0b3IuXCJcbiAgfSxcbiAgXCJnZW9tZXRyeV90eXBlXCI6IHtcbiAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgXCJ2YWx1ZXNcIjoge1xuICAgICAgXCJQb2ludFwiOiB7XG4gICAgICAgICAgXCJkb2NcIjogXCJGaWx0ZXIgdG8gcG9pbnQgZ2VvbWV0cmllcy5cIlxuICAgICAgfSxcbiAgICAgIFwiTGluZVN0cmluZ1wiOiB7XG4gICAgICAgICAgXCJkb2NcIjogXCJGaWx0ZXIgdG8gbGluZSBnZW9tZXRyaWVzLlwiXG4gICAgICB9LFxuICAgICAgXCJQb2x5Z29uXCI6IHtcbiAgICAgICAgICBcImRvY1wiOiBcIkZpbHRlciB0byBwb2x5Z29uIGdlb21ldHJpZXMuXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiZG9jXCI6IFwiVGhlIGdlb21ldHJ5IHR5cGUgZm9yIHRoZSBmaWx0ZXIgdG8gc2VsZWN0LlwiXG4gIH0sXG4gIFwiZnVuY3Rpb25cIjoge1xuICAgIFwiZXhwcmVzc2lvblwiOiB7XG4gICAgICBcInR5cGVcIjogXCJleHByZXNzaW9uXCIsXG4gICAgICBcImRvY1wiOiBcIkFuIGV4cHJlc3Npb24uXCJcbiAgICB9LFxuICAgIFwic3RvcHNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwiZG9jXCI6IFwiQW4gYXJyYXkgb2Ygc3RvcHMuXCIsXG4gICAgICBcInZhbHVlXCI6IFwiZnVuY3Rpb25fc3RvcFwiXG4gICAgfSxcbiAgICBcImJhc2VcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMSxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJkb2NcIjogXCJUaGUgZXhwb25lbnRpYWwgYmFzZSBvZiB0aGUgaW50ZXJwb2xhdGlvbiBjdXJ2ZS4gSXQgY29udHJvbHMgdGhlIHJhdGUgYXQgd2hpY2ggdGhlIHJlc3VsdCBpbmNyZWFzZXMuIEhpZ2hlciB2YWx1ZXMgbWFrZSB0aGUgcmVzdWx0IGluY3JlYXNlIG1vcmUgdG93YXJkcyB0aGUgaGlnaCBlbmQgb2YgdGhlIHJhbmdlLiBXaXRoIGAxYCB0aGUgc3RvcHMgYXJlIGludGVycG9sYXRlZCBsaW5lYXJseS5cIlxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIG5hbWUgb2YgYSBmZWF0dXJlIHByb3BlcnR5IHRvIHVzZSBhcyB0aGUgZnVuY3Rpb24gaW5wdXQuXCIsXG4gICAgICBcImRlZmF1bHRcIjogXCIkem9vbVwiXG4gICAgfSxcbiAgICBcInR5cGVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJ2YWx1ZXNcIjoge1xuICAgICAgICAgIFwiaWRlbnRpdHlcIjoge1xuICAgICAgICAgICAgICBcImRvY1wiOiBcIlJldHVybiB0aGUgaW5wdXQgdmFsdWUgYXMgdGhlIG91dHB1dCB2YWx1ZS5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJleHBvbmVudGlhbFwiOiB7XG4gICAgICAgICAgICAgIFwiZG9jXCI6IFwiR2VuZXJhdGUgYW4gb3V0cHV0IGJ5IGludGVycG9sYXRpbmcgYmV0d2VlbiBzdG9wcyBqdXN0IGxlc3MgdGhhbiBhbmQganVzdCBncmVhdGVyIHRoYW4gdGhlIGZ1bmN0aW9uIGlucHV0LlwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImludGVydmFsXCI6IHtcbiAgICAgICAgICAgICAgXCJkb2NcIjogXCJSZXR1cm4gdGhlIG91dHB1dCB2YWx1ZSBvZiB0aGUgc3RvcCBqdXN0IGxlc3MgdGhhbiB0aGUgZnVuY3Rpb24gaW5wdXQuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiY2F0ZWdvcmljYWxcIjoge1xuICAgICAgICAgICAgICBcImRvY1wiOiBcIlJldHVybiB0aGUgb3V0cHV0IHZhbHVlIG9mIHRoZSBzdG9wIGVxdWFsIHRvIHRoZSBmdW5jdGlvbiBpbnB1dC5cIlxuICAgICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcImRvY1wiOiBcIlRoZSBpbnRlcnBvbGF0aW9uIHN0cmF0ZWd5IHRvIHVzZSBpbiBmdW5jdGlvbiBldmFsdWF0aW9uLlwiLFxuICAgICAgXCJkZWZhdWx0XCI6IFwiZXhwb25lbnRpYWxcIlxuICAgIH0sXG4gICAgXCJjb2xvclNwYWNlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwidmFsdWVzXCI6IHtcbiAgICAgICAgICBcInJnYlwiOiB7XG4gICAgICAgICAgICAgIFwiZG9jXCI6IFwiVXNlIHRoZSBSR0IgY29sb3Igc3BhY2UgdG8gaW50ZXJwb2xhdGUgY29sb3IgdmFsdWVzXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwibGFiXCI6IHtcbiAgICAgICAgICAgICAgXCJkb2NcIjogXCJVc2UgdGhlIExBQiBjb2xvciBzcGFjZSB0byBpbnRlcnBvbGF0ZSBjb2xvciB2YWx1ZXMuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiaGNsXCI6IHtcbiAgICAgICAgICAgICAgXCJkb2NcIjogXCJVc2UgdGhlIEhDTCBjb2xvciBzcGFjZSB0byBpbnRlcnBvbGF0ZSBjb2xvciB2YWx1ZXMsIGludGVycG9sYXRpbmcgdGhlIEh1ZSwgQ2hyb21hLCBhbmQgTHVtaW5hbmNlIGNoYW5uZWxzIGluZGl2aWR1YWxseS5cIlxuICAgICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcImRvY1wiOiBcIlRoZSBjb2xvciBzcGFjZSBpbiB3aGljaCBjb2xvcnMgaW50ZXJwb2xhdGVkLiBJbnRlcnBvbGF0aW5nIGNvbG9ycyBpbiBwZXJjZXB0dWFsIGNvbG9yIHNwYWNlcyBsaWtlIExBQiBhbmQgSENMIHRlbmQgdG8gcHJvZHVjZSBjb2xvciByYW1wcyB0aGF0IGxvb2sgbW9yZSBjb25zaXN0ZW50IGFuZCBwcm9kdWNlIGNvbG9ycyB0aGF0IGNhbiBiZSBkaWZmZXJlbnRpYXRlZCBtb3JlIGVhc2lseSB0aGFuIHRob3NlIGludGVycG9sYXRlZCBpbiBSR0Igc3BhY2UuXCIsXG4gICAgICBcImRlZmF1bHRcIjogXCJyZ2JcIlxuICAgIH0sXG4gICAgXCJkZWZhdWx0XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIipcIixcbiAgICAgIFwicmVxdWlyZWRcIjogZmFsc2UsXG4gICAgICBcImRvY1wiOiBcIkEgdmFsdWUgdG8gc2VydmUgYXMgYSBmYWxsYmFjayBmdW5jdGlvbiByZXN1bHQgd2hlbiBhIHZhbHVlIGlzbid0IG90aGVyd2lzZSBhdmFpbGFibGUuIEl0IGlzIHVzZWQgaW4gdGhlIGZvbGxvd2luZyBjaXJjdW1zdGFuY2VzOlxcbiogSW4gY2F0ZWdvcmljYWwgZnVuY3Rpb25zLCB3aGVuIHRoZSBmZWF0dXJlIHZhbHVlIGRvZXMgbm90IG1hdGNoIGFueSBvZiB0aGUgc3RvcCBkb21haW4gdmFsdWVzLlxcbiogSW4gcHJvcGVydHkgYW5kIHpvb20tYW5kLXByb3BlcnR5IGZ1bmN0aW9ucywgd2hlbiBhIGZlYXR1cmUgZG9lcyBub3QgY29udGFpbiBhIHZhbHVlIGZvciB0aGUgc3BlY2lmaWVkIHByb3BlcnR5LlxcbiogSW4gaWRlbnRpdHkgZnVuY3Rpb25zLCB3aGVuIHRoZSBmZWF0dXJlIHZhbHVlIGlzIG5vdCB2YWxpZCBmb3IgdGhlIHN0eWxlIHByb3BlcnR5IChmb3IgZXhhbXBsZSwgaWYgdGhlIGZ1bmN0aW9uIGlzIGJlaW5nIHVzZWQgZm9yIGEgYGNpcmNsZS1jb2xvcmAgcHJvcGVydHkgYnV0IHRoZSBmZWF0dXJlIHByb3BlcnR5IHZhbHVlIGlzIG5vdCBhIHN0cmluZyBvciBub3QgYSB2YWxpZCBjb2xvcikuXFxuKiBJbiBpbnRlcnZhbCBvciBleHBvbmVudGlhbCBwcm9wZXJ0eSBhbmQgem9vbS1hbmQtcHJvcGVydHkgZnVuY3Rpb25zLCB3aGVuIHRoZSBmZWF0dXJlIHZhbHVlIGlzIG5vdCBudW1lcmljLlxcbklmIG5vIGRlZmF1bHQgaXMgcHJvdmlkZWQsIHRoZSBzdHlsZSBwcm9wZXJ0eSdzIGRlZmF1bHQgaXMgdXNlZCBpbiB0aGVzZSBjaXJjdW1zdGFuY2VzLlwiXG4gICAgfVxuICB9LFxuICBcImZ1bmN0aW9uX3N0b3BcIjoge1xuICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgXCJtYXhpbXVtXCI6IDIyLFxuICAgIFwidmFsdWVcIjogW1xuICAgICAgXCJudW1iZXJcIixcbiAgICAgIFwiY29sb3JcIlxuICAgIF0sXG4gICAgXCJsZW5ndGhcIjogMixcbiAgICBcImRvY1wiOiBcIlpvb20gbGV2ZWwgYW5kIHZhbHVlIHBhaXIuXCJcbiAgfSxcbiAgXCJleHByZXNzaW9uXCI6IHtcbiAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgIFwidmFsdWVcIjogXCIqXCIsXG4gICAgXCJtaW5pbXVtXCI6IDEsXG4gICAgXCJkb2NcIjogXCJBbiBleHByZXNzaW9uIGRlZmluZXMgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIGZvciBkYXRhLWRyaXZlbiBzdHlsZSBwcm9wZXJ0aWVzIG9yIGZlYXR1cmUgZmlsdGVycy5cIlxuICB9LFxuICBcImV4cHJlc3Npb25fbmFtZVwiOiB7XG4gICAgXCJkb2NcIjogXCJcIixcbiAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgXCJ2YWx1ZXNcIjoge1xuICAgICAgXCJsZXRcIjoge1xuICAgICAgICBcImRvY1wiOiBcIkJpbmRzIGV4cHJlc3Npb25zIHRvIG5hbWVkIHZhcmlhYmxlcywgd2hpY2ggY2FuIHRoZW4gYmUgcmVmZXJlbmNlZCBpbiB0aGUgcmVzdWx0IGV4cHJlc3Npb24gdXNpbmcgW1xcXCJ2YXJcXFwiLCBcXFwidmFyaWFibGVfbmFtZVxcXCJdLlwiLFxuICAgICAgICBcImdyb3VwXCI6IFwiVmFyaWFibGUgYmluZGluZ1wiXG4gICAgICB9LFxuICAgICAgXCJ2YXJcIjoge1xuICAgICAgICBcImRvY1wiOiBcIlJlZmVyZW5jZXMgdmFyaWFibGUgYm91bmQgdXNpbmcgXFxcImxldFxcXCIuXCIsXG4gICAgICAgIFwiZ3JvdXBcIjogXCJWYXJpYWJsZSBiaW5kaW5nXCJcbiAgICAgIH0sXG4gICAgICBcImxpdGVyYWxcIjoge1xuICAgICAgICBcImRvY1wiOiBcIlByb3ZpZGVzIGEgbGl0ZXJhbCBhcnJheSBvciBvYmplY3QgdmFsdWUuXCIsXG4gICAgICAgIFwiZ3JvdXBcIjogXCJUeXBlc1wiXG4gICAgICB9LFxuICAgICAgXCJhcnJheVwiOiB7XG4gICAgICAgIFwiZG9jXCI6IFwiQXNzZXJ0cyB0aGF0IHRoZSBpbnB1dCBpcyBhbiBhcnJheSAob3B0aW5hbGx5IHdpdGggYSBzcGVjaWZpYyBpdGVtIHR5cGUgYW5kIGxlbmd0aCkuXCIsXG4gICAgICAgIFwiZ3JvdXBcIjogXCJUeXBlc1wiXG4gICAgICB9LFxuICAgICAgXCJhdFwiOiB7XG4gICAgICAgIFwiZG9jXCI6IFwiUmV0cmlldmVzIGFuIGl0ZW0gZnJvbSBhbiBhcnJheS5cIixcbiAgICAgICAgXCJncm91cFwiOiBcIkxvb2t1cFwiXG4gICAgICB9LFxuICAgICAgICBcImNhc2VcIjoge1xuICAgICAgICBcImRvY1wiOiBcIllpZWxkcyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IG91dHB1dCBleHByZXNzaW9uIHdob3NlIGNvcnJlc3BvbmRpbmcgdGVzdCBldmFsdWF0ZXMgdG8gdHJ1ZS5cIixcbiAgICAgICAgXCJncm91cFwiOiBcIkRlY2lzaW9uXCJcbiAgICAgIH0sXG4gICAgICBcIm1hdGNoXCI6IHtcbiAgICAgICAgXCJkb2NcIjogXCJZaWVsZHMgdGhlIG91dHB1dCB2YWx1ZSB3aG9zZSBsYWJlbCB2YWx1ZSBtYXRjaGVzIHRoZSBpbnB1dCwgb3IgdGhlIGZhbGxiYWNrIHZhbHVlIGlmIG5vIG1hdGNoIGlzIGZvdW5kLlwiLFxuICAgICAgICBcImdyb3VwXCI6IFwiRGVjaXNpb25cIlxuICAgICAgfSxcbiAgICAgIFwiY29hbGVzY2VcIjoge1xuICAgICAgICBcImRvY1wiOiBcIkV2YWx1YXRlcyBlYWNoIGV4cHJlc3Npb24gaW4gdHVybiB1bnRpbCB0aGUgZmlyc3Qgbm9uLW51bGwgdmFsdWUgaXMgb2J0YWluZWQsIGFuZCByZXR1cm5zIHRoYXQgdmFsdWUuXCIsXG4gICAgICAgIFwiZ3JvdXBcIjogXCJEZWNpc2lvblwiXG4gICAgICB9LFxuICAgICAgXCJjdXJ2ZVwiOiB7XG4gICAgICAgIFwiZG9jXCI6IFwiSW50ZXJwb2xhdGVzIGFuIG91dHB1dCB2YWx1ZSBiYXNlZCBvbiBhIHNldCBvZiBpbnB1dC9vdXRwdXQgcGFpcnMgdXNpbmcgdGhlIHNwZWNpZmllZCBpbnRlcnBvbGF0aW9uIHN0cmF0ZWd5LiBBIHNldCBvZiBvbmUgaW5wdXQgYW5kIG9uZSBvdXRwdXQgdmFsdWUgaXMga25vd24gYXMgYSBcXFwic3RvcC5cXFwiIFN0b3AgaW5wdXRzIG11c3QgYmUgbnVtZXJpYyBsaXRlcmFscyBpbiBzdHJpY3RseSBhc2NlbmRpbmcgb3JkZXIuXFxuXFxuSW50ZXJwb2xhdGlvbiB0eXBlczpcXG4tIGBbXFxcInN0ZXBcXFwiXWA6IHJldHVybnMgdGhlIG91dHB1dCB2YWx1ZSBvZiB0aGUgc3RvcCBqdXN0IGxlc3MgdGhhbiB0aGUgaW5wdXQgLCBvciB0aGUgZmlyc3QgaW5wdXQgaWYgdGhlIGlucHV0IGlzIGxlc3MgdGhhbiB0aGUgZmlyc3Qgc3RvcC5cXG4tIGBbXFxcImxpbmVhclxcXCJdYDogaW50ZXJwb2xhdGVzIGxpbmVhcmx5IGJldHdlZW4gdGhlIHBhaXIgb2Ygc3RvcHMganVzdCBsZXNzIHRoYW4gYW5kIGp1c3QgZ3JlYXRlciB0aGFuIHRoZSBpbnB1dCAuXFxuLSBgW1xcXCJleHBvbmVudGlhbFxcXCIsIGJhc2VdYDogaW50ZXJwb2xhdGVzIGV4cG9uZW50aWFsbHkgYmV0d2VlbiB0aGUgc3RvcHMganVzdCBsZXNzIHRoYW4gYW5kIGp1c3QgZ3JlYXRlciB0aGFuIHRoZSBpbnB1dCAuIGBiYXNlYCBjb250cm9scyB0aGUgcmF0ZSBhdCB3aGljaCB0aGUgb3V0cHV0IGluY3JlYXNlczogaGlnaGVyIHZhbHVlcyBtYWtlIHRoZSBvdXRwdXQgaW5jcmVhc2UgbW9yZSB0b3dhcmRzIHRoZSBoaWdoIGVuZCBvZiB0aGUgcmFuZ2UuIFdpdGggdmFsdWVzIGNsb3NlIHRvIDEgdGhlIG91dHB1dCBpbmNyZWFzZXMgbGluZWFybHkuXFxuLSBgW1xcXCJjdWJpYy1iZXppZXJcXFwiLCB4MSwgeTIsIHgyLCB5Ml1gOiBpbnRlcnBvbGF0ZXMgdXNpbmcgdGhlIGN1YmljIGJlemllciBjdXJ2ZSBkZWZpbmVkIGJ5IHRoZSBnaXZlbiBjb250cm9sIHBvaW50c1xcblxcbk5vdGUgdGhhdCBpbnRlcnBvbGF0aW9uIHR5cGVzIG90aGVyIHRoYXQgXFxcInN0ZXBcXFwiIGFyZSBvbmx5IHN1cHBvcnRlZCB3aGVuIHRoZSBvdXRwdXQgdHlwZSBpcyBgbnVtYmVyYCwgYGFycmF5PG51bWJlcj5gLCBvciBgQ29sb3JgLlwiLFxuICAgICAgICBcImdyb3VwXCI6IFwiUmFtcHMsIHNjYWxlcywgY3VydmVzXCJcbiAgICAgIH0sXG4gICAgICBcImxuMlwiOiB7XG4gICAgICAgIFwiZG9jXCI6IFwiUmV0dXJucyBtYXRoZW1hdGljYWwgY29uc3RhbnQgbG4oMikuXCIsXG4gICAgICAgIFwiZ3JvdXBcIjogXCJNYXRoXCJcbiAgICAgIH0sXG4gICAgICBcInBpXCI6IHtcbiAgICAgICAgXCJkb2NcIjogXCJSZXR1cm5zIHRoZSBtYXRoZW1hdGljYWwgY29uc3RhbnQgcGkuXCIsXG4gICAgICAgIFwiZ3JvdXBcIjogXCJNYXRoXCJcbiAgICAgIH0sXG4gICAgICBcImVcIjoge1xuICAgICAgICBcImRvY1wiOiBcIlJldHVybnMgdGhlIG1hdGhlbWF0aWNhbCBjb25zdGFudCBlLlwiLFxuICAgICAgICBcImdyb3VwXCI6IFwiTWF0aFwiXG4gICAgICB9LFxuICAgICAgXCJ0eXBlb2ZcIjoge1xuICAgICAgICBcImRvY1wiOiBcIlJldHVybnMgYSBzdHJpbmcgZGVzY3JpYmluZyB0aGUgdHlwZSBvZiB0aGUgZ2l2ZW4gdmFsdWUuXCIsXG4gICAgICAgIFwiZ3JvdXBcIjogXCJUeXBlc1wiXG4gICAgICB9LFxuICAgICAgXCJzdHJpbmdcIjoge1xuICAgICAgICBcImRvY1wiOiBcIkFzc2VydHMgdGhhdCB0aGUgaW5wdXQgdmFsdWUgaXMgYSBTdHJpbmcuIElmIG11bHRpcGxlIHZhbHVlcyBhcmUgcHJvdmlkZWQsIGVhY2ggb25lIGlzIGV2YWx1YXRlZCBpbiBvcmRlciB1bnRpbCBhIFN0cmluZyB2YWx1ZSBpcyBvYnRhaW5lZC5cIixcbiAgICAgICAgXCJncm91cFwiOiBcIlR5cGVzXCJcbiAgICAgIH0sXG4gICAgICBcIm51bWJlclwiOiB7XG4gICAgICAgIFwiZG9jXCI6IFwiQXNzZXJ0cyB0aGF0IHRoZSBpbnB1dCB2YWx1ZSBpcyBhIE51bWJlci4gSWYgbXVsdGlwbGUgdmFsdWVzIGFyZSBwcm92aWRlZCwgZWFjaCBvbmUgaXMgZXZhbHVhdGVkIGluIG9yZGVyIHVudGlsIGEgTnVtYmVyIHZhbHVlIGlzIG9idGFpbmVkLlwiLFxuICAgICAgICBcImdyb3VwXCI6IFwiVHlwZXNcIlxuICAgICAgfSxcbiAgICAgIFwiYm9vbGVhblwiOiB7XG4gICAgICAgIFwiZG9jXCI6IFwiQXNzZXJ0cyB0aGF0IHRoZSBpbnB1dCB2YWx1ZSBpcyBhIEJvb2xlYW4uIElmIG11bHRpcGxlIHZhbHVlcyBhcmUgcHJvdmlkZWQsIGVhY2ggb25lIGlzIGV2YWx1YXRlZCBpbiBvcmRlciB1bnRpbCBhIEJvb2xlYW4gdmFsdWUgaXMgb2J0YWluZWQuXCIsXG4gICAgICAgIFwiZ3JvdXBcIjogXCJUeXBlc1wiXG4gICAgICB9LFxuICAgICAgXCJvYmplY3RcIjoge1xuICAgICAgICBcImRvY1wiOiBcIkFzc2VydHMgdGhhdCB0aGUgaW5wdXQgdmFsdWUgaXMgYW4gT2JqZWN0cy5cIixcbiAgICAgICAgXCJncm91cFwiOiBcIlR5cGVzXCJcbiAgICAgIH0sXG4gICAgICBcInRvLXN0cmluZ1wiOiB7XG4gICAgICAgIFwiZG9jXCI6IFwiQ29lcmNlcyB0aGUgaW5wdXQgdmFsdWUgdG8gYSBTdHJpbmcuXCIsXG4gICAgICAgIFwiZ3JvdXBcIjogXCJUeXBlc1wiXG4gICAgICB9LFxuICAgICAgXCJ0by1udW1iZXJcIjoge1xuICAgICAgICBcImRvY1wiOiBcIkNvZXJjZXMgdGhlIGlucHV0IHZhbHVlIHRvIGEgTnVtYmVyLCBpZiBwb3NzaWJsZS4gSWYgbXVsdGlwbGUgdmFsdWVzIGFyZSBwcm92aWRlZCwgZWFjaCBvbmUgaXMgZXZhbHVhdGVkIGluIG9yZGVyIHVudGlsIHRoZSBmaXJzdCBzdWNjZXNzZnVsIGNvbnZlcnNpb24gaXMgb2J0YWluZWQuXCIsXG4gICAgICAgIFwiZ3JvdXBcIjogXCJUeXBlc1wiXG4gICAgICB9LFxuICAgICAgXCJ0by1ib29sZWFuXCI6IHtcbiAgICAgICAgXCJkb2NcIjogXCJDb2VyY2VzIHRoZSBpbnB1dCB2YWx1ZSB0byBhIEJvb2xlYW4uXCIsXG4gICAgICAgIFwiZ3JvdXBcIjogXCJUeXBlc1wiXG4gICAgICB9LFxuICAgICAgXCJ0by1yZ2JhXCI6IHtcbiAgICAgICAgXCJkb2NcIjogXCJSZXR1cm5zIHRoZSBhbiBhcnJheSBvZiB0aGUgZ2l2ZW4gY29sb3IncyByLCBnLCBiLCBhIGNvbXBvbmVudHMuXCIsXG4gICAgICAgIFwiZ3JvdXBcIjogXCJDb2xvclwiXG4gICAgICB9LFxuICAgICAgXCJ0by1jb2xvclwiOiB7XG4gICAgICAgIFwiZG9jXCI6IFwiQ29lcmNlcyB0aGUgaW5wdXQgdmFsdWUgdG8gYSBDb2xvci4gSWYgbXVsdGlwbGUgdmFsdWVzIGFyZSBwcm92aWRlZCwgZWFjaCBvbmUgaXMgZXZhbHVhdGVkIGluIG9yZGVyIHVudGlsIHRoZSBmaXJzdCBzdWNjZXNzZnVsIGNvbnZlcnNpb24gaXMgb2J0YWluZWQuXCIsXG4gICAgICAgIFwiZ3JvdXBcIjogXCJUeXBlc1wiXG4gICAgICB9LFxuICAgICAgXCJyZ2JcIjoge1xuICAgICAgICBcImRvY1wiOiBcIkNyZWF0ZXMgYSBjb2xvciB2YWx1ZSBmcm9tIHIsIGcsIGIgY29tcG9uZW50cy5cIixcbiAgICAgICAgXCJncm91cFwiOiBcIkNvbG9yXCJcbiAgICAgIH0sXG4gICAgICBcInJnYmFcIjoge1xuICAgICAgICBcImRvY1wiOiBcIkNyZWF0ZXMgYSBjb2xvciB2YWx1ZSBmcm9tIHIsIGcsIGIsIGEgY29tcG9uZW50cy5cIixcbiAgICAgICAgXCJncm91cFwiOiBcIkNvbG9yXCJcbiAgICAgIH0sXG4gICAgICBcImdldFwiOiB7XG4gICAgICAgIFwiZG9jXCI6IFwiUmV0cmlldmVzIGFuIHRoZSBvYmplY3QgcHJvcGVydHkgdmFsdWUuICBJZiBpdCdzIG5vdCBwcm92aWRlZCwgdGhlIG9iamVjdCBhcmd1bWVudCBkZWZhdWx0cyB0byBbXFxcInByb3BlcnRpZXNcXFwiXS4gIFJldHVybnMgbnVsbCBpZiB0aGUgcmVxdWVzdGVkIHByb3BlcnR5IGlzIG1pc3NpbmcgZnJvbSB0aGUgb2JqZWN0LlwiLFxuICAgICAgICBcImdyb3VwXCI6IFwiTG9va3VwXCJcbiAgICAgIH0sXG4gICAgICBcImhhc1wiOiB7XG4gICAgICAgIFwiZG9jXCI6IFwiVGVzdHMgZm9yIHRoZSBwcmVzZW5jZSBvZiBhbiBvYmplY3QgcHJvcGVydHkgdmFsdWUuICBJZiBpdCdzIG5vdCBwcm92aWRlZCwgdGhlIG9iamVjdCBhcmd1bWVudCBkZWZhdWx0cyB0byBbXFxcInByb3BlcnRpZXNcXFwiXS5cIixcbiAgICAgICAgXCJncm91cFwiOiBcIkxvb2t1cFwiXG4gICAgICB9LFxuICAgICAgXCJsZW5ndGhcIjoge1xuICAgICAgICBcImRvY1wiOiBcIkdldHMgdGhlIGxlbmd0aCBvZiBhbiBhcnJheSBvciBzdHJpbmcuXCIsXG4gICAgICAgIFwiZ3JvdXBcIjogXCJMb29rdXBcIlxuICAgICAgfSxcbiAgICAgIFwicHJvcGVydGllc1wiOiB7XG4gICAgICAgIFwiZG9jXCI6IFwiR2V0cyB0aGUgZmVhdHVyZSBwcm9wZXJ0aWVzIG9iamVjdC4gIE5vdGUgdGhhdCBpbiBzb21lIGNhc2VzLCBpdCBtYXkgYmUgbW9yZSBlZmZpY2llbnQgdG8gdXNlIFtcXFwiZ2V0XFxcIiwgXFxcInByb3BlcnR5X25hbWVcXFwiXSBkaXJlY3RseS5cIixcbiAgICAgICAgXCJncm91cFwiOiBcIkZlYXR1cmUgZGF0YVwiXG4gICAgICB9LFxuICAgICAgXCJnZW9tZXRyeS10eXBlXCI6IHtcbiAgICAgICAgXCJkb2NcIjogXCJHZXRzIHRoZSBmZWF0dXJlJ3MgZ2VvbWV0cnkgdHlwZTogUG9pbnQsIE11bHRpUG9pbnQsIExpbmVTdHJpbmcsIE11bHRpTGluZVN0cmluZywgUG9seWdvbiwgTXVsdGlQb2x5Z29uLlwiLFxuICAgICAgICBcImdyb3VwXCI6IFwiRmVhdHVyZSBkYXRhXCJcbiAgICAgIH0sXG4gICAgICBcImlkXCI6IHtcbiAgICAgICAgXCJkb2NcIjogXCJHZXRzIHRoZSBmZWF0dXJlJ3MgaWQsIGlmIGl0IGhhcyBvbmUuXCIsXG4gICAgICAgIFwiZ3JvdXBcIjogXCJGZWF0dXJlIGRhdGFcIlxuICAgICAgfSxcbiAgICAgIFwiem9vbVwiOiB7XG4gICAgICAgIFwiZG9jXCI6IFwiR2V0cyB0aGUgY3VycmVudCB6b29tIGxldmVsLiAgTm90ZSB0aGF0IGluIHN0eWxlIGxheW91dCBhbmQgcGFpbnQgcHJvcGVydGllcywgW1xcXCJ6b29tXFxcIl0gbWF5IG9ubHkgYXBwZWFyIGFzIHRoZSBpbnB1dCB0byBhIHRvcC1sZXZlbCBbXFxcImN1cnZlXFxcIl0gZXhwcmVzc2lvbi5cIixcbiAgICAgICAgXCJncm91cFwiOiBcIlpvb21cIlxuICAgICAgfSxcbiAgICAgIFwiaGVhdG1hcC1kZW5zaXR5XCI6IHtcbiAgICAgICAgXCJkb2NcIjogXCJHZXRzIHRoZSBrZXJuZWwgZGVuc2l0eSBlc3RpbWF0aW9uIG9mIGEgcGl4ZWwgaW4gYSBoZWF0bWFwIGxheWVyLCB3aGljaCBpcyBhIHJlbGF0aXZlIG1lYXN1cmUgb2YgaG93IG1hbnkgZGF0YSBwb2ludHMgYXJlIGNyb3dkZWQgYXJvdW5kIGEgcGFydGljdWxhciBwaXhlbC4gQ2FuIG9ubHkgYmUgdXNlZCBpbiB0aGUgYGhlYXRtYXAtY29sb3JgIHByb3BlcnR5LlwiLFxuICAgICAgICBcImdyb3VwXCI6IFwiSGVhdG1hcFwiXG4gICAgICB9LFxuICAgICAgXCIrXCI6IHtcbiAgICAgICAgXCJkb2NcIjogXCJcIixcbiAgICAgICAgXCJncm91cFwiOiBcIk1hdGhcIlxuICAgICAgfSxcbiAgICAgIFwiKlwiOiB7XG4gICAgICAgIFwiZG9jXCI6IFwiXCIsXG4gICAgICAgIFwiZ3JvdXBcIjogXCJNYXRoXCJcbiAgICAgIH0sXG4gICAgICBcIi1cIjoge1xuICAgICAgICBcImRvY1wiOiBcIlwiLFxuICAgICAgICBcImdyb3VwXCI6IFwiTWF0aFwiXG4gICAgICB9LFxuICAgICAgXCIvXCI6IHtcbiAgICAgICAgXCJkb2NcIjogXCJcIixcbiAgICAgICAgXCJncm91cFwiOiBcIk1hdGhcIlxuICAgICAgfSxcbiAgICAgIFwiJVwiOiB7XG4gICAgICAgIFwiZG9jXCI6IFwiXCIsXG4gICAgICAgIFwiZ3JvdXBcIjogXCJNYXRoXCJcbiAgICAgIH0sXG4gICAgICBcIl5cIjoge1xuICAgICAgICBcImRvY1wiOiBcIlwiLFxuICAgICAgICBcImdyb3VwXCI6IFwiTWF0aFwiXG4gICAgICB9LFxuICAgICAgXCJsb2cxMFwiOiB7XG4gICAgICAgIFwiZG9jXCI6IFwiXCIsXG4gICAgICAgIFwiZ3JvdXBcIjogXCJNYXRoXCJcbiAgICAgIH0sXG4gICAgICBcImxuXCI6IHtcbiAgICAgICAgXCJkb2NcIjogXCJcIixcbiAgICAgICAgXCJncm91cFwiOiBcIk1hdGhcIlxuICAgICAgfSxcbiAgICAgIFwibG9nMlwiOiB7XG4gICAgICAgIFwiZG9jXCI6IFwiXCIsXG4gICAgICAgIFwiZ3JvdXBcIjogXCJNYXRoXCJcbiAgICAgIH0sXG4gICAgICBcInNpblwiOiB7XG4gICAgICAgIFwiZG9jXCI6IFwiXCIsXG4gICAgICAgIFwiZ3JvdXBcIjogXCJNYXRoXCJcbiAgICAgIH0sXG4gICAgICBcImNvc1wiOiB7XG4gICAgICAgIFwiZG9jXCI6IFwiXCIsXG4gICAgICAgIFwiZ3JvdXBcIjogXCJNYXRoXCJcbiAgICAgIH0sXG4gICAgICBcInRhblwiOiB7XG4gICAgICAgIFwiZG9jXCI6IFwiXCIsXG4gICAgICAgIFwiZ3JvdXBcIjogXCJNYXRoXCJcbiAgICAgIH0sXG4gICAgICBcImFzaW5cIjoge1xuICAgICAgICBcImRvY1wiOiBcIlwiLFxuICAgICAgICBcImdyb3VwXCI6IFwiTWF0aFwiXG4gICAgICB9LFxuICAgICAgXCJhY29zXCI6IHtcbiAgICAgICAgXCJkb2NcIjogXCJcIixcbiAgICAgICAgXCJncm91cFwiOiBcIk1hdGhcIlxuICAgICAgfSxcbiAgICAgIFwiYXRhblwiOiB7XG4gICAgICAgIFwiZG9jXCI6IFwiXCIsXG4gICAgICAgIFwiZ3JvdXBcIjogXCJNYXRoXCJcbiAgICAgIH0sXG4gICAgICBcIm1pblwiOiB7XG4gICAgICAgIFwiZG9jXCI6IFwiXCIsXG4gICAgICAgIFwiZ3JvdXBcIjogXCJNYXRoXCJcbiAgICAgIH0sXG4gICAgICBcIm1heFwiOiB7XG4gICAgICAgIFwiZG9jXCI6IFwiXCIsXG4gICAgICAgIFwiZ3JvdXBcIjogXCJNYXRoXCJcbiAgICAgIH0sXG4gICAgICBcIj09XCI6IHtcbiAgICAgICAgXCJkb2NcIjogXCJcIixcbiAgICAgICAgXCJncm91cFwiOiBcIkRlY2lzaW9uXCJcbiAgICAgIH0sXG4gICAgICBcIiE9XCI6IHtcbiAgICAgICAgXCJkb2NcIjogXCJcIixcbiAgICAgICAgXCJncm91cFwiOiBcIkRlY2lzaW9uXCJcbiAgICAgIH0sXG4gICAgICBcIj5cIjoge1xuICAgICAgICBcImRvY1wiOiBcIlwiLFxuICAgICAgICBcImdyb3VwXCI6IFwiRGVjaXNpb25cIlxuICAgICAgfSxcbiAgICAgIFwiPFwiOiB7XG4gICAgICAgIFwiZG9jXCI6IFwiXCIsXG4gICAgICAgIFwiZ3JvdXBcIjogXCJEZWNpc2lvblwiXG4gICAgICB9LFxuICAgICAgXCI+PVwiOiB7XG4gICAgICAgIFwiZG9jXCI6IFwiXCIsXG4gICAgICAgIFwiZ3JvdXBcIjogXCJEZWNpc2lvblwiXG4gICAgICB9LFxuICAgICAgXCI8PVwiOiB7XG4gICAgICAgIFwiZG9jXCI6IFwiXCIsXG4gICAgICAgIFwiZ3JvdXBcIjogXCJEZWNpc2lvblwiXG4gICAgICB9LFxuICAgICAgXCJhbGxcIjoge1xuICAgICAgICBcImRvY1wiOiBcIlwiLFxuICAgICAgICBcImdyb3VwXCI6IFwiRGVjaXNpb25cIlxuICAgICAgfSxcbiAgICAgIFwiYW55XCI6IHtcbiAgICAgICAgXCJkb2NcIjogXCJcIixcbiAgICAgICAgXCJncm91cFwiOiBcIkRlY2lzaW9uXCJcbiAgICAgIH0sXG4gICAgICBcIiFcIjoge1xuICAgICAgICBcImRvY1wiOiBcIlwiLFxuICAgICAgICBcImdyb3VwXCI6IFwiRGVjaXNpb25cIlxuICAgICAgfSxcbiAgICAgIFwidXBjYXNlXCI6IHtcbiAgICAgICAgXCJkb2NcIjogXCJcIixcbiAgICAgICAgXCJncm91cFwiOiBcIlN0cmluZ1wiXG4gICAgICB9LFxuICAgICAgXCJkb3duY2FzZVwiOiB7XG4gICAgICAgIFwiZG9jXCI6IFwiXCIsXG4gICAgICAgIFwiZ3JvdXBcIjogXCJTdHJpbmdcIlxuICAgICAgfSxcbiAgICAgIFwiY29uY2F0XCI6IHtcbiAgICAgICAgXCJkb2NcIjogXCJDb25jZXRlbmF0ZSB0aGUgZ2l2ZW4gc3RyaW5ncy5cIixcbiAgICAgICAgXCJncm91cFwiOiBcIlN0cmluZ1wiXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBcImxpZ2h0XCI6IHtcbiAgICBcImFuY2hvclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImRlZmF1bHRcIjogXCJ2aWV3cG9ydFwiLFxuICAgICAgXCJ2YWx1ZXNcIjoge1xuICAgICAgICBcIm1hcFwiOiB7XG4gICAgICAgICAgXCJkb2NcIjogXCJUaGUgcG9zaXRpb24gb2YgdGhlIGxpZ2h0IHNvdXJjZSBpcyBhbGlnbmVkIHRvIHRoZSByb3RhdGlvbiBvZiB0aGUgbWFwLlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwidmlld3BvcnRcIjoge1xuICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIHBvc2l0aW9uIG9mIHRoZSBsaWdodCBzb3VyY2UgaXMgYWxpZ25lZCB0byB0aGUgcm90YXRpb24gb2YgdGhlIHZpZXdwb3J0LlwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcInRyYW5zaXRpb25cIjogZmFsc2UsXG4gICAgICBcInpvb20tZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwicHJvcGVydHktZnVuY3Rpb25cIjogZmFsc2UsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcImRvY1wiOiBcIldoZXRoZXIgZXh0cnVkZWQgZ2VvbWV0cmllcyBhcmUgbGl0IHJlbGF0aXZlIHRvIHRoZSBtYXAgb3Igdmlld3BvcnQuXCIsXG4gICAgICBcImV4YW1wbGVcIjogXCJtYXBcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjI3LjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCI1LjEuMFwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMy42LjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC41LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcImRlZmF1bHRcIjogWzEuMTUsIDIxMCwgMzBdLFxuICAgICAgXCJsZW5ndGhcIjogMyxcbiAgICAgIFwidmFsdWVcIjogXCJudW1iZXJcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ6b29tLWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInByb3BlcnR5LWZ1bmN0aW9uXCI6IGZhbHNlLFxuICAgICAgXCJkb2NcIjogXCJQb3NpdGlvbiBvZiB0aGUgbGlnaHQgc291cmNlIHJlbGF0aXZlIHRvIGxpdCAoZXh0cnVkZWQpIGdlb21ldHJpZXMsIGluIFtyIHJhZGlhbCBjb29yZGluYXRlLCBhIGF6aW11dGhhbCBhbmdsZSwgcCBwb2xhciBhbmdsZV0gd2hlcmUgciBpbmRpY2F0ZXMgdGhlIGRpc3RhbmNlIGZyb20gdGhlIGNlbnRlciBvZiB0aGUgYmFzZSBvZiBhbiBvYmplY3QgdG8gaXRzIGxpZ2h0LCBhIGluZGljYXRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIGxpZ2h0IHJlbGF0aXZlIHRvIDDCsCAoMMKwIHdoZW4gYGxpZ2h0LmFuY2hvcmAgaXMgc2V0IHRvIGB2aWV3cG9ydGAgY29ycmVzcG9uZHMgdG8gdGhlIHRvcCBvZiB0aGUgdmlld3BvcnQsIG9yIDDCsCB3aGVuIGBsaWdodC5hbmNob3JgIGlzIHNldCB0byBgbWFwYCBjb3JyZXNwb25kcyB0byBkdWUgbm9ydGgsIGFuZCBkZWdyZWVzIHByb2NlZWQgY2xvY2t3aXNlKSwgYW5kIHAgaW5kaWNhdGVzIHRoZSBoZWlnaHQgb2YgdGhlIGxpZ2h0IChmcm9tIDDCsCwgZGlyZWN0bHkgYWJvdmUsIHRvIDE4MMKwLCBkaXJlY3RseSBiZWxvdykuXCIsXG4gICAgICBcImV4YW1wbGVcIjogWzEuNSwgOTAsIDgwXSxcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjI3LjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCI1LjEuMFwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMy42LjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC41LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcImNvbG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXG4gICAgICBcImRlZmF1bHRcIjogXCIjZmZmZmZmXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInpvb20tZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwicHJvcGVydHktZnVuY3Rpb25cIjogZmFsc2UsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiQ29sb3IgdGludCBmb3IgbGlnaHRpbmcgZXh0cnVkZWQgZ2VvbWV0cmllcy5cIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjI3LjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCI1LjEuMFwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMy42LjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC41LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcImludGVuc2l0eVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLjUsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwibWF4aW11bVwiOiAxLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ6b29tLWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInByb3BlcnR5LWZ1bmN0aW9uXCI6IGZhbHNlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcImRvY1wiOiBcIkludGVuc2l0eSBvZiBsaWdodGluZyAob24gYSBzY2FsZSBmcm9tIDAgdG8gMSkuIEhpZ2hlciBudW1iZXJzIHdpbGwgcHJlc2VudCBhcyBtb3JlIGV4dHJlbWUgY29udHJhc3QuXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4yNy4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiNS4xLjBcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjMuNi4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuNS4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgXCJwYWludFwiOiBbXG4gICAgXCJwYWludF9maWxsXCIsXG4gICAgXCJwYWludF9saW5lXCIsXG4gICAgXCJwYWludF9jaXJjbGVcIixcbiAgICBcInBhaW50X2hlYXRtYXBcIixcbiAgICBcInBhaW50X2ZpbGwtZXh0cnVzaW9uXCIsXG4gICAgXCJwYWludF9zeW1ib2xcIixcbiAgICBcInBhaW50X3Jhc3RlclwiLFxuICAgIFwicGFpbnRfYmFja2dyb3VuZFwiXG4gIF0sXG4gIFwicGFpbnRfZmlsbFwiOiB7XG4gICAgXCJmaWxsLWFudGlhbGlhc1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInpvb20tZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwiZGVmYXVsdFwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJXaGV0aGVyIG9yIG5vdCB0aGUgZmlsbCBzaG91bGQgYmUgYW50aWFsaWFzZWQuXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4xMC4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiMi4wLjFcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjIuMC4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuMS4wXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHt9XG4gICAgICB9XG4gICAgfSxcbiAgICBcImZpbGwtb3BhY2l0eVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiem9vbS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJwcm9wZXJ0eS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwibWF4aW11bVwiOiAxLFxuICAgICAgXCJkb2NcIjogXCJUaGUgb3BhY2l0eSBvZiB0aGUgZW50aXJlIGZpbGwgbGF5ZXIuIEluIGNvbnRyYXN0IHRvIHRoZSBgZmlsbC1jb2xvcmAsIHRoaXMgdmFsdWUgd2lsbCBhbHNvIGFmZmVjdCB0aGUgMXB4IHN0cm9rZSBhcm91bmQgdGhlIGZpbGwsIGlmIHRoZSBzdHJva2UgaXMgdXNlZC5cIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAgXCJqc1wiOiBcIjAuMTAuMFwiLFxuICAgICAgICAgIFwiYW5kcm9pZFwiOiBcIjIuMC4xXCIsXG4gICAgICAgICAgXCJpb3NcIjogXCIyLjAuMFwiLFxuICAgICAgICAgIFwibWFjb3NcIjogXCIwLjEuMFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG4gICAgICAgICAgXCJqc1wiOiBcIjAuMjEuMFwiLFxuICAgICAgICAgIFwiYW5kcm9pZFwiOiBcIjUuMC4wXCIsXG4gICAgICAgICAgXCJpb3NcIjogXCIzLjUuMFwiLFxuICAgICAgICAgIFwibWFjb3NcIjogXCIwLjQuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiZmlsbC1jb2xvclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJjb2xvclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IFwiIzAwMDAwMFwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgY29sb3Igb2YgdGhlIGZpbGxlZCBwYXJ0IG9mIHRoaXMgbGF5ZXIuIFRoaXMgY29sb3IgY2FuIGJlIHNwZWNpZmllZCBhcyBgcmdiYWAgd2l0aCBhbiBhbHBoYSBjb21wb25lbnQgYW5kIHRoZSBjb2xvcidzIG9wYWNpdHkgd2lsbCBub3QgYWZmZWN0IHRoZSBvcGFjaXR5IG9mIHRoZSAxcHggc3Ryb2tlLCBpZiBpdCBpcyB1c2VkLlwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ6b29tLWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInByb3BlcnR5LWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICB7XG4gICAgICAgICAgXCIhXCI6IFwiZmlsbC1wYXR0ZXJuXCJcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjEwLjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCIyLjAuMVwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMi4wLjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC4xLjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjE5LjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCI1LjAuMFwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMy41LjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC40LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcImZpbGwtb3V0bGluZS1jb2xvclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJjb2xvclwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgb3V0bGluZSBjb2xvciBvZiB0aGUgZmlsbC4gTWF0Y2hlcyB0aGUgdmFsdWUgb2YgYGZpbGwtY29sb3JgIGlmIHVuc3BlY2lmaWVkLlwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ6b29tLWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInByb3BlcnR5LWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICB7XG4gICAgICAgICAgXCIhXCI6IFwiZmlsbC1wYXR0ZXJuXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIFwiZmlsbC1hbnRpYWxpYXNcIjogdHJ1ZVxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAgXCJqc1wiOiBcIjAuMTAuMFwiLFxuICAgICAgICAgIFwiYW5kcm9pZFwiOiBcIjIuMC4xXCIsXG4gICAgICAgICAgXCJpb3NcIjogXCIyLjAuMFwiLFxuICAgICAgICAgIFwibWFjb3NcIjogXCIwLjEuMFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG4gICAgICAgICAgXCJqc1wiOiBcIjAuMTkuMFwiLFxuICAgICAgICAgIFwiYW5kcm9pZFwiOiBcIjUuMC4wXCIsXG4gICAgICAgICAgXCJpb3NcIjogXCIzLjUuMFwiLFxuICAgICAgICAgIFwibWFjb3NcIjogXCIwLjQuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiZmlsbC10cmFuc2xhdGVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwidmFsdWVcIjogXCJudW1iZXJcIixcbiAgICAgIFwibGVuZ3RoXCI6IDIsXG4gICAgICBcImRlZmF1bHRcIjogW1xuICAgICAgICAwLFxuICAgICAgICAwXG4gICAgICBdLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ6b29tLWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwidW5pdHNcIjogXCJwaXhlbHNcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGdlb21ldHJ5J3Mgb2Zmc2V0LiBWYWx1ZXMgYXJlIFt4LCB5XSB3aGVyZSBuZWdhdGl2ZXMgaW5kaWNhdGUgbGVmdCBhbmQgdXAsIHJlc3BlY3RpdmVseS5cIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjEwLjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCIyLjAuMVwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMi4wLjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC4xLjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge31cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiZmlsbC10cmFuc2xhdGUtYW5jaG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwiem9vbS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ2YWx1ZXNcIjoge1xuICAgICAgICBcIm1hcFwiOiB7XG4gICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBmaWxsIGlzIHRyYW5zbGF0ZWQgcmVsYXRpdmUgdG8gdGhlIG1hcC5cIlxuICAgICAgICB9LFxuICAgICAgICBcInZpZXdwb3J0XCI6IHtcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIGZpbGwgaXMgdHJhbnNsYXRlZCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQuXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiZG9jXCI6IFwiQ29udHJvbHMgdGhlIHRyYW5zbGF0aW9uIHJlZmVyZW5jZSBwb2ludC5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIm1hcFwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiZmlsbC10cmFuc2xhdGVcIlxuICAgICAgXSxcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjEwLjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCIyLjAuMVwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMi4wLjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC4xLjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge31cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiZmlsbC1wYXR0ZXJuXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ6b29tLWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiTmFtZSBvZiBpbWFnZSBpbiBzcHJpdGUgdG8gdXNlIGZvciBkcmF3aW5nIGltYWdlIGZpbGxzLiBGb3Igc2VhbWxlc3MgcGF0dGVybnMsIGltYWdlIHdpZHRoIGFuZCBoZWlnaHQgbXVzdCBiZSBhIGZhY3RvciBvZiB0d28gKDIsIDQsIDgsIC4uLiwgNTEyKS5cIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjEwLjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCIyLjAuMVwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMi4wLjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC4xLjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge31cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIFwicGFpbnRfZmlsbC1leHRydXNpb25cIjoge1xuICAgIFwiZmlsbC1leHRydXNpb24tb3BhY2l0eVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiem9vbS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJwcm9wZXJ0eS1mdW5jdGlvblwiOiBmYWxzZSxcbiAgICAgIFwiZGVmYXVsdFwiOiAxLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcIm1heGltdW1cIjogMSxcbiAgICAgIFwiZG9jXCI6IFwiVGhlIG9wYWNpdHkgb2YgdGhlIGVudGlyZSBmaWxsIGV4dHJ1c2lvbiBsYXllci4gVGhpcyBpcyByZW5kZXJlZCBvbiBhIHBlci1sYXllciwgbm90IHBlci1mZWF0dXJlLCBiYXNpcywgYW5kIGRhdGEtZHJpdmVuIHN0eWxpbmcgaXMgbm90IGF2YWlsYWJsZS5cIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAgXCJqc1wiOiBcIjAuMjcuMFwiLFxuICAgICAgICAgIFwiYW5kcm9pZFwiOiBcIjUuMS4wXCIsXG4gICAgICAgICAgXCJpb3NcIjogXCIzLjYuMFwiLFxuICAgICAgICAgIFwibWFjb3NcIjogXCIwLjUuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiZmlsbC1leHRydXNpb24tY29sb3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGJhc2UgY29sb3Igb2YgdGhlIGV4dHJ1ZGVkIGZpbGwuIFRoZSBleHRydXNpb24ncyBzdXJmYWNlcyB3aWxsIGJlIHNoYWRlZCBkaWZmZXJlbnRseSBiYXNlZCBvbiB0aGlzIGNvbG9yIGluIGNvbWJpbmF0aW9uIHdpdGggdGhlIHJvb3QgYGxpZ2h0YCBzZXR0aW5ncy4gSWYgdGhpcyBjb2xvciBpcyBzcGVjaWZpZWQgYXMgYHJnYmFgIHdpdGggYW4gYWxwaGEgY29tcG9uZW50LCB0aGUgYWxwaGEgY29tcG9uZW50IHdpbGwgYmUgaWdub3JlZDsgdXNlIGBmaWxsLWV4dHJ1c2lvbi1vcGFjaXR5YCB0byBzZXQgbGF5ZXIgb3BhY2l0eS5cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiem9vbS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJwcm9wZXJ0eS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgIFwiIVwiOiBcImZpbGwtZXh0cnVzaW9uLXBhdHRlcm5cIlxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAgXCJqc1wiOiBcIjAuMjcuMFwiLFxuICAgICAgICAgIFwiYW5kcm9pZFwiOiBcIjUuMS4wXCIsXG4gICAgICAgICAgXCJpb3NcIjogXCIzLjYuMFwiLFxuICAgICAgICAgIFwibWFjb3NcIjogXCIwLjUuMFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG4gICAgICAgICAgXCJqc1wiOiBcIjAuMjcuMFwiLFxuICAgICAgICAgIFwiYW5kcm9pZFwiOiBcIjUuMS4wXCIsXG4gICAgICAgICAgXCJpb3NcIjogXCIzLjYuMFwiLFxuICAgICAgICAgIFwibWFjb3NcIjogXCIwLjUuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiZmlsbC1leHRydXNpb24tdHJhbnNsYXRlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcInZhbHVlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImxlbmd0aFwiOiAyLFxuICAgICAgXCJkZWZhdWx0XCI6IFtcbiAgICAgICAgMCxcbiAgICAgICAgMFxuICAgICAgXSxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiem9vbS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBnZW9tZXRyeSdzIG9mZnNldC4gVmFsdWVzIGFyZSBbeCwgeV0gd2hlcmUgbmVnYXRpdmVzIGluZGljYXRlIGxlZnQgYW5kIHVwIChvbiB0aGUgZmxhdCBwbGFuZSksIHJlc3BlY3RpdmVseS5cIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjI3LjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCI1LjEuMFwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMy42LjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC41LjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge31cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiZmlsbC1leHRydXNpb24tdHJhbnNsYXRlLWFuY2hvclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInpvb20tZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidmFsdWVzXCI6IHtcbiAgICAgICAgXCJtYXBcIjoge1xuICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgZmlsbCBleHRydXNpb24gaXMgdHJhbnNsYXRlZCByZWxhdGl2ZSB0byB0aGUgbWFwLlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwidmlld3BvcnRcIjoge1xuICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgZmlsbCBleHRydXNpb24gaXMgdHJhbnNsYXRlZCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQuXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiZG9jXCI6IFwiQ29udHJvbHMgdGhlIHRyYW5zbGF0aW9uIHJlZmVyZW5jZSBwb2ludC5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIm1hcFwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiZmlsbC1leHRydXNpb24tdHJhbnNsYXRlXCJcbiAgICAgIF0sXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4yNy4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiNS4xLjBcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjMuNi4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuNS4wXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHt9XG4gICAgICB9XG4gICAgfSxcbiAgICBcImZpbGwtZXh0cnVzaW9uLXBhdHRlcm5cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInpvb20tZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJOYW1lIG9mIGltYWdlIGluIHNwcml0ZSB0byB1c2UgZm9yIGRyYXdpbmcgaW1hZ2VzIG9uIGV4dHJ1ZGVkIGZpbGxzLiBGb3Igc2VhbWxlc3MgcGF0dGVybnMsIGltYWdlIHdpZHRoIGFuZCBoZWlnaHQgbXVzdCBiZSBhIGZhY3RvciBvZiB0d28gKDIsIDQsIDgsIC4uLiwgNTEyKS5cIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjI3LjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCI1LjEuMFwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMy42LjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC41LjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge31cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiZmlsbC1leHRydXNpb24taGVpZ2h0XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ6b29tLWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInByb3BlcnR5LWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJ1bml0c1wiOiBcIm1ldGVyc1wiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgaGVpZ2h0IHdpdGggd2hpY2ggdG8gZXh0cnVkZSB0aGlzIGxheWVyLlwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4yNy4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiNS4xLjBcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjMuNi4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuNS4wXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4yNy4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiNS4xLjBcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjMuNi4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuNS4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJmaWxsLWV4dHJ1c2lvbi1iYXNlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ6b29tLWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInByb3BlcnR5LWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJ1bml0c1wiOiBcIm1ldGVyc1wiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgaGVpZ2h0IHdpdGggd2hpY2ggdG8gZXh0cnVkZSB0aGUgYmFzZSBvZiB0aGlzIGxheWVyLiBNdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgZmlsbC1leHRydXNpb24taGVpZ2h0YC5cIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiZmlsbC1leHRydXNpb24taGVpZ2h0XCJcbiAgICAgIF0sXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4yNy4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiNS4xLjBcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjMuNi4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuNS4wXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4yNy4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiNS4xLjBcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjMuNi4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuNS4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgXCJwYWludF9saW5lXCI6IHtcbiAgICBcImxpbmUtb3BhY2l0eVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIG9wYWNpdHkgYXQgd2hpY2ggdGhlIGxpbmUgd2lsbCBiZSBkcmF3bi5cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiem9vbS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJwcm9wZXJ0eS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwibWF4aW11bVwiOiAxLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4xMC4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiMi4wLjFcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjIuMC4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuMS4wXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4yOS4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiNS4wLjBcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjMuNS4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuNC4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJsaW5lLWNvbG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBjb2xvciB3aXRoIHdoaWNoIHRoZSBsaW5lIHdpbGwgYmUgZHJhd24uXCIsXG4gICAgICBcImRlZmF1bHRcIjogXCIjMDAwMDAwXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInpvb20tZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwicHJvcGVydHktZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBcIiFcIjogXCJsaW5lLXBhdHRlcm5cIlxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAgXCJqc1wiOiBcIjAuMTAuMFwiLFxuICAgICAgICAgIFwiYW5kcm9pZFwiOiBcIjIuMC4xXCIsXG4gICAgICAgICAgXCJpb3NcIjogXCIyLjAuMFwiLFxuICAgICAgICAgIFwibWFjb3NcIjogXCIwLjEuMFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG4gICAgICAgICAgXCJqc1wiOiBcIjAuMjMuMFwiLFxuICAgICAgICAgIFwiYW5kcm9pZFwiOiBcIjUuMC4wXCIsXG4gICAgICAgICAgXCJpb3NcIjogXCIzLjUuMFwiLFxuICAgICAgICAgIFwibWFjb3NcIjogXCIwLjQuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwibGluZS10cmFuc2xhdGVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwidmFsdWVcIjogXCJudW1iZXJcIixcbiAgICAgIFwibGVuZ3RoXCI6IDIsXG4gICAgICBcImRlZmF1bHRcIjogW1xuICAgICAgICAwLFxuICAgICAgICAwXG4gICAgICBdLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ6b29tLWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwidW5pdHNcIjogXCJwaXhlbHNcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGdlb21ldHJ5J3Mgb2Zmc2V0LiBWYWx1ZXMgYXJlIFt4LCB5XSB3aGVyZSBuZWdhdGl2ZXMgaW5kaWNhdGUgbGVmdCBhbmQgdXAsIHJlc3BlY3RpdmVseS5cIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjEwLjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCIyLjAuMVwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMi4wLjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC4xLjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge31cbiAgICAgIH1cbiAgICB9LFxuICAgIFwibGluZS10cmFuc2xhdGUtYW5jaG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwiem9vbS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ2YWx1ZXNcIjoge1xuICAgICAgICBcIm1hcFwiOiB7XG4gICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBsaW5lIGlzIHRyYW5zbGF0ZWQgcmVsYXRpdmUgdG8gdGhlIG1hcC5cIlxuICAgICAgICB9LFxuICAgICAgICBcInZpZXdwb3J0XCI6IHtcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIGxpbmUgaXMgdHJhbnNsYXRlZCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQuXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiZG9jXCI6IFwiQ29udHJvbHMgdGhlIHRyYW5zbGF0aW9uIHJlZmVyZW5jZSBwb2ludC5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIm1hcFwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwibGluZS10cmFuc2xhdGVcIlxuICAgICAgXSxcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjEwLjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCIyLjAuMVwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMi4wLjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC4xLjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge31cbiAgICAgIH1cbiAgICB9LFxuICAgIFwibGluZS13aWR0aFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAxLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInpvb20tZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwicHJvcGVydHktZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJTdHJva2UgdGhpY2tuZXNzLlwiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAgXCJqc1wiOiBcIjAuMTAuMFwiLFxuICAgICAgICAgIFwiYW5kcm9pZFwiOiBcIjIuMC4xXCIsXG4gICAgICAgICAgXCJpb3NcIjogXCIyLjAuMFwiLFxuICAgICAgICAgIFwibWFjb3NcIjogXCIwLjEuMFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG4gICAgICAgICAgXCJqc1wiOiBcIjAuMzkuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwibGluZS1nYXAtd2lkdGhcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJkb2NcIjogXCJEcmF3cyBhIGxpbmUgY2FzaW5nIG91dHNpZGUgb2YgYSBsaW5lJ3MgYWN0dWFsIHBhdGguIFZhbHVlIGluZGljYXRlcyB0aGUgd2lkdGggb2YgdGhlIGlubmVyIGdhcC5cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiem9vbS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJwcm9wZXJ0eS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4xMC4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiMi4wLjFcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjIuMC4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuMS4wXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4yOS4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiNS4wLjBcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjMuNS4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuNC4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJsaW5lLW9mZnNldFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJkb2NcIjogXCJUaGUgbGluZSdzIG9mZnNldC4gRm9yIGxpbmVhciBmZWF0dXJlcywgYSBwb3NpdGl2ZSB2YWx1ZSBvZmZzZXRzIHRoZSBsaW5lIHRvIHRoZSByaWdodCwgcmVsYXRpdmUgdG8gdGhlIGRpcmVjdGlvbiBvZiB0aGUgbGluZSwgYW5kIGEgbmVnYXRpdmUgdmFsdWUgdG8gdGhlIGxlZnQuIEZvciBwb2x5Z29uIGZlYXR1cmVzLCBhIHBvc2l0aXZlIHZhbHVlIHJlc3VsdHMgaW4gYW4gaW5zZXQsIGFuZCBhIG5lZ2F0aXZlIHZhbHVlIHJlc3VsdHMgaW4gYW4gb3V0c2V0LlwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ6b29tLWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInByb3BlcnR5LWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwidW5pdHNcIjogXCJwaXhlbHNcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjEyLjFcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCIzLjAuMFwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMy4xLjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC4xLjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjI5LjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCI1LjAuMFwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMy41LjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC40LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcImxpbmUtYmx1clwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInpvb20tZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwicHJvcGVydHktZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJCbHVyIGFwcGxpZWQgdG8gdGhlIGxpbmUsIGluIHBpeGVscy5cIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjEwLjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCIyLjAuMVwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMi4wLjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC4xLjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjI5LjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCI1LjAuMFwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMy41LjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC40LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcImxpbmUtZGFzaGFycmF5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcInZhbHVlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInpvb20tZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiU3BlY2lmaWVzIHRoZSBsZW5ndGhzIG9mIHRoZSBhbHRlcm5hdGluZyBkYXNoZXMgYW5kIGdhcHMgdGhhdCBmb3JtIHRoZSBkYXNoIHBhdHRlcm4uIFRoZSBsZW5ndGhzIGFyZSBsYXRlciBzY2FsZWQgYnkgdGhlIGxpbmUgd2lkdGguIFRvIGNvbnZlcnQgYSBkYXNoIGxlbmd0aCB0byBwaXhlbHMsIG11bHRpcGx5IHRoZSBsZW5ndGggYnkgdGhlIGN1cnJlbnQgbGluZSB3aWR0aC5cIixcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInVuaXRzXCI6IFwibGluZSB3aWR0aHNcIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICB7XG4gICAgICAgICAgXCIhXCI6IFwibGluZS1wYXR0ZXJuXCJcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjEwLjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCIyLjAuMVwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMi4wLjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC4xLjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge31cbiAgICAgIH1cbiAgICB9LFxuICAgIFwibGluZS1wYXR0ZXJuXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ6b29tLWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiTmFtZSBvZiBpbWFnZSBpbiBzcHJpdGUgdG8gdXNlIGZvciBkcmF3aW5nIGltYWdlIGxpbmVzLiBGb3Igc2VhbWxlc3MgcGF0dGVybnMsIGltYWdlIHdpZHRoIG11c3QgYmUgYSBmYWN0b3Igb2YgdHdvICgyLCA0LCA4LCAuLi4sIDUxMikuXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4xMC4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiMi4wLjFcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjIuMC4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuMS4wXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHt9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBcInBhaW50X2NpcmNsZVwiOiB7XG4gICAgXCJjaXJjbGUtcmFkaXVzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDUsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiem9vbS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJwcm9wZXJ0eS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCIsXG4gICAgICBcImRvY1wiOiBcIkNpcmNsZSByYWRpdXMuXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4xMC4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiMi4wLjFcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjIuMC4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuMS4wXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4xOC4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiNS4wLjBcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjMuNS4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuNC4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJjaXJjbGUtY29sb3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGZpbGwgY29sb3Igb2YgdGhlIGNpcmNsZS5cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiem9vbS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJwcm9wZXJ0eS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4xMC4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiMi4wLjFcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjIuMC4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuMS4wXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4xOC4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiNS4wLjBcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjMuNS4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuNC4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJjaXJjbGUtYmx1clwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJkb2NcIjogXCJBbW91bnQgdG8gYmx1ciB0aGUgY2lyY2xlLiAxIGJsdXJzIHRoZSBjaXJjbGUgc3VjaCB0aGF0IG9ubHkgdGhlIGNlbnRlcnBvaW50IGlzIGZ1bGwgb3BhY2l0eS5cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiem9vbS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJwcm9wZXJ0eS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4xMC4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiMi4wLjFcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjIuMC4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuMS4wXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4yMC4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiNS4wLjBcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjMuNS4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuNC4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJjaXJjbGUtb3BhY2l0eVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIG9wYWNpdHkgYXQgd2hpY2ggdGhlIGNpcmNsZSB3aWxsIGJlIGRyYXduLlwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwibWF4aW11bVwiOiAxLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ6b29tLWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInByb3BlcnR5LWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjEwLjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCIyLjAuMVwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMi4wLjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC4xLjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjIwLjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCI1LjAuMFwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMy41LjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC40LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcImNpcmNsZS10cmFuc2xhdGVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwidmFsdWVcIjogXCJudW1iZXJcIixcbiAgICAgIFwibGVuZ3RoXCI6IDIsXG4gICAgICBcImRlZmF1bHRcIjogWzAsIDBdLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ6b29tLWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwidW5pdHNcIjogXCJwaXhlbHNcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGdlb21ldHJ5J3Mgb2Zmc2V0LiBWYWx1ZXMgYXJlIFt4LCB5XSB3aGVyZSBuZWdhdGl2ZXMgaW5kaWNhdGUgbGVmdCBhbmQgdXAsIHJlc3BlY3RpdmVseS5cIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjEwLjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCIyLjAuMVwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMi4wLjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC4xLjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge31cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiY2lyY2xlLXRyYW5zbGF0ZS1hbmNob3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ6b29tLWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInZhbHVlc1wiOiB7XG4gICAgICAgIFwibWFwXCI6IHtcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIGNpcmNsZSBpcyB0cmFuc2xhdGVkIHJlbGF0aXZlIHRvIHRoZSBtYXAuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJ2aWV3cG9ydFwiOiB7XG4gICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBjaXJjbGUgaXMgdHJhbnNsYXRlZCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQuXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiZG9jXCI6IFwiQ29udHJvbHMgdGhlIHRyYW5zbGF0aW9uIHJlZmVyZW5jZSBwb2ludC5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIm1hcFwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiY2lyY2xlLXRyYW5zbGF0ZVwiXG4gICAgICBdLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAgXCJqc1wiOiBcIjAuMTAuMFwiLFxuICAgICAgICAgIFwiYW5kcm9pZFwiOiBcIjIuMC4xXCIsXG4gICAgICAgICAgXCJpb3NcIjogXCIyLjAuMFwiLFxuICAgICAgICAgIFwibWFjb3NcIjogXCIwLjEuMFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7fVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJjaXJjbGUtcGl0Y2gtc2NhbGVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ6b29tLWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInZhbHVlc1wiOiB7XG4gICAgICAgIFwibWFwXCI6IHtcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiQ2lyY2xlcyBhcmUgc2NhbGVkIGFjY29yZGluZyB0byB0aGVpciBhcHBhcmVudCBkaXN0YW5jZSB0byB0aGUgY2FtZXJhLlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwidmlld3BvcnRcIjoge1xuICAgICAgICAgICAgXCJkb2NcIjogXCJDaXJjbGVzIGFyZSBub3Qgc2NhbGVkLlwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcImRlZmF1bHRcIjogXCJtYXBcIixcbiAgICAgIFwiZG9jXCI6IFwiQ29udHJvbHMgdGhlIHNjYWxpbmcgYmVoYXZpb3Igb2YgdGhlIGNpcmNsZSB3aGVuIHRoZSBtYXAgaXMgcGl0Y2hlZC5cIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjIxLjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCI0LjIuMFwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMy40LjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC4yLjFcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge31cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiY2lyY2xlLXBpdGNoLWFsaWdubWVudFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInpvb20tZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidmFsdWVzXCI6IHtcbiAgICAgICAgXCJtYXBcIjoge1xuICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgY2lyY2xlIGlzIGFsaWduZWQgdG8gdGhlIHBsYW5lIG9mIHRoZSBtYXAuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJ2aWV3cG9ydFwiOiB7XG4gICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBjaXJjbGUgaXMgYWxpZ25lZCB0byB0aGUgcGxhbmUgb2YgdGhlIHZpZXdwb3J0LlwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcImRlZmF1bHRcIjogXCJ2aWV3cG9ydFwiLFxuICAgICAgXCJkb2NcIjogXCJPcmllbnRhdGlvbiBvZiBjaXJjbGUgd2hlbiBtYXAgaXMgcGl0Y2hlZC5cIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjM5LjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge31cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiY2lyY2xlLXN0cm9rZS13aWR0aFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInpvb20tZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwicHJvcGVydHktZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgd2lkdGggb2YgdGhlIGNpcmNsZSdzIHN0cm9rZS4gU3Ryb2tlcyBhcmUgcGxhY2VkIG91dHNpZGUgb2YgdGhlIGBjaXJjbGUtcmFkaXVzYC5cIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjI5LjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCI1LjAuMFwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMy41LjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC40LjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjI5LjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCI1LjAuMFwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMy41LjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC40LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcImNpcmNsZS1zdHJva2UtY29sb3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIHN0cm9rZSBjb2xvciBvZiB0aGUgY2lyY2xlLlwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ6b29tLWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInByb3BlcnR5LWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjI5LjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCI1LjAuMFwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMy41LjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC40LjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjI5LjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCI1LjAuMFwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMy41LjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC40LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcImNpcmNsZS1zdHJva2Utb3BhY2l0eVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIG9wYWNpdHkgb2YgdGhlIGNpcmNsZSdzIHN0cm9rZS5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiAxLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcIm1heGltdW1cIjogMSxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiem9vbS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJwcm9wZXJ0eS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4yOS4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiNS4wLjBcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjMuNS4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuNC4wXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4yOS4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiNS4wLjBcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjMuNS4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuNC4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgXCJwYWludF9oZWF0bWFwXCI6IHtcbiAgICBcImhlYXRtYXAtcmFkaXVzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDMwLFxuICAgICAgXCJtaW5pbXVtXCI6IDEsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInpvb20tZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwicHJvcGVydHktZnVuY3Rpb25cIjogZmFsc2UsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwidW5pdHNcIjogXCJwaXhlbHNcIixcbiAgICAgIFwiZG9jXCI6IFwiUmFkaXVzIG9mIGluZmx1ZW5jZSBvZiBvbmUgaGVhdG1hcCBwb2ludCBpbiBwaXhlbHMuIEluY3JlYXNpbmcgdGhlIHZhbHVlIG1ha2VzIHRoZSBoZWF0bWFwIHNtb290aGVyLCBidXQgbGVzcyBkZXRhaWxlZC5cIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjQxLjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge31cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiaGVhdG1hcC13ZWlnaHRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMSxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ6b29tLWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInByb3BlcnR5LWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInRyYW5zaXRpb25cIjogZmFsc2UsXG4gICAgICBcImRvY1wiOiBcIkEgbWVhc3VyZSBvZiBob3cgbXVjaCBhbiBpbmRpdmlkdWFsIHBvaW50IGNvbnRyaWJ1dGVzIHRvIHRoZSBoZWF0bWFwLiBBIHZhbHVlIG9mIDEwIHdvdWxkIGJlIGVxdWl2YWxlbnQgdG8gaGF2aW5nIDEwIHBvaW50cyBvZiB3ZWlnaHQgMSBpbiB0aGUgc2FtZSBzcG90LiBFc3BlY2lhbGx5IHVzZWZ1bCB3aGVuIGNvbWJpbmVkIHdpdGggY2x1c3RlcmluZy5cIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjQxLjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjQxLjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcImhlYXRtYXAtaW50ZW5zaXR5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiem9vbS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJwcm9wZXJ0eS1mdW5jdGlvblwiOiBmYWxzZSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJTaW1pbGFyIHRvIGBoZWF0bWFwLXdlaWdodGAgYnV0IGNvbnRyb2xzIHRoZSBpbnRlbnNpdHkgb2YgdGhlIGhlYXRtYXAgZ2xvYmFsbHkuIFByaW1hcmlseSB1c2VkIGZvciBhZGp1c3RpbmcgdGhlIGhlYXRtYXAgYmFzZWQgb24gem9vbSBsZXZlbC5cIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjQxLjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge31cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiaGVhdG1hcC1jb2xvclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJjb2xvclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IHtcbiAgICAgICAgICBcInN0b3BzXCI6IFtcbiAgICAgICAgICAgICAgWzAsIFwicmdiYSgwLCAwLCAyNTUsIDApXCJdLFxuICAgICAgICAgICAgICBbMC4xLCBcInJveWFsYmx1ZVwiXSxcbiAgICAgICAgICAgICAgWzAuMywgXCJjeWFuXCJdLFxuICAgICAgICAgICAgICBbMC41LCBcImxpbWVcIl0sXG4gICAgICAgICAgICAgIFswLjcsIFwieWVsbG93XCJdLFxuICAgICAgICAgICAgICBbMSwgXCJyZWRcIl1cbiAgICAgICAgICBdXG4gICAgICB9LFxuICAgICAgXCJkb2NcIjogXCJEZWZpbmVzIHRoZSBjb2xvciBvZiBlYWNoIHBpeGVsIGJhc2VkIG9uIGl0cyBkZW5zaXR5IHZhbHVlIGluIGEgaGVhdG1hcC4gU2hvdWxkIGJlIGVpdGhlciBhIHN0b3AgZnVuY3Rpb24gd2l0aCBpbnB1dCB2YWx1ZXMgcmFuZ2luZyBmcm9tIGAwYCB0byBgMWAsIG9yIGEgY3VydmUgZXhwcmVzc2lvbiB3aXRoIGEgc3BlY2lhbCBgW1xcXCJoZWF0bWFwLWRlbnNpdHlcXFwiXWAga2V5d29yZCBhcyB0aGUgaW5wdXQuXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInpvb20tZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwicHJvcGVydHktZnVuY3Rpb25cIjogZmFsc2UsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjQxLjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge31cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiaGVhdG1hcC1vcGFjaXR5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgZ2xvYmFsIG9wYWNpdHkgYXQgd2hpY2ggdGhlIGhlYXRtYXAgbGF5ZXIgd2lsbCBiZSBkcmF3bi5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiAxLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcIm1heGltdW1cIjogMSxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiem9vbS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJwcm9wZXJ0eS1mdW5jdGlvblwiOiBmYWxzZSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAgXCJqc1wiOiBcIjAuNDEuMFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7fVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgXCJwYWludF9zeW1ib2xcIjoge1xuICAgIFwiaWNvbi1vcGFjaXR5XCI6IHtcbiAgICAgIFwiZG9jXCI6IFwiVGhlIG9wYWNpdHkgYXQgd2hpY2ggdGhlIGljb24gd2lsbCBiZSBkcmF3bi5cIixcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwibWF4aW11bVwiOiAxLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ6b29tLWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInByb3BlcnR5LWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImljb24taW1hZ2VcIlxuICAgICAgXSxcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjEwLjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCIyLjAuMVwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMi4wLjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC4xLjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjMzLjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCI1LjAuMFwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMy41LjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC40LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcImljb24tY29sb3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiem9vbS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJwcm9wZXJ0eS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcImRvY1wiOiBcIlRoZSBjb2xvciBvZiB0aGUgaWNvbi4gVGhpcyBjYW4gb25seSBiZSB1c2VkIHdpdGggc2RmIGljb25zLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgICBdLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAgXCJqc1wiOiBcIjAuMTAuMFwiLFxuICAgICAgICAgIFwiYW5kcm9pZFwiOiBcIjIuMC4xXCIsXG4gICAgICAgICAgXCJpb3NcIjogXCIyLjAuMFwiLFxuICAgICAgICAgIFwibWFjb3NcIjogXCIwLjEuMFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG4gICAgICAgICAgXCJqc1wiOiBcIjAuMzMuMFwiLFxuICAgICAgICAgIFwiYW5kcm9pZFwiOiBcIjUuMC4wXCIsXG4gICAgICAgICAgXCJpb3NcIjogXCIzLjUuMFwiLFxuICAgICAgICAgIFwibWFjb3NcIjogXCIwLjQuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiaWNvbi1oYWxvLWNvbG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXG4gICAgICBcImRlZmF1bHRcIjogXCJyZ2JhKDAsIDAsIDAsIDApXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInpvb20tZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwicHJvcGVydHktZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJUaGUgY29sb3Igb2YgdGhlIGljb24ncyBoYWxvLiBJY29uIGhhbG9zIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBTREYgaWNvbnMuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJpY29uLWltYWdlXCJcbiAgICAgIF0sXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4xMC4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiMi4wLjFcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjIuMC4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuMS4wXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4zMy4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiNS4wLjBcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjMuNS4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuNC4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJpY29uLWhhbG8td2lkdGhcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ6b29tLWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInByb3BlcnR5LWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwidW5pdHNcIjogXCJwaXhlbHNcIixcbiAgICAgIFwiZG9jXCI6IFwiRGlzdGFuY2Ugb2YgaGFsbyB0byB0aGUgaWNvbiBvdXRsaW5lLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgICBdLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAgXCJqc1wiOiBcIjAuMTAuMFwiLFxuICAgICAgICAgIFwiYW5kcm9pZFwiOiBcIjIuMC4xXCIsXG4gICAgICAgICAgXCJpb3NcIjogXCIyLjAuMFwiLFxuICAgICAgICAgIFwibWFjb3NcIjogXCIwLjEuMFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG4gICAgICAgICAgXCJqc1wiOiBcIjAuMzMuMFwiLFxuICAgICAgICAgIFwiYW5kcm9pZFwiOiBcIjUuMC4wXCIsXG4gICAgICAgICAgXCJpb3NcIjogXCIzLjUuMFwiLFxuICAgICAgICAgIFwibWFjb3NcIjogXCIwLjQuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiaWNvbi1oYWxvLWJsdXJcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ6b29tLWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInByb3BlcnR5LWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwidW5pdHNcIjogXCJwaXhlbHNcIixcbiAgICAgIFwiZG9jXCI6IFwiRmFkZSBvdXQgdGhlIGhhbG8gdG93YXJkcyB0aGUgb3V0c2lkZS5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImljb24taW1hZ2VcIlxuICAgICAgXSxcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjEwLjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCIyLjAuMVwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMi4wLjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC4xLjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjMzLjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCI1LjAuMFwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMy41LjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC40LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcImljb24tdHJhbnNsYXRlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcInZhbHVlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImxlbmd0aFwiOiAyLFxuICAgICAgXCJkZWZhdWx0XCI6IFtcbiAgICAgICAgMCxcbiAgICAgICAgMFxuICAgICAgXSxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiem9vbS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCIsXG4gICAgICBcImRvY1wiOiBcIkRpc3RhbmNlIHRoYXQgdGhlIGljb24ncyBhbmNob3IgaXMgbW92ZWQgZnJvbSBpdHMgb3JpZ2luYWwgcGxhY2VtZW50LiBQb3NpdGl2ZSB2YWx1ZXMgaW5kaWNhdGUgcmlnaHQgYW5kIGRvd24sIHdoaWxlIG5lZ2F0aXZlIHZhbHVlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cC5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImljb24taW1hZ2VcIlxuICAgICAgXSxcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjEwLjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCIyLjAuMVwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMi4wLjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC4xLjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge31cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiaWNvbi10cmFuc2xhdGUtYW5jaG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwiem9vbS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ2YWx1ZXNcIjoge1xuICAgICAgICBcIm1hcFwiOiB7XG4gICAgICAgICAgICBcImRvY1wiOiBcIkljb25zIGFyZSB0cmFuc2xhdGVkIHJlbGF0aXZlIHRvIHRoZSBtYXAuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJ2aWV3cG9ydFwiOiB7XG4gICAgICAgICAgICBcImRvY1wiOiBcIkljb25zIGFyZSB0cmFuc2xhdGVkIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydC5cIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJkb2NcIjogXCJDb250cm9scyB0aGUgdHJhbnNsYXRpb24gcmVmZXJlbmNlIHBvaW50LlwiLFxuICAgICAgXCJkZWZhdWx0XCI6IFwibWFwXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJpY29uLWltYWdlXCIsXG4gICAgICAgIFwiaWNvbi10cmFuc2xhdGVcIlxuICAgICAgXSxcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjEwLjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCIyLjAuMVwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMi4wLjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC4xLjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge31cbiAgICAgIH1cbiAgICB9LFxuICAgIFwidGV4dC1vcGFjaXR5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgb3BhY2l0eSBhdCB3aGljaCB0aGUgdGV4dCB3aWxsIGJlIGRyYXduLlwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwibWF4aW11bVwiOiAxLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ6b29tLWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInByb3BlcnR5LWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXSxcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjEwLjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCIyLjAuMVwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMi4wLjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC4xLjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjMzLjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCI1LjAuMFwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMy41LjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC40LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcInRleHQtY29sb3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGNvbG9yIHdpdGggd2hpY2ggdGhlIHRleHQgd2lsbCBiZSBkcmF3bi5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiem9vbS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJwcm9wZXJ0eS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF0sXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4xMC4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiMi4wLjFcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjIuMC4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuMS4wXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4zMy4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiNS4wLjBcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjMuNS4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuNC4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJ0ZXh0LWhhbG8tY29sb3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcInJnYmEoMCwgMCwgMCwgMClcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiem9vbS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJwcm9wZXJ0eS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcImRvY1wiOiBcIlRoZSBjb2xvciBvZiB0aGUgdGV4dCdzIGhhbG8sIHdoaWNoIGhlbHBzIGl0IHN0YW5kIG91dCBmcm9tIGJhY2tncm91bmRzLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAgXCJqc1wiOiBcIjAuMTAuMFwiLFxuICAgICAgICAgIFwiYW5kcm9pZFwiOiBcIjIuMC4xXCIsXG4gICAgICAgICAgXCJpb3NcIjogXCIyLjAuMFwiLFxuICAgICAgICAgIFwibWFjb3NcIjogXCIwLjEuMFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG4gICAgICAgICAgXCJqc1wiOiBcIjAuMzMuMFwiLFxuICAgICAgICAgIFwiYW5kcm9pZFwiOiBcIjUuMC4wXCIsXG4gICAgICAgICAgXCJpb3NcIjogXCIzLjUuMFwiLFxuICAgICAgICAgIFwibWFjb3NcIjogXCIwLjQuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwidGV4dC1oYWxvLXdpZHRoXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiem9vbS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJwcm9wZXJ0eS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCIsXG4gICAgICBcImRvY1wiOiBcIkRpc3RhbmNlIG9mIGhhbG8gdG8gdGhlIGZvbnQgb3V0bGluZS4gTWF4IHRleHQgaGFsbyB3aWR0aCBpcyAxLzQgb2YgdGhlIGZvbnQtc2l6ZS5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXSxcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjEwLjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCIyLjAuMVwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMi4wLjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC4xLjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjMzLjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCI1LjAuMFwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMy41LjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC40LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcInRleHQtaGFsby1ibHVyXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiem9vbS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJwcm9wZXJ0eS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBoYWxvJ3MgZmFkZW91dCBkaXN0YW5jZSB0b3dhcmRzIHRoZSBvdXRzaWRlLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAgXCJqc1wiOiBcIjAuMTAuMFwiLFxuICAgICAgICAgIFwiYW5kcm9pZFwiOiBcIjIuMC4xXCIsXG4gICAgICAgICAgXCJpb3NcIjogXCIyLjAuMFwiLFxuICAgICAgICAgIFwibWFjb3NcIjogXCIwLjEuMFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG4gICAgICAgICAgXCJqc1wiOiBcIjAuMzMuMFwiLFxuICAgICAgICAgIFwiYW5kcm9pZFwiOiBcIjUuMC4wXCIsXG4gICAgICAgICAgXCJpb3NcIjogXCIzLjUuMFwiLFxuICAgICAgICAgIFwibWFjb3NcIjogXCIwLjQuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwidGV4dC10cmFuc2xhdGVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwidmFsdWVcIjogXCJudW1iZXJcIixcbiAgICAgIFwibGVuZ3RoXCI6IDIsXG4gICAgICBcImRlZmF1bHRcIjogW1xuICAgICAgICAwLFxuICAgICAgICAwXG4gICAgICBdLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ6b29tLWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwidW5pdHNcIjogXCJwaXhlbHNcIixcbiAgICAgIFwiZG9jXCI6IFwiRGlzdGFuY2UgdGhhdCB0aGUgdGV4dCdzIGFuY2hvciBpcyBtb3ZlZCBmcm9tIGl0cyBvcmlnaW5hbCBwbGFjZW1lbnQuIFBvc2l0aXZlIHZhbHVlcyBpbmRpY2F0ZSByaWdodCBhbmQgZG93biwgd2hpbGUgbmVnYXRpdmUgdmFsdWVzIGluZGljYXRlIGxlZnQgYW5kIHVwLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAgXCJqc1wiOiBcIjAuMTAuMFwiLFxuICAgICAgICAgIFwiYW5kcm9pZFwiOiBcIjIuMC4xXCIsXG4gICAgICAgICAgXCJpb3NcIjogXCIyLjAuMFwiLFxuICAgICAgICAgIFwibWFjb3NcIjogXCIwLjEuMFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7fVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJ0ZXh0LXRyYW5zbGF0ZS1hbmNob3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ6b29tLWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInZhbHVlc1wiOiB7XG4gICAgICAgIFwibWFwXCI6IHtcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIHRleHQgaXMgdHJhbnNsYXRlZCByZWxhdGl2ZSB0byB0aGUgbWFwLlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwidmlld3BvcnRcIjoge1xuICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgdGV4dCBpcyB0cmFuc2xhdGVkIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydC5cIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJkb2NcIjogXCJDb250cm9scyB0aGUgdHJhbnNsYXRpb24gcmVmZXJlbmNlIHBvaW50LlwiLFxuICAgICAgXCJkZWZhdWx0XCI6IFwibWFwXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCIsXG4gICAgICAgIFwidGV4dC10cmFuc2xhdGVcIlxuICAgICAgXSxcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjEwLjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCIyLjAuMVwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMi4wLjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC4xLjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge31cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIFwicGFpbnRfcmFzdGVyXCI6IHtcbiAgICBcInJhc3Rlci1vcGFjaXR5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgb3BhY2l0eSBhdCB3aGljaCB0aGUgaW1hZ2Ugd2lsbCBiZSBkcmF3bi5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiAxLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcIm1heGltdW1cIjogMSxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiem9vbS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4xMC4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiMi4wLjFcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjIuMC4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuMS4wXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHt9XG4gICAgICB9XG4gICAgfSxcbiAgICBcInJhc3Rlci1odWUtcm90YXRlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcInBlcmlvZFwiOiAzNjAsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInpvb20tZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcImRlZ3JlZXNcIixcbiAgICAgIFwiZG9jXCI6IFwiUm90YXRlcyBodWVzIGFyb3VuZCB0aGUgY29sb3Igd2hlZWwuXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4xMC4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiMi4wLjFcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjIuMC4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuMS4wXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHt9XG4gICAgICB9XG4gICAgfSxcbiAgICBcInJhc3Rlci1icmlnaHRuZXNzLW1pblwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiem9vbS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJJbmNyZWFzZSBvciByZWR1Y2UgdGhlIGJyaWdodG5lc3Mgb2YgdGhlIGltYWdlLiBUaGUgdmFsdWUgaXMgdGhlIG1pbmltdW0gYnJpZ2h0bmVzcy5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcIm1heGltdW1cIjogMSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAgXCJqc1wiOiBcIjAuMTAuMFwiLFxuICAgICAgICAgIFwiYW5kcm9pZFwiOiBcIjIuMC4xXCIsXG4gICAgICAgICAgXCJpb3NcIjogXCIyLjAuMFwiLFxuICAgICAgICAgIFwibWFjb3NcIjogXCIwLjEuMFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7fVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJyYXN0ZXItYnJpZ2h0bmVzcy1tYXhcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInpvb20tZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiSW5jcmVhc2Ugb3IgcmVkdWNlIHRoZSBicmlnaHRuZXNzIG9mIHRoZSBpbWFnZS4gVGhlIHZhbHVlIGlzIHRoZSBtYXhpbXVtIGJyaWdodG5lc3MuXCIsXG4gICAgICBcImRlZmF1bHRcIjogMSxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJtYXhpbXVtXCI6IDEsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjEwLjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCIyLjAuMVwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMi4wLjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC4xLjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge31cbiAgICAgIH1cbiAgICB9LFxuICAgIFwicmFzdGVyLXNhdHVyYXRpb25cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRvY1wiOiBcIkluY3JlYXNlIG9yIHJlZHVjZSB0aGUgc2F0dXJhdGlvbiBvZiB0aGUgaW1hZ2UuXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwibWluaW11bVwiOiAtMSxcbiAgICAgIFwibWF4aW11bVwiOiAxLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ6b29tLWZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIFwianNcIjogXCIwLjEwLjBcIixcbiAgICAgICAgICBcImFuZHJvaWRcIjogXCIyLjAuMVwiLFxuICAgICAgICAgIFwiaW9zXCI6IFwiMi4wLjBcIixcbiAgICAgICAgICBcIm1hY29zXCI6IFwiMC4xLjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge31cbiAgICAgIH1cbiAgICB9LFxuICAgIFwicmFzdGVyLWNvbnRyYXN0XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkb2NcIjogXCJJbmNyZWFzZSBvciByZWR1Y2UgdGhlIGNvbnRyYXN0IG9mIHRoZSBpbWFnZS5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJtaW5pbXVtXCI6IC0xLFxuICAgICAgXCJtYXhpbXVtXCI6IDEsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInpvb20tZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAgXCJqc1wiOiBcIjAuMTAuMFwiLFxuICAgICAgICAgIFwiYW5kcm9pZFwiOiBcIjIuMC4xXCIsXG4gICAgICAgICAgXCJpb3NcIjogXCIyLjAuMFwiLFxuICAgICAgICAgIFwibWFjb3NcIjogXCIwLjEuMFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7fVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJyYXN0ZXItZmFkZS1kdXJhdGlvblwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAzMDAsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiem9vbS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInVuaXRzXCI6IFwibWlsbGlzZWNvbmRzXCIsXG4gICAgICBcImRvY1wiOiBcIkZhZGUgZHVyYXRpb24gd2hlbiBhIG5ldyB0aWxlIGlzIGFkZGVkLlwiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAgXCJqc1wiOiBcIjAuMTAuMFwiLFxuICAgICAgICAgIFwiYW5kcm9pZFwiOiBcIjIuMC4xXCIsXG4gICAgICAgICAgXCJpb3NcIjogXCIyLjAuMFwiLFxuICAgICAgICAgIFwibWFjb3NcIjogXCIwLjEuMFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7fVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgXCJwYWludF9iYWNrZ3JvdW5kXCI6IHtcbiAgICBcImJhY2tncm91bmQtY29sb3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGNvbG9yIHdpdGggd2hpY2ggdGhlIGJhY2tncm91bmQgd2lsbCBiZSBkcmF3bi5cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiem9vbS1mdW5jdGlvblwiOiB0cnVlLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgIFwiIVwiOiBcImJhY2tncm91bmQtcGF0dGVyblwiXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4xMC4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiMi4wLjFcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjIuMC4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuMS4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJiYWNrZ3JvdW5kLXBhdHRlcm5cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInpvb20tZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJOYW1lIG9mIGltYWdlIGluIHNwcml0ZSB0byB1c2UgZm9yIGRyYXdpbmcgYW4gaW1hZ2UgYmFja2dyb3VuZC4gRm9yIHNlYW1sZXNzIHBhdHRlcm5zLCBpbWFnZSB3aWR0aCBhbmQgaGVpZ2h0IG11c3QgYmUgYSBmYWN0b3Igb2YgdHdvICgyLCA0LCA4LCAuLi4sIDUxMikuXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBcImpzXCI6IFwiMC4xMC4wXCIsXG4gICAgICAgICAgXCJhbmRyb2lkXCI6IFwiMi4wLjFcIixcbiAgICAgICAgICBcImlvc1wiOiBcIjIuMC4wXCIsXG4gICAgICAgICAgXCJtYWNvc1wiOiBcIjAuMS4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJiYWNrZ3JvdW5kLW9wYWNpdHlcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMSxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJtYXhpbXVtXCI6IDEsXG4gICAgICBcImRvY1wiOiBcIlRoZSBvcGFjaXR5IGF0IHdoaWNoIHRoZSBiYWNrZ3JvdW5kIHdpbGwgYmUgZHJhd24uXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInpvb20tZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAgXCJqc1wiOiBcIjAuMTAuMFwiLFxuICAgICAgICAgIFwiYW5kcm9pZFwiOiBcIjIuMC4xXCIsXG4gICAgICAgICAgXCJpb3NcIjogXCIyLjAuMFwiLFxuICAgICAgICAgIFwibWFjb3NcIjogXCIwLjEuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIFwidHJhbnNpdGlvblwiOiB7XG4gICAgXCJkdXJhdGlvblwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAzMDAsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwidW5pdHNcIjogXCJtaWxsaXNlY29uZHNcIixcbiAgICAgIFwiZG9jXCI6IFwiVGltZSBhbGxvdHRlZCBmb3IgdHJhbnNpdGlvbnMgdG8gY29tcGxldGUuXCJcbiAgICB9LFxuICAgIFwiZGVsYXlcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJ1bml0c1wiOiBcIm1pbGxpc2Vjb25kc1wiLFxuICAgICAgXCJkb2NcIjogXCJMZW5ndGggb2YgdGltZSBiZWZvcmUgYSB0cmFuc2l0aW9uIGJlZ2lucy5cIlxuICAgIH1cbiAgfVxufVxuIiwiXG4vLyBDb25zdGFudHNcbmNvbnN0IFhuID0gMC45NTA0NzAsIC8vIEQ2NSBzdGFuZGFyZCByZWZlcmVudFxuICAgIFluID0gMSxcbiAgICBabiA9IDEuMDg4ODMwLFxuICAgIHQwID0gNCAvIDI5LFxuICAgIHQxID0gNiAvIDI5LFxuICAgIHQyID0gMyAqIHQxICogdDEsXG4gICAgdDMgPSB0MSAqIHQxICogdDEsXG4gICAgZGVnMnJhZCA9IE1hdGguUEkgLyAxODAsXG4gICAgcmFkMmRlZyA9IDE4MCAvIE1hdGguUEk7XG5cbi8vIFV0aWxpdGllc1xuZnVuY3Rpb24geHl6MmxhYih0KSB7XG4gICAgcmV0dXJuIHQgPiB0MyA/IE1hdGgucG93KHQsIDEgLyAzKSA6IHQgLyB0MiArIHQwO1xufVxuXG5mdW5jdGlvbiBsYWIyeHl6KHQpIHtcbiAgICByZXR1cm4gdCA+IHQxID8gdCAqIHQgKiB0IDogdDIgKiAodCAtIHQwKTtcbn1cblxuZnVuY3Rpb24geHl6MnJnYih4KSB7XG4gICAgcmV0dXJuIDI1NSAqICh4IDw9IDAuMDAzMTMwOCA/IDEyLjkyICogeCA6IDEuMDU1ICogTWF0aC5wb3coeCwgMSAvIDIuNCkgLSAwLjA1NSk7XG59XG5cbmZ1bmN0aW9uIHJnYjJ4eXooeCkge1xuICAgIHggLz0gMjU1O1xuICAgIHJldHVybiB4IDw9IDAuMDQwNDUgPyB4IC8gMTIuOTIgOiBNYXRoLnBvdygoeCArIDAuMDU1KSAvIDEuMDU1LCAyLjQpO1xufVxuXG4vLyBMQUJcbmZ1bmN0aW9uIHJnYlRvTGFiKHJnYkNvbG9yKSB7XG4gICAgY29uc3QgYiA9IHJnYjJ4eXoocmdiQ29sb3JbMF0pLFxuICAgICAgICBhID0gcmdiMnh5eihyZ2JDb2xvclsxXSksXG4gICAgICAgIGwgPSByZ2IyeHl6KHJnYkNvbG9yWzJdKSxcbiAgICAgICAgeCA9IHh5ejJsYWIoKDAuNDEyNDU2NCAqIGIgKyAwLjM1NzU3NjEgKiBhICsgMC4xODA0Mzc1ICogbCkgLyBYbiksXG4gICAgICAgIHkgPSB4eXoybGFiKCgwLjIxMjY3MjkgKiBiICsgMC43MTUxNTIyICogYSArIDAuMDcyMTc1MCAqIGwpIC8gWW4pLFxuICAgICAgICB6ID0geHl6MmxhYigoMC4wMTkzMzM5ICogYiArIDAuMTE5MTkyMCAqIGEgKyAwLjk1MDMwNDEgKiBsKSAvIFpuKTtcblxuICAgIHJldHVybiBbXG4gICAgICAgIDExNiAqIHkgLSAxNixcbiAgICAgICAgNTAwICogKHggLSB5KSxcbiAgICAgICAgMjAwICogKHkgLSB6KSxcbiAgICAgICAgcmdiQ29sb3JbM11cbiAgICBdO1xufVxuXG5mdW5jdGlvbiBsYWJUb1JnYihsYWJDb2xvcikge1xuICAgIGxldCB5ID0gKGxhYkNvbG9yWzBdICsgMTYpIC8gMTE2LFxuICAgICAgICB4ID0gaXNOYU4obGFiQ29sb3JbMV0pID8geSA6IHkgKyBsYWJDb2xvclsxXSAvIDUwMCxcbiAgICAgICAgeiA9IGlzTmFOKGxhYkNvbG9yWzJdKSA/IHkgOiB5IC0gbGFiQ29sb3JbMl0gLyAyMDA7XG4gICAgeSA9IFluICogbGFiMnh5eih5KTtcbiAgICB4ID0gWG4gKiBsYWIyeHl6KHgpO1xuICAgIHogPSBabiAqIGxhYjJ4eXooeik7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgeHl6MnJnYigzLjI0MDQ1NDIgKiB4IC0gMS41MzcxMzg1ICogeSAtIDAuNDk4NTMxNCAqIHopLCAvLyBENjUgLT4gc1JHQlxuICAgICAgICB4eXoycmdiKC0wLjk2OTI2NjAgKiB4ICsgMS44NzYwMTA4ICogeSArIDAuMDQxNTU2MCAqIHopLFxuICAgICAgICB4eXoycmdiKDAuMDU1NjQzNCAqIHggLSAwLjIwNDAyNTkgKiB5ICsgMS4wNTcyMjUyICogeiksXG4gICAgICAgIGxhYkNvbG9yWzNdXG4gICAgXTtcbn1cblxuLy8gSENMXG5mdW5jdGlvbiByZ2JUb0hjbChyZ2JDb2xvcikge1xuICAgIGNvbnN0IGxhYkNvbG9yID0gcmdiVG9MYWIocmdiQ29sb3IpO1xuICAgIGNvbnN0IGwgPSBsYWJDb2xvclswXSxcbiAgICAgICAgYSA9IGxhYkNvbG9yWzFdLFxuICAgICAgICBiID0gbGFiQ29sb3JbMl07XG4gICAgY29uc3QgaCA9IE1hdGguYXRhbjIoYiwgYSkgKiByYWQyZGVnO1xuICAgIHJldHVybiBbXG4gICAgICAgIGggPCAwID8gaCArIDM2MCA6IGgsXG4gICAgICAgIE1hdGguc3FydChhICogYSArIGIgKiBiKSxcbiAgICAgICAgbCxcbiAgICAgICAgcmdiQ29sb3JbM11cbiAgICBdO1xufVxuXG5mdW5jdGlvbiBoY2xUb1JnYihoY2xDb2xvcikge1xuICAgIGNvbnN0IGggPSBoY2xDb2xvclswXSAqIGRlZzJyYWQsXG4gICAgICAgIGMgPSBoY2xDb2xvclsxXSxcbiAgICAgICAgbCA9IGhjbENvbG9yWzJdO1xuICAgIHJldHVybiBsYWJUb1JnYihbXG4gICAgICAgIGwsXG4gICAgICAgIE1hdGguY29zKGgpICogYyxcbiAgICAgICAgTWF0aC5zaW4oaCkgKiBjLFxuICAgICAgICBoY2xDb2xvclszXVxuICAgIF0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBsYWI6IHtcbiAgICAgICAgZm9yd2FyZDogcmdiVG9MYWIsXG4gICAgICAgIHJldmVyc2U6IGxhYlRvUmdiXG4gICAgfSxcbiAgICBoY2w6IHtcbiAgICAgICAgZm9yd2FyZDogcmdiVG9IY2wsXG4gICAgICAgIHJldmVyc2U6IGhjbFRvUmdiXG4gICAgfVxufTtcbiIsIlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3V0cHV0LCAuLi5pbnB1dHMpIHtcbiAgICBmb3IgKGNvbnN0IGlucHV0IG9mIGlucHV0cykge1xuICAgICAgICBmb3IgKGNvbnN0IGsgaW4gaW5wdXQpIHtcbiAgICAgICAgICAgIG91dHB1dFtrXSA9IGlucHV0W2tdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuIiwiXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFR5cGUodmFsKSB7XG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIE51bWJlcikge1xuICAgICAgICByZXR1cm4gJ251bWJlcic7XG4gICAgfSBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuICdzdHJpbmcnO1xuICAgIH0gZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgQm9vbGVhbikge1xuICAgICAgICByZXR1cm4gJ2Jvb2xlYW4nO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIHJldHVybiAnYXJyYXknO1xuICAgIH0gZWxzZSBpZiAodmFsID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWw7XG4gICAgfVxufTtcbiIsIlxubW9kdWxlLmV4cG9ydHMgPSBpbnRlcnBvbGF0ZTtcblxuZnVuY3Rpb24gaW50ZXJwb2xhdGUoYSwgYiwgdCkge1xuICAgIHJldHVybiAoYSAqICgxIC0gdCkpICsgKGIgKiB0KTtcbn1cblxuaW50ZXJwb2xhdGUubnVtYmVyID0gaW50ZXJwb2xhdGU7XG5cbmludGVycG9sYXRlLnZlYzIgPSBmdW5jdGlvbihmcm9tLCB0bywgdCkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGludGVycG9sYXRlKGZyb21bMF0sIHRvWzBdLCB0KSxcbiAgICAgICAgaW50ZXJwb2xhdGUoZnJvbVsxXSwgdG9bMV0sIHQpXG4gICAgXTtcbn07XG5cbi8qXG4gKiBJbnRlcnBvbGF0ZSBiZXR3ZWVuIHR3byBjb2xvcnMgZ2l2ZW4gYXMgNC1lbGVtZW50IGFycmF5cy5cbiAqXG4gKiBAcGFyYW0ge0NvbG9yfSBmcm9tXG4gKiBAcGFyYW0ge0NvbG9yfSB0b1xuICogQHBhcmFtIHtudW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBmYWN0b3IgYmV0d2VlbiAwIGFuZCAxXG4gKiBAcmV0dXJucyB7Q29sb3J9IGludGVycG9sYXRlZCBjb2xvclxuICovXG5pbnRlcnBvbGF0ZS5jb2xvciA9IGZ1bmN0aW9uKGZyb20sIHRvLCB0KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgaW50ZXJwb2xhdGUoZnJvbVswXSwgdG9bMF0sIHQpLFxuICAgICAgICBpbnRlcnBvbGF0ZShmcm9tWzFdLCB0b1sxXSwgdCksXG4gICAgICAgIGludGVycG9sYXRlKGZyb21bMl0sIHRvWzJdLCB0KSxcbiAgICAgICAgaW50ZXJwb2xhdGUoZnJvbVszXSwgdG9bM10sIHQpXG4gICAgXTtcbn07XG5cbmludGVycG9sYXRlLmFycmF5ID0gZnVuY3Rpb24oZnJvbSwgdG8sIHQpIHtcbiAgICByZXR1cm4gZnJvbS5tYXAoKGQsIGkpID0+IHtcbiAgICAgICAgcmV0dXJuIGludGVycG9sYXRlKGQsIHRvW2ldLCB0KTtcbiAgICB9KTtcbn07XG4iLCIvLyAgICAgIFxuXG5jb25zdCBwYXJzZUNvbG9yU3RyaW5nID0gcmVxdWlyZSgnY3NzY29sb3JwYXJzZXInKS5wYXJzZUNTU0NvbG9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlQ29sb3IoaW5wdXQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCByZ2JhID0gcGFyc2VDb2xvclN0cmluZyhpbnB1dCk7XG4gICAgICAgIGlmICghcmdiYSkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG5cbiAgICAgICAgLy8gR0wgZXhwZWN0cyBhbGwgY29tcG9uZW50cyB0byBiZSBpbiB0aGUgcmFuZ2UgWzAsIDFdIGFuZCB0byBiZVxuICAgICAgICAvLyBtdWx0aXBsZWQgYnkgdGhlIGFscGhhIHZhbHVlLlxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgcmdiYVswXSAvIDI1NSAqIHJnYmFbM10sXG4gICAgICAgICAgICByZ2JhWzFdIC8gMjU1ICogcmdiYVszXSxcbiAgICAgICAgICAgIHJnYmFbMl0gLyAyNTUgKiByZ2JhWzNdLFxuICAgICAgICAgICAgcmdiYVszXVxuICAgICAgICBdO1xuXG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn07XG4iLCJcbi8vIFR1cm4ganNvbmxpbnQtbGluZXMtcHJpbWl0aXZlcyBvYmplY3RzIGludG8gcHJpbWl0aXZlIG9iamVjdHNcbmZ1bmN0aW9uIHVuYnVuZGxlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nIHx8IHZhbHVlIGluc3RhbmNlb2YgQm9vbGVhbikge1xuICAgICAgICByZXR1cm4gdmFsdWUudmFsdWVPZigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRlZXBVbmJ1bmRsZSh2YWx1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUubWFwKGRlZXBVbmJ1bmRsZSk7XG4gICAgfVxuICAgIHJldHVybiB1bmJ1bmRsZSh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdW5idW5kbGU7XG5tb2R1bGUuZXhwb3J0cy5kZWVwID0gZGVlcFVuYnVuZGxlO1xuIiwiXG5jb25zdCBWYWxpZGF0aW9uRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci92YWxpZGF0aW9uX2Vycm9yJyk7XG5jb25zdCBnZXRUeXBlID0gcmVxdWlyZSgnLi4vdXRpbC9nZXRfdHlwZScpO1xuY29uc3QgZXh0ZW5kID0gcmVxdWlyZSgnLi4vdXRpbC9leHRlbmQnKTtcbmNvbnN0IHVuYnVuZGxlID0gcmVxdWlyZSgnLi4vdXRpbC91bmJ1bmRsZV9qc29ubGludCcpO1xuY29uc3Qge2lzRXhwcmVzc2lvbn0gPSByZXF1aXJlKCcuLi9leHByZXNzaW9uJyk7XG5jb25zdCB7aXNGdW5jdGlvbn0gPSByZXF1aXJlKCcuLi9mdW5jdGlvbicpO1xuXG4vLyBNYWluIHJlY3Vyc2l2ZSB2YWxpZGF0aW9uIGZ1bmN0aW9uLiBUcmFja3M6XG4vL1xuLy8gLSBrZXk6IHN0cmluZyByZXByZXNlbnRpbmcgbG9jYXRpb24gb2YgdmFsaWRhdGlvbiBpbiBzdHlsZSB0cmVlLiBVc2VkIG9ubHlcbi8vICAgZm9yIG1vcmUgaW5mb3JtYXRpdmUgZXJyb3IgcmVwb3J0aW5nLlxuLy8gLSB2YWx1ZTogY3VycmVudCB2YWx1ZSBmcm9tIHN0eWxlIGJlaW5nIGV2YWx1YXRlZC4gTWF5IGJlIGFueXRoaW5nIGZyb20gYVxuLy8gICBoaWdoIGxldmVsIG9iamVjdCB0aGF0IG5lZWRzIHRvIGJlIGRlc2NlbmRlZCBpbnRvIGRlZXBlciBvciBhIHNpbXBsZVxuLy8gICBzY2FsYXIgdmFsdWUuXG4vLyAtIHZhbHVlU3BlYzogY3VycmVudCBzcGVjIGJlaW5nIGV2YWx1YXRlZC4gVHJhY2tzIHZhbHVlLlxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHZhbGlkYXRlKG9wdGlvbnMpIHtcblxuICAgIGNvbnN0IHZhbGlkYXRlRnVuY3Rpb24gPSByZXF1aXJlKCcuL3ZhbGlkYXRlX2Z1bmN0aW9uJyk7XG4gICAgY29uc3QgdmFsaWRhdGVFeHByZXNzaW9uID0gcmVxdWlyZSgnLi92YWxpZGF0ZV9leHByZXNzaW9uJyk7XG4gICAgY29uc3QgdmFsaWRhdGVPYmplY3QgPSByZXF1aXJlKCcuL3ZhbGlkYXRlX29iamVjdCcpO1xuICAgIGNvbnN0IFZBTElEQVRPUlMgPSB7XG4gICAgICAgICcqJzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0sXG4gICAgICAgICdhcnJheSc6IHJlcXVpcmUoJy4vdmFsaWRhdGVfYXJyYXknKSxcbiAgICAgICAgJ2Jvb2xlYW4nOiByZXF1aXJlKCcuL3ZhbGlkYXRlX2Jvb2xlYW4nKSxcbiAgICAgICAgJ251bWJlcic6IHJlcXVpcmUoJy4vdmFsaWRhdGVfbnVtYmVyJyksXG4gICAgICAgICdjb2xvcic6IHJlcXVpcmUoJy4vdmFsaWRhdGVfY29sb3InKSxcbiAgICAgICAgJ2NvbnN0YW50cyc6IHJlcXVpcmUoJy4vdmFsaWRhdGVfY29uc3RhbnRzJyksXG4gICAgICAgICdlbnVtJzogcmVxdWlyZSgnLi92YWxpZGF0ZV9lbnVtJyksXG4gICAgICAgICdmaWx0ZXInOiByZXF1aXJlKCcuL3ZhbGlkYXRlX2ZpbHRlcicpLFxuICAgICAgICAnZnVuY3Rpb24nOiByZXF1aXJlKCcuL3ZhbGlkYXRlX2Z1bmN0aW9uJyksXG4gICAgICAgICdsYXllcic6IHJlcXVpcmUoJy4vdmFsaWRhdGVfbGF5ZXInKSxcbiAgICAgICAgJ29iamVjdCc6IHJlcXVpcmUoJy4vdmFsaWRhdGVfb2JqZWN0JyksXG4gICAgICAgICdzb3VyY2UnOiByZXF1aXJlKCcuL3ZhbGlkYXRlX3NvdXJjZScpLFxuICAgICAgICAnbGlnaHQnOiByZXF1aXJlKCcuL3ZhbGlkYXRlX2xpZ2h0JyksXG4gICAgICAgICdzdHJpbmcnOiByZXF1aXJlKCcuL3ZhbGlkYXRlX3N0cmluZycpXG4gICAgfTtcblxuICAgIGNvbnN0IHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICBjb25zdCB2YWx1ZVNwZWMgPSBvcHRpb25zLnZhbHVlU3BlYztcbiAgICBjb25zdCBrZXkgPSBvcHRpb25zLmtleTtcbiAgICBjb25zdCBzdHlsZVNwZWMgPSBvcHRpb25zLnN0eWxlU3BlYztcbiAgICBjb25zdCBzdHlsZSA9IG9wdGlvbnMuc3R5bGU7XG5cbiAgICBpZiAoZ2V0VHlwZSh2YWx1ZSkgPT09ICdzdHJpbmcnICYmIHZhbHVlWzBdID09PSAnQCcpIHtcbiAgICAgICAgaWYgKHN0eWxlU3BlYy4kdmVyc2lvbiA+IDcpIHtcbiAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnY29uc3RhbnRzIGhhdmUgYmVlbiBkZXByZWNhdGVkIGFzIG9mIHY4JyldO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHZhbHVlIGluIHN0eWxlLmNvbnN0YW50cykpIHtcbiAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnY29uc3RhbnQgXCIlc1wiIG5vdCBmb3VuZCcsIHZhbHVlKV07XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucyA9IGV4dGVuZCh7fSwgb3B0aW9ucywgeyB2YWx1ZTogc3R5bGUuY29uc3RhbnRzW3ZhbHVlXSB9KTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWVTcGVjLmZ1bmN0aW9uICYmIGlzRnVuY3Rpb24odW5idW5kbGUodmFsdWUpKSkge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVGdW5jdGlvbihvcHRpb25zKTtcblxuICAgIH0gZWxzZSBpZiAodmFsdWVTcGVjLmZ1bmN0aW9uICYmIGlzRXhwcmVzc2lvbih1bmJ1bmRsZS5kZWVwKHZhbHVlKSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlRXhwcmVzc2lvbihvcHRpb25zKTtcblxuICAgIH0gZWxzZSBpZiAodmFsdWVTcGVjLnR5cGUgJiYgVkFMSURBVE9SU1t2YWx1ZVNwZWMudHlwZV0pIHtcbiAgICAgICAgcmV0dXJuIFZBTElEQVRPUlNbdmFsdWVTcGVjLnR5cGVdKG9wdGlvbnMpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlT2JqZWN0KGV4dGVuZCh7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgdmFsdWVTcGVjOiB2YWx1ZVNwZWMudHlwZSA/IHN0eWxlU3BlY1t2YWx1ZVNwZWMudHlwZV0gOiB2YWx1ZVNwZWNcbiAgICAgICAgfSkpO1xuICAgIH1cbn07XG4iLCJcbmNvbnN0IGdldFR5cGUgPSByZXF1aXJlKCcuLi91dGlsL2dldF90eXBlJyk7XG5jb25zdCB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vdmFsaWRhdGUnKTtcbmNvbnN0IFZhbGlkYXRpb25FcnJvciA9IHJlcXVpcmUoJy4uL2Vycm9yL3ZhbGlkYXRpb25fZXJyb3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB2YWxpZGF0ZUFycmF5KG9wdGlvbnMpIHtcbiAgICBjb25zdCBhcnJheSA9IG9wdGlvbnMudmFsdWU7XG4gICAgY29uc3QgYXJyYXlTcGVjID0gb3B0aW9ucy52YWx1ZVNwZWM7XG4gICAgY29uc3Qgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuICAgIGNvbnN0IHN0eWxlU3BlYyA9IG9wdGlvbnMuc3R5bGVTcGVjO1xuICAgIGNvbnN0IGtleSA9IG9wdGlvbnMua2V5O1xuICAgIGNvbnN0IHZhbGlkYXRlQXJyYXlFbGVtZW50ID0gb3B0aW9ucy5hcnJheUVsZW1lbnRWYWxpZGF0b3IgfHwgdmFsaWRhdGU7XG5cbiAgICBpZiAoZ2V0VHlwZShhcnJheSkgIT09ICdhcnJheScpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgYXJyYXksICdhcnJheSBleHBlY3RlZCwgJXMgZm91bmQnLCBnZXRUeXBlKGFycmF5KSldO1xuICAgIH1cblxuICAgIGlmIChhcnJheVNwZWMubGVuZ3RoICYmIGFycmF5Lmxlbmd0aCAhPT0gYXJyYXlTcGVjLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBhcnJheSwgJ2FycmF5IGxlbmd0aCAlZCBleHBlY3RlZCwgbGVuZ3RoICVkIGZvdW5kJywgYXJyYXlTcGVjLmxlbmd0aCwgYXJyYXkubGVuZ3RoKV07XG4gICAgfVxuXG4gICAgaWYgKGFycmF5U3BlY1snbWluLWxlbmd0aCddICYmIGFycmF5Lmxlbmd0aCA8IGFycmF5U3BlY1snbWluLWxlbmd0aCddKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGFycmF5LCAnYXJyYXkgbGVuZ3RoIGF0IGxlYXN0ICVkIGV4cGVjdGVkLCBsZW5ndGggJWQgZm91bmQnLCBhcnJheVNwZWNbJ21pbi1sZW5ndGgnXSwgYXJyYXkubGVuZ3RoKV07XG4gICAgfVxuXG4gICAgbGV0IGFycmF5RWxlbWVudFNwZWMgPSB7XG4gICAgICAgIFwidHlwZVwiOiBhcnJheVNwZWMudmFsdWVcbiAgICB9O1xuXG4gICAgaWYgKHN0eWxlU3BlYy4kdmVyc2lvbiA8IDcpIHtcbiAgICAgICAgYXJyYXlFbGVtZW50U3BlYy5mdW5jdGlvbiA9IGFycmF5U3BlYy5mdW5jdGlvbjtcbiAgICB9XG5cbiAgICBpZiAoZ2V0VHlwZShhcnJheVNwZWMudmFsdWUpID09PSAnb2JqZWN0Jykge1xuICAgICAgICBhcnJheUVsZW1lbnRTcGVjID0gYXJyYXlTcGVjLnZhbHVlO1xuICAgIH1cblxuICAgIGxldCBlcnJvcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGVBcnJheUVsZW1lbnQoe1xuICAgICAgICAgICAgYXJyYXk6IGFycmF5LFxuICAgICAgICAgICAgYXJyYXlJbmRleDogaSxcbiAgICAgICAgICAgIHZhbHVlOiBhcnJheVtpXSxcbiAgICAgICAgICAgIHZhbHVlU3BlYzogYXJyYXlFbGVtZW50U3BlYyxcbiAgICAgICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjLFxuICAgICAgICAgICAga2V5OiBgJHtrZXl9WyR7aX1dYFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcnM7XG59O1xuIiwiXG5jb25zdCBnZXRUeXBlID0gcmVxdWlyZSgnLi4vdXRpbC9nZXRfdHlwZScpO1xuY29uc3QgVmFsaWRhdGlvbkVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvdmFsaWRhdGlvbl9lcnJvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHZhbGlkYXRlQm9vbGVhbihvcHRpb25zKSB7XG4gICAgY29uc3QgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgIGNvbnN0IGtleSA9IG9wdGlvbnMua2V5O1xuICAgIGNvbnN0IHR5cGUgPSBnZXRUeXBlKHZhbHVlKTtcblxuICAgIGlmICh0eXBlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdib29sZWFuIGV4cGVjdGVkLCAlcyBmb3VuZCcsIHR5cGUpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gW107XG59O1xuIiwiXG5jb25zdCBWYWxpZGF0aW9uRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci92YWxpZGF0aW9uX2Vycm9yJyk7XG5jb25zdCBnZXRUeXBlID0gcmVxdWlyZSgnLi4vdXRpbC9nZXRfdHlwZScpO1xuY29uc3QgcGFyc2VDU1NDb2xvciA9IHJlcXVpcmUoJ2Nzc2NvbG9ycGFyc2VyJykucGFyc2VDU1NDb2xvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB2YWxpZGF0ZUNvbG9yKG9wdGlvbnMpIHtcbiAgICBjb25zdCBrZXkgPSBvcHRpb25zLmtleTtcbiAgICBjb25zdCB2YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gICAgY29uc3QgdHlwZSA9IGdldFR5cGUodmFsdWUpO1xuXG4gICAgaWYgKHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnY29sb3IgZXhwZWN0ZWQsICVzIGZvdW5kJywgdHlwZSldO1xuICAgIH1cblxuICAgIGlmIChwYXJzZUNTU0NvbG9yKHZhbHVlKSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ2NvbG9yIGV4cGVjdGVkLCBcIiVzXCIgZm91bmQnLCB2YWx1ZSldO1xuICAgIH1cblxuICAgIHJldHVybiBbXTtcbn07XG4iLCJcbmNvbnN0IFZhbGlkYXRpb25FcnJvciA9IHJlcXVpcmUoJy4uL2Vycm9yL3ZhbGlkYXRpb25fZXJyb3InKTtcbmNvbnN0IGdldFR5cGUgPSByZXF1aXJlKCcuLi91dGlsL2dldF90eXBlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdmFsaWRhdGVDb25zdGFudHMob3B0aW9ucykge1xuICAgIGNvbnN0IGtleSA9IG9wdGlvbnMua2V5O1xuICAgIGNvbnN0IGNvbnN0YW50cyA9IG9wdGlvbnMudmFsdWU7XG4gICAgY29uc3Qgc3R5bGVTcGVjID0gb3B0aW9ucy5zdHlsZVNwZWM7XG5cbiAgICBpZiAoc3R5bGVTcGVjLiR2ZXJzaW9uID4gNykge1xuICAgICAgICBpZiAoY29uc3RhbnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBjb25zdGFudHMsICdjb25zdGFudHMgaGF2ZSBiZWVuIGRlcHJlY2F0ZWQgYXMgb2YgdjgnKV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0eXBlID0gZ2V0VHlwZShjb25zdGFudHMpO1xuICAgICAgICBpZiAodHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGNvbnN0YW50cywgJ29iamVjdCBleHBlY3RlZCwgJXMgZm91bmQnLCB0eXBlKV07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBjb25zdGFudE5hbWUgaW4gY29uc3RhbnRzKSB7XG4gICAgICAgICAgICBpZiAoY29uc3RhbnROYW1lWzBdICE9PSAnQCcpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGAke2tleX0uJHtjb25zdGFudE5hbWV9YCwgY29uc3RhbnRzW2NvbnN0YW50TmFtZV0sICdjb25zdGFudHMgbXVzdCBzdGFydCB3aXRoIFwiQFwiJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgfVxuXG59O1xuIiwiXG5jb25zdCBWYWxpZGF0aW9uRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci92YWxpZGF0aW9uX2Vycm9yJyk7XG5jb25zdCB1bmJ1bmRsZSA9IHJlcXVpcmUoJy4uL3V0aWwvdW5idW5kbGVfanNvbmxpbnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB2YWxpZGF0ZUVudW0ob3B0aW9ucykge1xuICAgIGNvbnN0IGtleSA9IG9wdGlvbnMua2V5O1xuICAgIGNvbnN0IHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICBjb25zdCB2YWx1ZVNwZWMgPSBvcHRpb25zLnZhbHVlU3BlYztcbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlU3BlYy52YWx1ZXMpKSB7IC8vIDw9djdcbiAgICAgICAgaWYgKHZhbHVlU3BlYy52YWx1ZXMuaW5kZXhPZih1bmJ1bmRsZSh2YWx1ZSkpID09PSAtMSkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnZXhwZWN0ZWQgb25lIG9mIFslc10sICVzIGZvdW5kJywgdmFsdWVTcGVjLnZhbHVlcy5qb2luKCcsICcpLCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7IC8vID49djhcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHZhbHVlU3BlYy52YWx1ZXMpLmluZGV4T2YodW5idW5kbGUodmFsdWUpKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ2V4cGVjdGVkIG9uZSBvZiBbJXNdLCAlcyBmb3VuZCcsIE9iamVjdC5rZXlzKHZhbHVlU3BlYy52YWx1ZXMpLmpvaW4oJywgJyksIEpTT04uc3RyaW5naWZ5KHZhbHVlKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlcnJvcnM7XG59O1xuIiwiXG5jb25zdCBWYWxpZGF0aW9uRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci92YWxpZGF0aW9uX2Vycm9yJyk7XG5jb25zdCB7Y3JlYXRlRXhwcmVzc2lvbn0gPSByZXF1aXJlKCcuLi9leHByZXNzaW9uJyk7XG5jb25zdCB1bmJ1bmRsZSA9IHJlcXVpcmUoJy4uL3V0aWwvdW5idW5kbGVfanNvbmxpbnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB2YWxpZGF0ZUV4cHJlc3Npb24ob3B0aW9ucykge1xuICAgIGNvbnN0IGV4cHJlc3Npb24gPSBjcmVhdGVFeHByZXNzaW9uKHVuYnVuZGxlLmRlZXAob3B0aW9ucy52YWx1ZSksIG9wdGlvbnMudmFsdWVTcGVjLCBvcHRpb25zLmV4cHJlc3Npb25Db250ZXh0KTtcbiAgICBpZiAoZXhwcmVzc2lvbi5yZXN1bHQgPT09ICdzdWNjZXNzJykge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4cHJlc3Npb24uZXJyb3JzLm1hcCgoZXJyb3IpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBWYWxpZGF0aW9uRXJyb3IoYCR7b3B0aW9ucy5rZXl9JHtlcnJvci5rZXl9YCwgb3B0aW9ucy52YWx1ZSwgZXJyb3IubWVzc2FnZSk7XG4gICAgfSk7XG59O1xuIiwiXG5jb25zdCBWYWxpZGF0aW9uRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci92YWxpZGF0aW9uX2Vycm9yJyk7XG5jb25zdCB2YWxpZGF0ZUV4cHJlc3Npb24gPSByZXF1aXJlKCcuL3ZhbGlkYXRlX2V4cHJlc3Npb24nKTtcbmNvbnN0IHZhbGlkYXRlRW51bSA9IHJlcXVpcmUoJy4vdmFsaWRhdGVfZW51bScpO1xuY29uc3QgZ2V0VHlwZSA9IHJlcXVpcmUoJy4uL3V0aWwvZ2V0X3R5cGUnKTtcbmNvbnN0IHVuYnVuZGxlID0gcmVxdWlyZSgnLi4vdXRpbC91bmJ1bmRsZV9qc29ubGludCcpO1xuY29uc3QgZXh0ZW5kID0gcmVxdWlyZSgnLi4vdXRpbC9leHRlbmQnKTtcbmNvbnN0IHtpc0V4cHJlc3Npb25GaWx0ZXJ9ID0gcmVxdWlyZSgnLi4vZmVhdHVyZV9maWx0ZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB2YWxpZGF0ZUZpbHRlcihvcHRpb25zKSB7XG4gICAgY29uc3QgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgIGNvbnN0IGtleSA9IG9wdGlvbnMua2V5O1xuICAgIGNvbnN0IHN0eWxlU3BlYyA9IG9wdGlvbnMuc3R5bGVTcGVjO1xuICAgIGxldCB0eXBlO1xuXG4gICAgbGV0IGVycm9ycyA9IFtdO1xuXG4gICAgaWYgKGdldFR5cGUodmFsdWUpICE9PSAnYXJyYXknKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnYXJyYXkgZXhwZWN0ZWQsICVzIGZvdW5kJywgZ2V0VHlwZSh2YWx1ZSkpXTtcbiAgICB9XG5cbiAgICBpZiAoaXNFeHByZXNzaW9uRmlsdGVyKHVuYnVuZGxlLmRlZXAodmFsdWUpKSkge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVFeHByZXNzaW9uKGV4dGVuZCh7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgZXhwcmVzc2lvbkNvbnRleHQ6ICdmaWx0ZXInLFxuICAgICAgICAgICAgdmFsdWVTcGVjOiB7IHZhbHVlOiAnYm9vbGVhbicgfVxuICAgICAgICB9KSk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdmaWx0ZXIgYXJyYXkgbXVzdCBoYXZlIGF0IGxlYXN0IDEgZWxlbWVudCcpXTtcbiAgICB9XG5cbiAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlRW51bSh7XG4gICAgICAgIGtleTogYCR7a2V5fVswXWAsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVswXSxcbiAgICAgICAgdmFsdWVTcGVjOiBzdHlsZVNwZWMuZmlsdGVyX29wZXJhdG9yLFxuICAgICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSxcbiAgICAgICAgc3R5bGVTcGVjOiBvcHRpb25zLnN0eWxlU3BlY1xuICAgIH0pKTtcblxuICAgIHN3aXRjaCAodW5idW5kbGUodmFsdWVbMF0pKSB7XG4gICAgY2FzZSAnPCc6XG4gICAgY2FzZSAnPD0nOlxuICAgIGNhc2UgJz4nOlxuICAgIGNhc2UgJz49JzpcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+PSAyICYmIHVuYnVuZGxlKHZhbHVlWzFdKSA9PT0gJyR0eXBlJykge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnXCIkdHlwZVwiIGNhbm5vdCBiZSB1c2Ugd2l0aCBvcGVyYXRvciBcIiVzXCInLCB2YWx1ZVswXSkpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlICc9PSc6XG4gICAgY2FzZSAnIT0nOlxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdmaWx0ZXIgYXJyYXkgZm9yIG9wZXJhdG9yIFwiJXNcIiBtdXN0IGhhdmUgMyBlbGVtZW50cycsIHZhbHVlWzBdKSk7XG4gICAgICAgIH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgJ2luJzpcbiAgICBjYXNlICchaW4nOlxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgIHR5cGUgPSBnZXRUeXBlKHZhbHVlWzFdKTtcbiAgICAgICAgICAgIGlmICh0eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3IoYCR7a2V5fVsxXWAsIHZhbHVlWzFdLCAnc3RyaW5nIGV4cGVjdGVkLCAlcyBmb3VuZCcsIHR5cGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMjsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0eXBlID0gZ2V0VHlwZSh2YWx1ZVtpXSk7XG4gICAgICAgICAgICBpZiAodW5idW5kbGUodmFsdWVbMV0pID09PSAnJHR5cGUnKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZUVudW0oe1xuICAgICAgICAgICAgICAgICAgICBrZXk6IGAke2tleX1bJHtpfV1gLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVbaV0sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlU3BlYzogc3R5bGVTcGVjLmdlb21ldHJ5X3R5cGUsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSAnc3RyaW5nJyAmJiB0eXBlICE9PSAnbnVtYmVyJyAmJiB0eXBlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGAke2tleX1bJHtpfV1gLCB2YWx1ZVtpXSwgJ3N0cmluZywgbnVtYmVyLCBvciBib29sZWFuIGV4cGVjdGVkLCAlcyBmb3VuZCcsIHR5cGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgIGNhc2UgJ2FueSc6XG4gICAgY2FzZSAnYWxsJzpcbiAgICBjYXNlICdub25lJzpcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZUZpbHRlcih7XG4gICAgICAgICAgICAgICAga2V5OiBgJHtrZXl9WyR7aX1dYCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVbaV0sXG4gICAgICAgICAgICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUsXG4gICAgICAgICAgICAgICAgc3R5bGVTcGVjOiBvcHRpb25zLnN0eWxlU3BlY1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaGFzJzpcbiAgICBjYXNlICchaGFzJzpcbiAgICAgICAgdHlwZSA9IGdldFR5cGUodmFsdWVbMV0pO1xuICAgICAgICBpZiAodmFsdWUubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdmaWx0ZXIgYXJyYXkgZm9yIFwiJXNcIiBvcGVyYXRvciBtdXN0IGhhdmUgMiBlbGVtZW50cycsIHZhbHVlWzBdKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3IoYCR7a2V5fVsxXWAsIHZhbHVlWzFdLCAnc3RyaW5nIGV4cGVjdGVkLCAlcyBmb3VuZCcsIHR5cGUpKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgIH1cblxuICAgIHJldHVybiBlcnJvcnM7XG59O1xuIiwiXG5jb25zdCBWYWxpZGF0aW9uRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci92YWxpZGF0aW9uX2Vycm9yJyk7XG5jb25zdCBnZXRUeXBlID0gcmVxdWlyZSgnLi4vdXRpbC9nZXRfdHlwZScpO1xuY29uc3QgdmFsaWRhdGUgPSByZXF1aXJlKCcuL3ZhbGlkYXRlJyk7XG5jb25zdCB2YWxpZGF0ZU9iamVjdCA9IHJlcXVpcmUoJy4vdmFsaWRhdGVfb2JqZWN0Jyk7XG5jb25zdCB2YWxpZGF0ZUFycmF5ID0gcmVxdWlyZSgnLi92YWxpZGF0ZV9hcnJheScpO1xuY29uc3QgdmFsaWRhdGVOdW1iZXIgPSByZXF1aXJlKCcuL3ZhbGlkYXRlX251bWJlcicpO1xuY29uc3QgdW5idW5kbGUgPSByZXF1aXJlKCcuLi91dGlsL3VuYnVuZGxlX2pzb25saW50Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvbihvcHRpb25zKSB7XG4gICAgY29uc3QgZnVuY3Rpb25WYWx1ZVNwZWMgPSBvcHRpb25zLnZhbHVlU3BlYztcbiAgICBjb25zdCBmdW5jdGlvblR5cGUgPSB1bmJ1bmRsZShvcHRpb25zLnZhbHVlLnR5cGUpO1xuICAgIGxldCBzdG9wS2V5VHlwZTtcbiAgICBsZXQgc3RvcERvbWFpblZhbHVlcyA9IHt9O1xuICAgIGxldCBwcmV2aW91c1N0b3BEb21haW5WYWx1ZTtcbiAgICBsZXQgcHJldmlvdXNTdG9wRG9tYWluWm9vbTtcblxuICAgIGNvbnN0IGlzWm9vbUZ1bmN0aW9uID0gZnVuY3Rpb25UeXBlICE9PSAnY2F0ZWdvcmljYWwnICYmIG9wdGlvbnMudmFsdWUucHJvcGVydHkgPT09IHVuZGVmaW5lZDtcbiAgICBjb25zdCBpc1Byb3BlcnR5RnVuY3Rpb24gPSAhaXNab29tRnVuY3Rpb247XG4gICAgY29uc3QgaXNab29tQW5kUHJvcGVydHlGdW5jdGlvbiA9XG4gICAgICAgIGdldFR5cGUob3B0aW9ucy52YWx1ZS5zdG9wcykgPT09ICdhcnJheScgJiZcbiAgICAgICAgZ2V0VHlwZShvcHRpb25zLnZhbHVlLnN0b3BzWzBdKSA9PT0gJ2FycmF5JyAmJlxuICAgICAgICBnZXRUeXBlKG9wdGlvbnMudmFsdWUuc3RvcHNbMF1bMF0pID09PSAnb2JqZWN0JztcblxuICAgIGNvbnN0IGVycm9ycyA9IHZhbGlkYXRlT2JqZWN0KHtcbiAgICAgICAga2V5OiBvcHRpb25zLmtleSxcbiAgICAgICAgdmFsdWU6IG9wdGlvbnMudmFsdWUsXG4gICAgICAgIHZhbHVlU3BlYzogb3B0aW9ucy5zdHlsZVNwZWMuZnVuY3Rpb24sXG4gICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjLFxuICAgICAgICBvYmplY3RFbGVtZW50VmFsaWRhdG9yczoge1xuICAgICAgICAgICAgc3RvcHM6IHZhbGlkYXRlRnVuY3Rpb25TdG9wcyxcbiAgICAgICAgICAgIGRlZmF1bHQ6IHZhbGlkYXRlRnVuY3Rpb25EZWZhdWx0XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChmdW5jdGlvblR5cGUgPT09ICdpZGVudGl0eScgJiYgaXNab29tRnVuY3Rpb24pIHtcbiAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgb3B0aW9ucy52YWx1ZSwgJ21pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHkgXCJwcm9wZXJ0eVwiJykpO1xuICAgIH1cblxuICAgIGlmIChmdW5jdGlvblR5cGUgIT09ICdpZGVudGl0eScgJiYgIW9wdGlvbnMudmFsdWUuc3RvcHMpIHtcbiAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgb3B0aW9ucy52YWx1ZSwgJ21pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHkgXCJzdG9wc1wiJykpO1xuICAgIH1cblxuICAgIGlmIChmdW5jdGlvblR5cGUgPT09ICdleHBvbmVudGlhbCcgJiYgb3B0aW9ucy52YWx1ZVNwZWNbJ2Z1bmN0aW9uJ10gPT09ICdwaWVjZXdpc2UtY29uc3RhbnQnKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIG9wdGlvbnMudmFsdWUsICdleHBvbmVudGlhbCBmdW5jdGlvbnMgbm90IHN1cHBvcnRlZCcpKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zdHlsZVNwZWMuJHZlcnNpb24gPj0gOCkge1xuICAgICAgICBpZiAoaXNQcm9wZXJ0eUZ1bmN0aW9uICYmICFvcHRpb25zLnZhbHVlU3BlY1sncHJvcGVydHktZnVuY3Rpb24nXSkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgb3B0aW9ucy52YWx1ZSwgJ3Byb3BlcnR5IGZ1bmN0aW9ucyBub3Qgc3VwcG9ydGVkJykpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzWm9vbUZ1bmN0aW9uICYmICFvcHRpb25zLnZhbHVlU3BlY1snem9vbS1mdW5jdGlvbiddKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCBvcHRpb25zLnZhbHVlLCAnem9vbSBmdW5jdGlvbnMgbm90IHN1cHBvcnRlZCcpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICgoZnVuY3Rpb25UeXBlID09PSAnY2F0ZWdvcmljYWwnIHx8IGlzWm9vbUFuZFByb3BlcnR5RnVuY3Rpb24pICYmIG9wdGlvbnMudmFsdWUucHJvcGVydHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCBvcHRpb25zLnZhbHVlLCAnXCJwcm9wZXJ0eVwiIHByb3BlcnR5IGlzIHJlcXVpcmVkJykpO1xuICAgIH1cblxuICAgIHJldHVybiBlcnJvcnM7XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9uU3RvcHMob3B0aW9ucykge1xuICAgICAgICBpZiAoZnVuY3Rpb25UeXBlID09PSAnaWRlbnRpdHknKSB7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIG9wdGlvbnMudmFsdWUsICdpZGVudGl0eSBmdW5jdGlvbiBtYXkgbm90IGhhdmUgYSBcInN0b3BzXCIgcHJvcGVydHknKV07XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZXJyb3JzID0gW107XG4gICAgICAgIGNvbnN0IHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcblxuICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlQXJyYXkoe1xuICAgICAgICAgICAga2V5OiBvcHRpb25zLmtleSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIHZhbHVlU3BlYzogb3B0aW9ucy52YWx1ZVNwZWMsXG4gICAgICAgICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSxcbiAgICAgICAgICAgIHN0eWxlU3BlYzogb3B0aW9ucy5zdHlsZVNwZWMsXG4gICAgICAgICAgICBhcnJheUVsZW1lbnRWYWxpZGF0b3I6IHZhbGlkYXRlRnVuY3Rpb25TdG9wXG4gICAgICAgIH0pKTtcblxuICAgICAgICBpZiAoZ2V0VHlwZSh2YWx1ZSkgPT09ICdhcnJheScgJiYgdmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCB2YWx1ZSwgJ2FycmF5IG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgc3RvcCcpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvblN0b3Aob3B0aW9ucykge1xuICAgICAgICBsZXQgZXJyb3JzID0gW107XG4gICAgICAgIGNvbnN0IHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICAgICAgY29uc3Qga2V5ID0gb3B0aW9ucy5rZXk7XG5cbiAgICAgICAgaWYgKGdldFR5cGUodmFsdWUpICE9PSAnYXJyYXknKSB7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ2FycmF5IGV4cGVjdGVkLCAlcyBmb3VuZCcsIGdldFR5cGUodmFsdWUpKV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ2FycmF5IGxlbmd0aCAlZCBleHBlY3RlZCwgbGVuZ3RoICVkIGZvdW5kJywgMiwgdmFsdWUubGVuZ3RoKV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNab29tQW5kUHJvcGVydHlGdW5jdGlvbikge1xuICAgICAgICAgICAgaWYgKGdldFR5cGUodmFsdWVbMF0pICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnb2JqZWN0IGV4cGVjdGVkLCAlcyBmb3VuZCcsIGdldFR5cGUodmFsdWVbMF0pKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWVbMF0uem9vbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdvYmplY3Qgc3RvcCBrZXkgbXVzdCBoYXZlIHpvb20nKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWVbMF0udmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnb2JqZWN0IHN0b3Aga2V5IG11c3QgaGF2ZSB2YWx1ZScpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmV2aW91c1N0b3BEb21haW5ab29tICYmIHByZXZpb3VzU3RvcERvbWFpblpvb20gPiB1bmJ1bmRsZSh2YWx1ZVswXS56b29tKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlWzBdLnpvb20sICdzdG9wIHpvb20gdmFsdWVzIG11c3QgYXBwZWFyIGluIGFzY2VuZGluZyBvcmRlcicpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1bmJ1bmRsZSh2YWx1ZVswXS56b29tKSAhPT0gcHJldmlvdXNTdG9wRG9tYWluWm9vbSkge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzU3RvcERvbWFpblpvb20gPSB1bmJ1bmRsZSh2YWx1ZVswXS56b29tKTtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1N0b3BEb21haW5WYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBzdG9wRG9tYWluVmFsdWVzID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlT2JqZWN0KHtcbiAgICAgICAgICAgICAgICBrZXk6IGAke2tleX1bMF1gLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVswXSxcbiAgICAgICAgICAgICAgICB2YWx1ZVNwZWM6IHsgem9vbToge30gfSxcbiAgICAgICAgICAgICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSxcbiAgICAgICAgICAgICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjLFxuICAgICAgICAgICAgICAgIG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzOiB7IHpvb206IHZhbGlkYXRlTnVtYmVyLCB2YWx1ZTogdmFsaWRhdGVTdG9wRG9tYWluVmFsdWUgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZVN0b3BEb21haW5WYWx1ZSh7XG4gICAgICAgICAgICAgICAga2V5OiBgJHtrZXl9WzBdYCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVbMF0sXG4gICAgICAgICAgICAgICAgdmFsdWVTcGVjOiB7fSxcbiAgICAgICAgICAgICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSxcbiAgICAgICAgICAgICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjXG4gICAgICAgICAgICB9LCB2YWx1ZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVycm9ycy5jb25jYXQodmFsaWRhdGUoe1xuICAgICAgICAgICAga2V5OiBgJHtrZXl9WzFdYCxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVsxXSxcbiAgICAgICAgICAgIHZhbHVlU3BlYzogZnVuY3Rpb25WYWx1ZVNwZWMsXG4gICAgICAgICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSxcbiAgICAgICAgICAgIHN0eWxlU3BlYzogb3B0aW9ucy5zdHlsZVNwZWNcbiAgICAgICAgfSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlU3RvcERvbWFpblZhbHVlKG9wdGlvbnMsIHN0b3ApIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IGdldFR5cGUob3B0aW9ucy52YWx1ZSk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdW5idW5kbGUob3B0aW9ucy52YWx1ZSk7XG5cbiAgICAgICAgY29uc3QgcmVwb3J0VmFsdWUgPSBvcHRpb25zLnZhbHVlICE9PSBudWxsID8gb3B0aW9ucy52YWx1ZSA6IHN0b3A7XG5cbiAgICAgICAgaWYgKCFzdG9wS2V5VHlwZSkge1xuICAgICAgICAgICAgc3RvcEtleVR5cGUgPSB0eXBlO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHN0b3BLZXlUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIHJlcG9ydFZhbHVlLCAnJXMgc3RvcCBkb21haW4gdHlwZSBtdXN0IG1hdGNoIHByZXZpb3VzIHN0b3AgZG9tYWluIHR5cGUgJXMnLCB0eXBlLCBzdG9wS2V5VHlwZSldO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgIT09ICdudW1iZXInICYmIHR5cGUgIT09ICdzdHJpbmcnICYmIHR5cGUgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCByZXBvcnRWYWx1ZSwgJ3N0b3AgZG9tYWluIHZhbHVlIG11c3QgYmUgYSBudW1iZXIsIHN0cmluZywgb3IgYm9vbGVhbicpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlICE9PSAnbnVtYmVyJyAmJiBmdW5jdGlvblR5cGUgIT09ICdjYXRlZ29yaWNhbCcpIHtcbiAgICAgICAgICAgIGxldCBtZXNzYWdlID0gJ251bWJlciBleHBlY3RlZCwgJXMgZm91bmQnO1xuICAgICAgICAgICAgaWYgKGZ1bmN0aW9uVmFsdWVTcGVjWydwcm9wZXJ0eS1mdW5jdGlvbiddICYmIGZ1bmN0aW9uVHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSAnXFxuSWYgeW91IGludGVuZGVkIHRvIHVzZSBhIGNhdGVnb3JpY2FsIGZ1bmN0aW9uLCBzcGVjaWZ5IGBcInR5cGVcIjogXCJjYXRlZ29yaWNhbFwiYC4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCByZXBvcnRWYWx1ZSwgbWVzc2FnZSwgdHlwZSldO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZ1bmN0aW9uVHlwZSA9PT0gJ2NhdGVnb3JpY2FsJyAmJiB0eXBlID09PSAnbnVtYmVyJyAmJiAoIWlzRmluaXRlKHZhbHVlKSB8fCBNYXRoLmZsb29yKHZhbHVlKSAhPT0gdmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIHJlcG9ydFZhbHVlLCAnaW50ZWdlciBleHBlY3RlZCwgZm91bmQgJXMnLCB2YWx1ZSldO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZ1bmN0aW9uVHlwZSAhPT0gJ2NhdGVnb3JpY2FsJyAmJiB0eXBlID09PSAnbnVtYmVyJyAmJiBwcmV2aW91c1N0b3BEb21haW5WYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlIDwgcHJldmlvdXNTdG9wRG9tYWluVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgcmVwb3J0VmFsdWUsICdzdG9wIGRvbWFpbiB2YWx1ZXMgbXVzdCBhcHBlYXIgaW4gYXNjZW5kaW5nIG9yZGVyJyldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJldmlvdXNTdG9wRG9tYWluVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmdW5jdGlvblR5cGUgPT09ICdjYXRlZ29yaWNhbCcgJiYgdmFsdWUgaW4gc3RvcERvbWFpblZhbHVlcykge1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCByZXBvcnRWYWx1ZSwgJ3N0b3AgZG9tYWluIHZhbHVlcyBtdXN0IGJlIHVuaXF1ZScpXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0b3BEb21haW5WYWx1ZXNbdmFsdWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9uRGVmYXVsdChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZSh7XG4gICAgICAgICAgICBrZXk6IG9wdGlvbnMua2V5LFxuICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMudmFsdWUsXG4gICAgICAgICAgICB2YWx1ZVNwZWM6IGZ1bmN0aW9uVmFsdWVTcGVjLFxuICAgICAgICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUsXG4gICAgICAgICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjXG4gICAgICAgIH0pO1xuICAgIH1cbn07XG4iLCJcbmNvbnN0IFZhbGlkYXRpb25FcnJvciA9IHJlcXVpcmUoJy4uL2Vycm9yL3ZhbGlkYXRpb25fZXJyb3InKTtcbmNvbnN0IHZhbGlkYXRlU3RyaW5nID0gcmVxdWlyZSgnLi92YWxpZGF0ZV9zdHJpbmcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgY29uc3QgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgIGNvbnN0IGtleSA9IG9wdGlvbnMua2V5O1xuXG4gICAgY29uc3QgZXJyb3JzID0gdmFsaWRhdGVTdHJpbmcob3B0aW9ucyk7XG4gICAgaWYgKGVycm9ycy5sZW5ndGgpIHJldHVybiBlcnJvcnM7XG5cbiAgICBpZiAodmFsdWUuaW5kZXhPZigne2ZvbnRzdGFja30nKSA9PT0gLTEpIHtcbiAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnXCJnbHlwaHNcIiB1cmwgbXVzdCBpbmNsdWRlIGEgXCJ7Zm9udHN0YWNrfVwiIHRva2VuJykpO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZS5pbmRleE9mKCd7cmFuZ2V9JykgPT09IC0xKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ1wiZ2x5cGhzXCIgdXJsIG11c3QgaW5jbHVkZSBhIFwie3JhbmdlfVwiIHRva2VuJykpO1xuICAgIH1cblxuICAgIHJldHVybiBlcnJvcnM7XG59O1xuIiwiXG5jb25zdCBWYWxpZGF0aW9uRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci92YWxpZGF0aW9uX2Vycm9yJyk7XG5jb25zdCB1bmJ1bmRsZSA9IHJlcXVpcmUoJy4uL3V0aWwvdW5idW5kbGVfanNvbmxpbnQnKTtcbmNvbnN0IHZhbGlkYXRlT2JqZWN0ID0gcmVxdWlyZSgnLi92YWxpZGF0ZV9vYmplY3QnKTtcbmNvbnN0IHZhbGlkYXRlRmlsdGVyID0gcmVxdWlyZSgnLi92YWxpZGF0ZV9maWx0ZXInKTtcbmNvbnN0IHZhbGlkYXRlUGFpbnRQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vdmFsaWRhdGVfcGFpbnRfcHJvcGVydHknKTtcbmNvbnN0IHZhbGlkYXRlTGF5b3V0UHJvcGVydHkgPSByZXF1aXJlKCcuL3ZhbGlkYXRlX2xheW91dF9wcm9wZXJ0eScpO1xuY29uc3QgZXh0ZW5kID0gcmVxdWlyZSgnLi4vdXRpbC9leHRlbmQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB2YWxpZGF0ZUxheWVyKG9wdGlvbnMpIHtcbiAgICBsZXQgZXJyb3JzID0gW107XG5cbiAgICBjb25zdCBsYXllciA9IG9wdGlvbnMudmFsdWU7XG4gICAgY29uc3Qga2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgY29uc3Qgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuICAgIGNvbnN0IHN0eWxlU3BlYyA9IG9wdGlvbnMuc3R5bGVTcGVjO1xuXG4gICAgaWYgKCFsYXllci50eXBlICYmICFsYXllci5yZWYpIHtcbiAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLCAnZWl0aGVyIFwidHlwZVwiIG9yIFwicmVmXCIgaXMgcmVxdWlyZWQnKSk7XG4gICAgfVxuICAgIGxldCB0eXBlID0gdW5idW5kbGUobGF5ZXIudHlwZSk7XG4gICAgY29uc3QgcmVmID0gdW5idW5kbGUobGF5ZXIucmVmKTtcblxuICAgIGlmIChsYXllci5pZCkge1xuICAgICAgICBjb25zdCBsYXllcklkID0gdW5idW5kbGUobGF5ZXIuaWQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wdGlvbnMuYXJyYXlJbmRleDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBvdGhlckxheWVyID0gc3R5bGUubGF5ZXJzW2ldO1xuICAgICAgICAgICAgaWYgKHVuYnVuZGxlKG90aGVyTGF5ZXIuaWQpID09PSBsYXllcklkKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLmlkLCAnZHVwbGljYXRlIGxheWVyIGlkIFwiJXNcIiwgcHJldmlvdXNseSB1c2VkIGF0IGxpbmUgJWQnLCBsYXllci5pZCwgb3RoZXJMYXllci5pZC5fX2xpbmVfXykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCdyZWYnIGluIGxheWVyKSB7XG4gICAgICAgIFsndHlwZScsICdzb3VyY2UnLCAnc291cmNlLWxheWVyJywgJ2ZpbHRlcicsICdsYXlvdXQnXS5mb3JFYWNoKChwKSA9PiB7XG4gICAgICAgICAgICBpZiAocCBpbiBsYXllcikge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBsYXllcltwXSwgJ1wiJXNcIiBpcyBwcm9oaWJpdGVkIGZvciByZWYgbGF5ZXJzJywgcCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBsZXQgcGFyZW50O1xuXG4gICAgICAgIHN0eWxlLmxheWVycy5mb3JFYWNoKChsYXllcikgPT4ge1xuICAgICAgICAgICAgaWYgKHVuYnVuZGxlKGxheWVyLmlkKSA9PT0gcmVmKSBwYXJlbnQgPSBsYXllcjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBsYXllci5yZWYsICdyZWYgbGF5ZXIgXCIlc1wiIG5vdCBmb3VuZCcsIHJlZikpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcmVudC5yZWYpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBsYXllci5yZWYsICdyZWYgY2Fubm90IHJlZmVyZW5jZSBhbm90aGVyIHJlZiBsYXllcicpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHR5cGUgPSB1bmJ1bmRsZShwYXJlbnQudHlwZSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgIT09ICdiYWNrZ3JvdW5kJykge1xuICAgICAgICBpZiAoIWxheWVyLnNvdXJjZSkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLCAnbWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eSBcInNvdXJjZVwiJykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc291cmNlID0gc3R5bGUuc291cmNlcyAmJiBzdHlsZS5zb3VyY2VzW2xheWVyLnNvdXJjZV07XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VUeXBlID0gc291cmNlICYmIHVuYnVuZGxlKHNvdXJjZS50eXBlKTtcbiAgICAgICAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLnNvdXJjZSwgJ3NvdXJjZSBcIiVzXCIgbm90IGZvdW5kJywgbGF5ZXIuc291cmNlKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZVR5cGUgPT09ICd2ZWN0b3InICYmIHR5cGUgPT09ICdyYXN0ZXInKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLnNvdXJjZSwgJ2xheWVyIFwiJXNcIiByZXF1aXJlcyBhIHJhc3RlciBzb3VyY2UnLCBsYXllci5pZCkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2VUeXBlID09PSAncmFzdGVyJyAmJiB0eXBlICE9PSAncmFzdGVyJykge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBsYXllci5zb3VyY2UsICdsYXllciBcIiVzXCIgcmVxdWlyZXMgYSB2ZWN0b3Igc291cmNlJywgbGF5ZXIuaWQpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlVHlwZSA9PT0gJ3ZlY3RvcicgJiYgIWxheWVyWydzb3VyY2UtbGF5ZXInXSkge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBsYXllciwgJ2xheWVyIFwiJXNcIiBtdXN0IHNwZWNpZnkgYSBcInNvdXJjZS1sYXllclwiJywgbGF5ZXIuaWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGVPYmplY3Qoe1xuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgdmFsdWU6IGxheWVyLFxuICAgICAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlYy5sYXllcixcbiAgICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUsXG4gICAgICAgIHN0eWxlU3BlYzogb3B0aW9ucy5zdHlsZVNwZWMsXG4gICAgICAgIG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzOiB7XG4gICAgICAgICAgICAnKic6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaWx0ZXI6IHZhbGlkYXRlRmlsdGVyLFxuICAgICAgICAgICAgbGF5b3V0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlT2JqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXI6IGxheWVyLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IG9wdGlvbnMua2V5LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlU3BlYzogb3B0aW9ucy5zdHlsZVNwZWMsXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnKic6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVMYXlvdXRQcm9wZXJ0eShleHRlbmQoe2xheWVyVHlwZTogdHlwZX0sIG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhaW50OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlT2JqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXI6IGxheWVyLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IG9wdGlvbnMua2V5LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlU3BlYzogb3B0aW9ucy5zdHlsZVNwZWMsXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnKic6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVQYWludFByb3BlcnR5KGV4dGVuZCh7bGF5ZXJUeXBlOiB0eXBlfSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KSk7XG5cbiAgICByZXR1cm4gZXJyb3JzO1xufTtcbiIsIlxuY29uc3QgdmFsaWRhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vdmFsaWRhdGVfcHJvcGVydHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB2YWxpZGF0ZUxheW91dFByb3BlcnR5KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdmFsaWRhdGVQcm9wZXJ0eShvcHRpb25zLCAnbGF5b3V0Jyk7XG59O1xuIiwiXG5jb25zdCBWYWxpZGF0aW9uRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci92YWxpZGF0aW9uX2Vycm9yJyk7XG5jb25zdCBnZXRUeXBlID0gcmVxdWlyZSgnLi4vdXRpbC9nZXRfdHlwZScpO1xuY29uc3QgdmFsaWRhdGUgPSByZXF1aXJlKCcuL3ZhbGlkYXRlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdmFsaWRhdGVMaWdodChvcHRpb25zKSB7XG4gICAgY29uc3QgbGlnaHQgPSBvcHRpb25zLnZhbHVlO1xuICAgIGNvbnN0IHN0eWxlU3BlYyA9IG9wdGlvbnMuc3R5bGVTcGVjO1xuICAgIGNvbnN0IGxpZ2h0U3BlYyA9IHN0eWxlU3BlYy5saWdodDtcbiAgICBjb25zdCBzdHlsZSA9IG9wdGlvbnMuc3R5bGU7XG5cbiAgICBsZXQgZXJyb3JzID0gW107XG5cbiAgICBjb25zdCByb290VHlwZSA9IGdldFR5cGUobGlnaHQpO1xuICAgIGlmIChsaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgfSBlbHNlIGlmIChyb290VHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdChbbmV3IFZhbGlkYXRpb25FcnJvcignbGlnaHQnLCBsaWdodCwgJ29iamVjdCBleHBlY3RlZCwgJXMgZm91bmQnLCByb290VHlwZSldKTtcbiAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBsaWdodCkge1xuICAgICAgICBjb25zdCB0cmFuc2l0aW9uTWF0Y2ggPSBrZXkubWF0Y2goL14oLiopLXRyYW5zaXRpb24kLyk7XG5cbiAgICAgICAgaWYgKHRyYW5zaXRpb25NYXRjaCAmJiBsaWdodFNwZWNbdHJhbnNpdGlvbk1hdGNoWzFdXSAmJiBsaWdodFNwZWNbdHJhbnNpdGlvbk1hdGNoWzFdXS50cmFuc2l0aW9uKSB7XG4gICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlKHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbGlnaHRba2V5XSxcbiAgICAgICAgICAgICAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlYy50cmFuc2l0aW9uLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgICAgICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlY1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGxpZ2h0U3BlY1trZXldKSB7XG4gICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlKHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbGlnaHRba2V5XSxcbiAgICAgICAgICAgICAgICB2YWx1ZVNwZWM6IGxpZ2h0U3BlY1trZXldLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgICAgICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlY1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdChbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxpZ2h0W2tleV0sICd1bmtub3duIHByb3BlcnR5IFwiJXNcIicsIGtleSldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlcnJvcnM7XG59O1xuIiwiXG5jb25zdCBnZXRUeXBlID0gcmVxdWlyZSgnLi4vdXRpbC9nZXRfdHlwZScpO1xuY29uc3QgVmFsaWRhdGlvbkVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvdmFsaWRhdGlvbl9lcnJvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHZhbGlkYXRlTnVtYmVyKG9wdGlvbnMpIHtcbiAgICBjb25zdCBrZXkgPSBvcHRpb25zLmtleTtcbiAgICBjb25zdCB2YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gICAgY29uc3QgdmFsdWVTcGVjID0gb3B0aW9ucy52YWx1ZVNwZWM7XG4gICAgY29uc3QgdHlwZSA9IGdldFR5cGUodmFsdWUpO1xuXG4gICAgaWYgKHR5cGUgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnbnVtYmVyIGV4cGVjdGVkLCAlcyBmb3VuZCcsIHR5cGUpXTtcbiAgICB9XG5cbiAgICBpZiAoJ21pbmltdW0nIGluIHZhbHVlU3BlYyAmJiB2YWx1ZSA8IHZhbHVlU3BlYy5taW5pbXVtKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnJXMgaXMgbGVzcyB0aGFuIHRoZSBtaW5pbXVtIHZhbHVlICVzJywgdmFsdWUsIHZhbHVlU3BlYy5taW5pbXVtKV07XG4gICAgfVxuXG4gICAgaWYgKCdtYXhpbXVtJyBpbiB2YWx1ZVNwZWMgJiYgdmFsdWUgPiB2YWx1ZVNwZWMubWF4aW11bSkge1xuICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJyVzIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbWF4aW11bSB2YWx1ZSAlcycsIHZhbHVlLCB2YWx1ZVNwZWMubWF4aW11bSldO1xuICAgIH1cblxuICAgIHJldHVybiBbXTtcbn07XG4iLCJcbmNvbnN0IFZhbGlkYXRpb25FcnJvciA9IHJlcXVpcmUoJy4uL2Vycm9yL3ZhbGlkYXRpb25fZXJyb3InKTtcbmNvbnN0IGdldFR5cGUgPSByZXF1aXJlKCcuLi91dGlsL2dldF90eXBlJyk7XG5jb25zdCB2YWxpZGF0ZVNwZWMgPSByZXF1aXJlKCcuL3ZhbGlkYXRlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdmFsaWRhdGVPYmplY3Qob3B0aW9ucykge1xuICAgIGNvbnN0IGtleSA9IG9wdGlvbnMua2V5O1xuICAgIGNvbnN0IG9iamVjdCA9IG9wdGlvbnMudmFsdWU7XG4gICAgY29uc3QgZWxlbWVudFNwZWNzID0gb3B0aW9ucy52YWx1ZVNwZWMgfHwge307XG4gICAgY29uc3QgZWxlbWVudFZhbGlkYXRvcnMgPSBvcHRpb25zLm9iamVjdEVsZW1lbnRWYWxpZGF0b3JzIHx8IHt9O1xuICAgIGNvbnN0IHN0eWxlID0gb3B0aW9ucy5zdHlsZTtcbiAgICBjb25zdCBzdHlsZVNwZWMgPSBvcHRpb25zLnN0eWxlU3BlYztcbiAgICBsZXQgZXJyb3JzID0gW107XG5cbiAgICBjb25zdCB0eXBlID0gZ2V0VHlwZShvYmplY3QpO1xuICAgIGlmICh0eXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBvYmplY3QsICdvYmplY3QgZXhwZWN0ZWQsICVzIGZvdW5kJywgdHlwZSldO1xuICAgIH1cblxuICAgIGZvciAoY29uc3Qgb2JqZWN0S2V5IGluIG9iamVjdCkge1xuICAgICAgICBjb25zdCBlbGVtZW50U3BlY0tleSA9IG9iamVjdEtleS5zcGxpdCgnLicpWzBdOyAvLyB0cmVhdCAncGFpbnQuKicgYXMgJ3BhaW50J1xuICAgICAgICBjb25zdCBlbGVtZW50U3BlYyA9IGVsZW1lbnRTcGVjc1tlbGVtZW50U3BlY0tleV0gfHwgZWxlbWVudFNwZWNzWycqJ107XG5cbiAgICAgICAgbGV0IHZhbGlkYXRlRWxlbWVudDtcbiAgICAgICAgaWYgKGVsZW1lbnRWYWxpZGF0b3JzW2VsZW1lbnRTcGVjS2V5XSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFbGVtZW50ID0gZWxlbWVudFZhbGlkYXRvcnNbZWxlbWVudFNwZWNLZXldO1xuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnRTcGVjc1tlbGVtZW50U3BlY0tleV0pIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRWxlbWVudCA9IHZhbGlkYXRlU3BlYztcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50VmFsaWRhdG9yc1snKiddKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUVsZW1lbnQgPSBlbGVtZW50VmFsaWRhdG9yc1snKiddO1xuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnRTcGVjc1snKiddKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUVsZW1lbnQgPSB2YWxpZGF0ZVNwZWM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgb2JqZWN0W29iamVjdEtleV0sICd1bmtub3duIHByb3BlcnR5IFwiJXNcIicsIG9iamVjdEtleSkpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlRWxlbWVudCh7XG4gICAgICAgICAgICBrZXk6IChrZXkgPyBgJHtrZXl9LmAgOiBrZXkpICsgb2JqZWN0S2V5LFxuICAgICAgICAgICAgdmFsdWU6IG9iamVjdFtvYmplY3RLZXldLFxuICAgICAgICAgICAgdmFsdWVTcGVjOiBlbGVtZW50U3BlYyxcbiAgICAgICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjLFxuICAgICAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgICAgICBvYmplY3RLZXk6IG9iamVjdEtleVxuICAgICAgICB9LCBvYmplY3QpKTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGVsZW1lbnRTcGVjS2V5IGluIGVsZW1lbnRTcGVjcykge1xuICAgICAgICBpZiAoZWxlbWVudFNwZWNzW2VsZW1lbnRTcGVjS2V5XS5yZXF1aXJlZCAmJiBlbGVtZW50U3BlY3NbZWxlbWVudFNwZWNLZXldWydkZWZhdWx0J10gPT09IHVuZGVmaW5lZCAmJiBvYmplY3RbZWxlbWVudFNwZWNLZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBvYmplY3QsICdtaXNzaW5nIHJlcXVpcmVkIHByb3BlcnR5IFwiJXNcIicsIGVsZW1lbnRTcGVjS2V5KSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXJyb3JzO1xufTtcbiIsIlxuY29uc3QgdmFsaWRhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vdmFsaWRhdGVfcHJvcGVydHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB2YWxpZGF0ZVBhaW50UHJvcGVydHkob3B0aW9ucykge1xuICAgIHJldHVybiB2YWxpZGF0ZVByb3BlcnR5KG9wdGlvbnMsICdwYWludCcpO1xufTtcbiIsIlxuY29uc3QgdmFsaWRhdGUgPSByZXF1aXJlKCcuL3ZhbGlkYXRlJyk7XG5jb25zdCBWYWxpZGF0aW9uRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci92YWxpZGF0aW9uX2Vycm9yJyk7XG5jb25zdCBnZXRUeXBlID0gcmVxdWlyZSgnLi4vdXRpbC9nZXRfdHlwZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHkob3B0aW9ucywgcHJvcGVydHlUeXBlKSB7XG4gICAgY29uc3Qga2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgY29uc3Qgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuICAgIGNvbnN0IHN0eWxlU3BlYyA9IG9wdGlvbnMuc3R5bGVTcGVjO1xuICAgIGNvbnN0IHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICBjb25zdCBwcm9wZXJ0eUtleSA9IG9wdGlvbnMub2JqZWN0S2V5O1xuICAgIGNvbnN0IGxheWVyU3BlYyA9IHN0eWxlU3BlY1tgJHtwcm9wZXJ0eVR5cGV9XyR7b3B0aW9ucy5sYXllclR5cGV9YF07XG5cbiAgICBpZiAoIWxheWVyU3BlYykgcmV0dXJuIFtdO1xuXG4gICAgY29uc3QgdHJhbnNpdGlvbk1hdGNoID0gcHJvcGVydHlLZXkubWF0Y2goL14oLiopLXRyYW5zaXRpb24kLyk7XG4gICAgaWYgKHByb3BlcnR5VHlwZSA9PT0gJ3BhaW50JyAmJiB0cmFuc2l0aW9uTWF0Y2ggJiYgbGF5ZXJTcGVjW3RyYW5zaXRpb25NYXRjaFsxXV0gJiYgbGF5ZXJTcGVjW3RyYW5zaXRpb25NYXRjaFsxXV0udHJhbnNpdGlvbikge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUoe1xuICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlYy50cmFuc2l0aW9uLFxuICAgICAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICAgICAgc3R5bGVTcGVjOiBzdHlsZVNwZWNcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgdmFsdWVTcGVjID0gb3B0aW9ucy52YWx1ZVNwZWMgfHwgbGF5ZXJTcGVjW3Byb3BlcnR5S2V5XTtcbiAgICBpZiAoIXZhbHVlU3BlYykge1xuICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ3Vua25vd24gcHJvcGVydHkgXCIlc1wiJywgcHJvcGVydHlLZXkpXTtcbiAgICB9XG5cbiAgICBsZXQgdG9rZW5NYXRjaDtcbiAgICBpZiAoZ2V0VHlwZSh2YWx1ZSkgPT09ICdzdHJpbmcnICYmIHZhbHVlU3BlY1sncHJvcGVydHktZnVuY3Rpb24nXSAmJiAhdmFsdWVTcGVjLnRva2VucyAmJiAodG9rZW5NYXRjaCA9IC9eeyhbXn1dKyl9JC8uZXhlYyh2YWx1ZSkpKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihcbiAgICAgICAgICAgIGtleSwgdmFsdWUsXG4gICAgICAgICAgICAnXCIlc1wiIGRvZXMgbm90IHN1cHBvcnQgaW50ZXJwb2xhdGlvbiBzeW50YXhcXG4nICtcbiAgICAgICAgICAgICAgICAnVXNlIGFuIGlkZW50aXR5IHByb3BlcnR5IGZ1bmN0aW9uIGluc3RlYWQ6IGB7IFwidHlwZVwiOiBcImlkZW50aXR5XCIsIFwicHJvcGVydHlcIjogJXNgIH1gLicsXG4gICAgICAgICAgICBwcm9wZXJ0eUtleSwgSlNPTi5zdHJpbmdpZnkodG9rZW5NYXRjaFsxXSlcbiAgICAgICAgKV07XG4gICAgfVxuXG4gICAgY29uc3QgZXJyb3JzID0gW107XG5cbiAgICBpZiAob3B0aW9ucy5sYXllclR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0eUtleSA9PT0gJ3RleHQtZmllbGQnICYmIHN0eWxlICYmICFzdHlsZS5nbHlwaHMpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ3VzZSBvZiBcInRleHQtZmllbGRcIiByZXF1aXJlcyBhIHN0eWxlIFwiZ2x5cGhzXCIgcHJvcGVydHknKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZSh7XG4gICAgICAgIGtleTogb3B0aW9ucy5rZXksXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgdmFsdWVTcGVjOiB2YWx1ZVNwZWMsXG4gICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgc3R5bGVTcGVjOiBzdHlsZVNwZWMsXG4gICAgICAgIGV4cHJlc3Npb25Db250ZXh0OiAncHJvcGVydHknXG4gICAgfSkpO1xufTtcbiIsIlxuY29uc3QgVmFsaWRhdGlvbkVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvdmFsaWRhdGlvbl9lcnJvcicpO1xuY29uc3QgdW5idW5kbGUgPSByZXF1aXJlKCcuLi91dGlsL3VuYnVuZGxlX2pzb25saW50Jyk7XG5jb25zdCB2YWxpZGF0ZU9iamVjdCA9IHJlcXVpcmUoJy4vdmFsaWRhdGVfb2JqZWN0Jyk7XG5jb25zdCB2YWxpZGF0ZUVudW0gPSByZXF1aXJlKCcuL3ZhbGlkYXRlX2VudW0nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB2YWxpZGF0ZVNvdXJjZShvcHRpb25zKSB7XG4gICAgY29uc3QgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgIGNvbnN0IGtleSA9IG9wdGlvbnMua2V5O1xuICAgIGNvbnN0IHN0eWxlU3BlYyA9IG9wdGlvbnMuc3R5bGVTcGVjO1xuICAgIGNvbnN0IHN0eWxlID0gb3B0aW9ucy5zdHlsZTtcblxuICAgIGlmICghdmFsdWUudHlwZSkge1xuICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ1widHlwZVwiIGlzIHJlcXVpcmVkJyldO1xuICAgIH1cblxuICAgIGNvbnN0IHR5cGUgPSB1bmJ1bmRsZSh2YWx1ZS50eXBlKTtcbiAgICBsZXQgZXJyb3JzID0gW107XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd2ZWN0b3InOlxuICAgIGNhc2UgJ3Jhc3Rlcic6XG4gICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGVPYmplY3Qoe1xuICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlYy5zb3VyY2VfdGlsZSxcbiAgICAgICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgICAgICAgc3R5bGVTcGVjOiBzdHlsZVNwZWNcbiAgICAgICAgfSkpO1xuICAgICAgICBpZiAoJ3VybCcgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChbJ3R5cGUnLCAndXJsJywgJ3RpbGVTaXplJ10uaW5kZXhPZihwcm9wKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihgJHtrZXl9LiR7cHJvcH1gLCB2YWx1ZVtwcm9wXSwgJ2Egc291cmNlIHdpdGggYSBcInVybFwiIHByb3BlcnR5IG1heSBub3QgaW5jbHVkZSBhIFwiJXNcIiBwcm9wZXJ0eScsIHByb3ApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycm9ycztcblxuICAgIGNhc2UgJ2dlb2pzb24nOlxuICAgICAgICByZXR1cm4gdmFsaWRhdGVPYmplY3Qoe1xuICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlYy5zb3VyY2VfZ2VvanNvbixcbiAgICAgICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjXG4gICAgICAgIH0pO1xuXG4gICAgY2FzZSAndmlkZW8nOlxuICAgICAgICByZXR1cm4gdmFsaWRhdGVPYmplY3Qoe1xuICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlYy5zb3VyY2VfdmlkZW8sXG4gICAgICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlY1xuICAgICAgICB9KTtcblxuICAgIGNhc2UgJ2ltYWdlJzpcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlT2JqZWN0KHtcbiAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgdmFsdWVTcGVjOiBzdHlsZVNwZWMuc291cmNlX2ltYWdlLFxuICAgICAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICAgICAgc3R5bGVTcGVjOiBzdHlsZVNwZWNcbiAgICAgICAgfSk7XG5cbiAgICBjYXNlICdjYW52YXMnOlxuICAgICAgICByZXR1cm4gdmFsaWRhdGVPYmplY3Qoe1xuICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlYy5zb3VyY2VfY2FudmFzLFxuICAgICAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICAgICAgc3R5bGVTcGVjOiBzdHlsZVNwZWNcbiAgICAgICAgfSk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdmFsaWRhdGVFbnVtKHtcbiAgICAgICAgICAgIGtleTogYCR7a2V5fS50eXBlYCxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZS50eXBlLFxuICAgICAgICAgICAgdmFsdWVTcGVjOiB7dmFsdWVzOiBbJ3ZlY3RvcicsICdyYXN0ZXInLCAnZ2VvanNvbicsICd2aWRlbycsICdpbWFnZScsICdjYW52YXMnXX0sXG4gICAgICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlY1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuIiwiXG5jb25zdCBnZXRUeXBlID0gcmVxdWlyZSgnLi4vdXRpbC9nZXRfdHlwZScpO1xuY29uc3QgVmFsaWRhdGlvbkVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvdmFsaWRhdGlvbl9lcnJvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHZhbGlkYXRlU3RyaW5nKG9wdGlvbnMpIHtcbiAgICBjb25zdCB2YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gICAgY29uc3Qga2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgY29uc3QgdHlwZSA9IGdldFR5cGUodmFsdWUpO1xuXG4gICAgaWYgKHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnc3RyaW5nIGV4cGVjdGVkLCAlcyBmb3VuZCcsIHR5cGUpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gW107XG59O1xuIiwiXG5jb25zdCB2YWxpZGF0ZVN0eWxlTWluID0gcmVxdWlyZSgnLi92YWxpZGF0ZV9zdHlsZS5taW4nKTtcbmNvbnN0IFBhcnNpbmdFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3IvcGFyc2luZ19lcnJvcicpO1xuY29uc3QganNvbmxpbnQgPSByZXF1aXJlKCdqc29ubGludC1saW5lcy1wcmltaXRpdmVzJyk7XG5cbi8qKlxuICogVmFsaWRhdGUgYSBNYXBib3ggR0wgc3R5bGUgYWdhaW5zdCB0aGUgc3R5bGUgc3BlY2lmaWNhdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGFsaWFzIHZhbGlkYXRlXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd8QnVmZmVyfSBzdHlsZSBUaGUgc3R5bGUgdG8gYmUgdmFsaWRhdGVkLiBJZiBhIGBTdHJpbmdgXG4gKiAgICAgb3IgYEJ1ZmZlcmAgaXMgcHJvdmlkZWQsIHRoZSByZXR1cm5lZCBlcnJvcnMgd2lsbCBjb250YWluIGxpbmUgbnVtYmVycy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3R5bGVTcGVjXSBUaGUgc3R5bGUgc3BlY2lmaWNhdGlvbiB0byB2YWxpZGF0ZSBhZ2FpbnN0LlxuICogICAgIElmIG9taXR0ZWQsIHRoZSBzcGVjIHZlcnNpb24gaXMgaW5mZXJyZWQgZnJvbSB0aGUgc3R5bGVzaGVldC5cbiAqIEByZXR1cm5zIHtBcnJheTxWYWxpZGF0aW9uRXJyb3J8UGFyc2luZ0Vycm9yPn1cbiAqIEBleGFtcGxlXG4gKiAgIHZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJ21hcGJveC1nbC1zdHlsZS1zcGVjJykudmFsaWRhdGU7XG4gKiAgIHZhciBzdHlsZSA9IGZzLnJlYWRGaWxlU3luYygnLi9zdHlsZS5qc29uJywgJ3V0ZjgnKTtcbiAqICAgdmFyIGVycm9ycyA9IHZhbGlkYXRlKHN0eWxlKTtcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHZhbGlkYXRlU3R5bGUoc3R5bGUsIHN0eWxlU3BlYykge1xuICAgIGNvbnN0IGluZGV4ID0gcmVxdWlyZSgnLi8nKTtcblxuICAgIGlmIChzdHlsZSBpbnN0YW5jZW9mIFN0cmluZyB8fCB0eXBlb2Ygc3R5bGUgPT09ICdzdHJpbmcnIHx8IHN0eWxlIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdHlsZSA9IGpzb25saW50LnBhcnNlKHN0eWxlLnRvU3RyaW5nKCkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBQYXJzaW5nRXJyb3IoZSldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3R5bGVTcGVjID0gc3R5bGVTcGVjIHx8IGluZGV4W2B2JHtzdHlsZS52ZXJzaW9ufWBdO1xuXG4gICAgcmV0dXJuIHZhbGlkYXRlU3R5bGVNaW4oc3R5bGUsIHN0eWxlU3BlYyk7XG59O1xuXG5leHBvcnRzLnNvdXJjZSA9IHZhbGlkYXRlU3R5bGVNaW4uc291cmNlO1xuZXhwb3J0cy5saWdodCA9IHZhbGlkYXRlU3R5bGVNaW4ubGlnaHQ7XG5leHBvcnRzLmxheWVyID0gdmFsaWRhdGVTdHlsZU1pbi5sYXllcjtcbmV4cG9ydHMuZmlsdGVyID0gdmFsaWRhdGVTdHlsZU1pbi5maWx0ZXI7XG5leHBvcnRzLnBhaW50UHJvcGVydHkgPSB2YWxpZGF0ZVN0eWxlTWluLnBhaW50UHJvcGVydHk7XG5leHBvcnRzLmxheW91dFByb3BlcnR5ID0gdmFsaWRhdGVTdHlsZU1pbi5sYXlvdXRQcm9wZXJ0eTtcbiIsIlxuY29uc3QgdmFsaWRhdGVDb25zdGFudHMgPSByZXF1aXJlKCcuL3ZhbGlkYXRlL3ZhbGlkYXRlX2NvbnN0YW50cycpO1xuY29uc3QgdmFsaWRhdGUgPSByZXF1aXJlKCcuL3ZhbGlkYXRlL3ZhbGlkYXRlJyk7XG5jb25zdCBsYXRlc3RTdHlsZVNwZWMgPSByZXF1aXJlKCcuL3JlZmVyZW5jZS9sYXRlc3QnKTtcbmNvbnN0IHZhbGlkYXRlR2x5cGhzVVJMID0gcmVxdWlyZSgnLi92YWxpZGF0ZS92YWxpZGF0ZV9nbHlwaHNfdXJsJyk7XG5cbi8qKlxuICogVmFsaWRhdGUgYSBNYXBib3ggR0wgc3R5bGUgYWdhaW5zdCB0aGUgc3R5bGUgc3BlY2lmaWNhdGlvbi4gVGhpcyBlbnRyeXBvaW50LFxuICogYG1hcGJveC1nbC1zdHlsZS1zcGVjL2xpYi92YWxpZGF0ZV9zdHlsZS5taW5gLCBpcyBkZXNpZ25lZCB0byBwcm9kdWNlIGFzXG4gKiBzbWFsbCBhIGJyb3dzZXJpZnkgYnVuZGxlIGFzIHBvc3NpYmxlIGJ5IG9taXR0aW5nIHVubmVjZXNzYXJ5IGZ1bmN0aW9uYWxpdHlcbiAqIGFuZCBsZWdhY3kgc3R5bGUgc3BlY2lmaWNhdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZSBUaGUgc3R5bGUgdG8gYmUgdmFsaWRhdGVkLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdHlsZVNwZWNdIFRoZSBzdHlsZSBzcGVjaWZpY2F0aW9uIHRvIHZhbGlkYXRlIGFnYWluc3QuXG4gKiAgICAgSWYgb21pdHRlZCwgdGhlIGxhdGVzdCBzdHlsZSBzcGVjIGlzIHVzZWQuXG4gKiBAcmV0dXJucyB7QXJyYXk8VmFsaWRhdGlvbkVycm9yPn1cbiAqIEBleGFtcGxlXG4gKiAgIHZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJ21hcGJveC1nbC1zdHlsZS1zcGVjL2xpYi92YWxpZGF0ZV9zdHlsZS5taW4nKTtcbiAqICAgdmFyIGVycm9ycyA9IHZhbGlkYXRlKHN0eWxlKTtcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVTdHlsZU1pbihzdHlsZSwgc3R5bGVTcGVjKSB7XG4gICAgc3R5bGVTcGVjID0gc3R5bGVTcGVjIHx8IGxhdGVzdFN0eWxlU3BlYztcblxuICAgIGxldCBlcnJvcnMgPSBbXTtcblxuICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGUoe1xuICAgICAgICBrZXk6ICcnLFxuICAgICAgICB2YWx1ZTogc3R5bGUsXG4gICAgICAgIHZhbHVlU3BlYzogc3R5bGVTcGVjLiRyb290LFxuICAgICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlYyxcbiAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICBvYmplY3RFbGVtZW50VmFsaWRhdG9yczoge1xuICAgICAgICAgICAgZ2x5cGhzOiB2YWxpZGF0ZUdseXBoc1VSTCxcbiAgICAgICAgICAgICcqJzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSkpO1xuXG4gICAgaWYgKHN0eWxlU3BlYy4kdmVyc2lvbiA+IDcgJiYgc3R5bGUuY29uc3RhbnRzKSB7XG4gICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGVDb25zdGFudHMoe1xuICAgICAgICAgICAga2V5OiAnY29uc3RhbnRzJyxcbiAgICAgICAgICAgIHZhbHVlOiBzdHlsZS5jb25zdGFudHMsXG4gICAgICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlY1xuICAgICAgICB9KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNvcnRFcnJvcnMoZXJyb3JzKTtcbn1cblxudmFsaWRhdGVTdHlsZU1pbi5zb3VyY2UgPSB3cmFwQ2xlYW5FcnJvcnMocmVxdWlyZSgnLi92YWxpZGF0ZS92YWxpZGF0ZV9zb3VyY2UnKSk7XG52YWxpZGF0ZVN0eWxlTWluLmxpZ2h0ID0gd3JhcENsZWFuRXJyb3JzKHJlcXVpcmUoJy4vdmFsaWRhdGUvdmFsaWRhdGVfbGlnaHQnKSk7XG52YWxpZGF0ZVN0eWxlTWluLmxheWVyID0gd3JhcENsZWFuRXJyb3JzKHJlcXVpcmUoJy4vdmFsaWRhdGUvdmFsaWRhdGVfbGF5ZXInKSk7XG52YWxpZGF0ZVN0eWxlTWluLmZpbHRlciA9IHdyYXBDbGVhbkVycm9ycyhyZXF1aXJlKCcuL3ZhbGlkYXRlL3ZhbGlkYXRlX2ZpbHRlcicpKTtcbnZhbGlkYXRlU3R5bGVNaW4ucGFpbnRQcm9wZXJ0eSA9IHdyYXBDbGVhbkVycm9ycyhyZXF1aXJlKCcuL3ZhbGlkYXRlL3ZhbGlkYXRlX3BhaW50X3Byb3BlcnR5JykpO1xudmFsaWRhdGVTdHlsZU1pbi5sYXlvdXRQcm9wZXJ0eSA9IHdyYXBDbGVhbkVycm9ycyhyZXF1aXJlKCcuL3ZhbGlkYXRlL3ZhbGlkYXRlX2xheW91dF9wcm9wZXJ0eScpKTtcblxuZnVuY3Rpb24gc29ydEVycm9ycyhlcnJvcnMpIHtcbiAgICByZXR1cm4gW10uY29uY2F0KGVycm9ycykuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICByZXR1cm4gYS5saW5lIC0gYi5saW5lO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiB3cmFwQ2xlYW5FcnJvcnMoaW5uZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzb3J0RXJyb3JzKGlubmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdmFsaWRhdGVTdHlsZU1pbjtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyByZXNvbHZlcyAuIGFuZCAuLiBlbGVtZW50cyBpbiBhIHBhdGggYXJyYXkgd2l0aCBkaXJlY3RvcnkgbmFtZXMgdGhlcmVcbi8vIG11c3QgYmUgbm8gc2xhc2hlcywgZW1wdHkgZWxlbWVudHMsIG9yIGRldmljZSBuYW1lcyAoYzpcXCkgaW4gdGhlIGFycmF5XG4vLyAoc28gYWxzbyBubyBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzIC0gaXQgZG9lcyBub3QgZGlzdGluZ3Vpc2hcbi8vIHJlbGF0aXZlIGFuZCBhYnNvbHV0ZSBwYXRocylcbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KHBhcnRzLCBhbGxvd0Fib3ZlUm9vdCkge1xuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbGFzdCA9IHBhcnRzW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgcGFydHMudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFydHM7XG59XG5cbi8vIFNwbGl0IGEgZmlsZW5hbWUgaW50byBbcm9vdCwgZGlyLCBiYXNlbmFtZSwgZXh0XSwgdW5peCB2ZXJzaW9uXG4vLyAncm9vdCcgaXMganVzdCBhIHNsYXNoLCBvciBub3RoaW5nLlxudmFyIHNwbGl0UGF0aFJlID1cbiAgICAvXihcXC8/fCkoW1xcc1xcU10qPykoKD86XFwuezEsMn18W15cXC9dKz98KShcXC5bXi5cXC9dKnwpKSg/OltcXC9dKikkLztcbnZhciBzcGxpdFBhdGggPSBmdW5jdGlvbihmaWxlbmFtZSkge1xuICByZXR1cm4gc3BsaXRQYXRoUmUuZXhlYyhmaWxlbmFtZSkuc2xpY2UoMSk7XG59O1xuXG4vLyBwYXRoLnJlc29sdmUoW2Zyb20gLi4uXSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlc29sdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc29sdmVkUGF0aCA9ICcnLFxuICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAtMSAmJiAhcmVzb2x2ZWRBYnNvbHV0ZTsgaS0tKSB7XG4gICAgdmFyIHBhdGggPSAoaSA+PSAwKSA/IGFyZ3VtZW50c1tpXSA6IHByb2Nlc3MuY3dkKCk7XG5cbiAgICAvLyBTa2lwIGVtcHR5IGFuZCBpbnZhbGlkIGVudHJpZXNcbiAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH0gZWxzZSBpZiAoIXBhdGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJlc29sdmVkUGF0aCA9IHBhdGggKyAnLycgKyByZXNvbHZlZFBhdGg7XG4gICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IHBhdGguY2hhckF0KDApID09PSAnLyc7XG4gIH1cblxuICAvLyBBdCB0aGlzIHBvaW50IHRoZSBwYXRoIHNob3VsZCBiZSByZXNvbHZlZCB0byBhIGZ1bGwgYWJzb2x1dGUgcGF0aCwgYnV0XG4gIC8vIGhhbmRsZSByZWxhdGl2ZSBwYXRocyB0byBiZSBzYWZlIChtaWdodCBoYXBwZW4gd2hlbiBwcm9jZXNzLmN3ZCgpIGZhaWxzKVxuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICByZXNvbHZlZFBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocmVzb2x2ZWRQYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIXJlc29sdmVkQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICByZXR1cm4gKChyZXNvbHZlZEFic29sdXRlID8gJy8nIDogJycpICsgcmVzb2x2ZWRQYXRoKSB8fCAnLic7XG59O1xuXG4vLyBwYXRoLm5vcm1hbGl6ZShwYXRoKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5ub3JtYWxpemUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciBpc0Fic29sdXRlID0gZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpLFxuICAgICAgdHJhaWxpbmdTbGFzaCA9IHN1YnN0cihwYXRoLCAtMSkgPT09ICcvJztcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihwYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIWlzQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICBpZiAoIXBhdGggJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBwYXRoID0gJy4nO1xuICB9XG4gIGlmIChwYXRoICYmIHRyYWlsaW5nU2xhc2gpIHtcbiAgICBwYXRoICs9ICcvJztcbiAgfVxuXG4gIHJldHVybiAoaXNBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHBhdGg7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmlzQWJzb2x1dGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5qb2luID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXRocyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gIHJldHVybiBleHBvcnRzLm5vcm1hbGl6ZShmaWx0ZXIocGF0aHMsIGZ1bmN0aW9uKHAsIGluZGV4KSB7XG4gICAgaWYgKHR5cGVvZiBwICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGguam9pbiBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH0pLmpvaW4oJy8nKSk7XG59O1xuXG5cbi8vIHBhdGgucmVsYXRpdmUoZnJvbSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlbGF0aXZlID0gZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgZnJvbSA9IGV4cG9ydHMucmVzb2x2ZShmcm9tKS5zdWJzdHIoMSk7XG4gIHRvID0gZXhwb3J0cy5yZXNvbHZlKHRvKS5zdWJzdHIoMSk7XG5cbiAgZnVuY3Rpb24gdHJpbShhcnIpIHtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIGZvciAoOyBzdGFydCA8IGFyci5sZW5ndGg7IHN0YXJ0KyspIHtcbiAgICAgIGlmIChhcnJbc3RhcnRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGVuZCA9IGFyci5sZW5ndGggLSAxO1xuICAgIGZvciAoOyBlbmQgPj0gMDsgZW5kLS0pIHtcbiAgICAgIGlmIChhcnJbZW5kXSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA+IGVuZCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiBhcnIuc2xpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0ICsgMSk7XG4gIH1cblxuICB2YXIgZnJvbVBhcnRzID0gdHJpbShmcm9tLnNwbGl0KCcvJykpO1xuICB2YXIgdG9QYXJ0cyA9IHRyaW0odG8uc3BsaXQoJy8nKSk7XG5cbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGZyb21QYXJ0cy5sZW5ndGgsIHRvUGFydHMubGVuZ3RoKTtcbiAgdmFyIHNhbWVQYXJ0c0xlbmd0aCA9IGxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChmcm9tUGFydHNbaV0gIT09IHRvUGFydHNbaV0pIHtcbiAgICAgIHNhbWVQYXJ0c0xlbmd0aCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgb3V0cHV0UGFydHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IHNhbWVQYXJ0c0xlbmd0aDsgaSA8IGZyb21QYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFBhcnRzLnB1c2goJy4uJyk7XG4gIH1cblxuICBvdXRwdXRQYXJ0cyA9IG91dHB1dFBhcnRzLmNvbmNhdCh0b1BhcnRzLnNsaWNlKHNhbWVQYXJ0c0xlbmd0aCkpO1xuXG4gIHJldHVybiBvdXRwdXRQYXJ0cy5qb2luKCcvJyk7XG59O1xuXG5leHBvcnRzLnNlcCA9ICcvJztcbmV4cG9ydHMuZGVsaW1pdGVyID0gJzonO1xuXG5leHBvcnRzLmRpcm5hbWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciByZXN1bHQgPSBzcGxpdFBhdGgocGF0aCksXG4gICAgICByb290ID0gcmVzdWx0WzBdLFxuICAgICAgZGlyID0gcmVzdWx0WzFdO1xuXG4gIGlmICghcm9vdCAmJiAhZGlyKSB7XG4gICAgLy8gTm8gZGlybmFtZSB3aGF0c29ldmVyXG4gICAgcmV0dXJuICcuJztcbiAgfVxuXG4gIGlmIChkaXIpIHtcbiAgICAvLyBJdCBoYXMgYSBkaXJuYW1lLCBzdHJpcCB0cmFpbGluZyBzbGFzaFxuICAgIGRpciA9IGRpci5zdWJzdHIoMCwgZGlyLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgcmV0dXJuIHJvb3QgKyBkaXI7XG59O1xuXG5cbmV4cG9ydHMuYmFzZW5hbWUgPSBmdW5jdGlvbihwYXRoLCBleHQpIHtcbiAgdmFyIGYgPSBzcGxpdFBhdGgocGF0aClbMl07XG4gIC8vIFRPRE86IG1ha2UgdGhpcyBjb21wYXJpc29uIGNhc2UtaW5zZW5zaXRpdmUgb24gd2luZG93cz9cbiAgaWYgKGV4dCAmJiBmLnN1YnN0cigtMSAqIGV4dC5sZW5ndGgpID09PSBleHQpIHtcbiAgICBmID0gZi5zdWJzdHIoMCwgZi5sZW5ndGggLSBleHQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZjtcbn07XG5cblxuZXhwb3J0cy5leHRuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gc3BsaXRQYXRoKHBhdGgpWzNdO1xufTtcblxuZnVuY3Rpb24gZmlsdGVyICh4cywgZikge1xuICAgIGlmICh4cy5maWx0ZXIpIHJldHVybiB4cy5maWx0ZXIoZik7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGYoeHNbaV0sIGksIHhzKSkgcmVzLnB1c2goeHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyBTdHJpbmcucHJvdG90eXBlLnN1YnN0ciAtIG5lZ2F0aXZlIGluZGV4IGRvbid0IHdvcmsgaW4gSUU4XG52YXIgc3Vic3RyID0gJ2FiJy5zdWJzdHIoLTEpID09PSAnYidcbiAgICA/IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHsgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbikgfVxuICAgIDogZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikge1xuICAgICAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IHN0ci5sZW5ndGggKyBzdGFydDtcbiAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbik7XG4gICAgfVxuO1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuNC4xIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiZcblx0XHQhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0IW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChcblx0XHRmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsXG5cdCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cblx0ICogQG5hbWUgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHR2YXIgcHVueWNvZGUsXG5cblx0LyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuXHRtYXhJbnQgPSAyMTQ3NDgzNjQ3LCAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cblx0LyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuXHRiYXNlID0gMzYsXG5cdHRNaW4gPSAxLFxuXHR0TWF4ID0gMjYsXG5cdHNrZXcgPSAzOCxcblx0ZGFtcCA9IDcwMCxcblx0aW5pdGlhbEJpYXMgPSA3Mixcblx0aW5pdGlhbE4gPSAxMjgsIC8vIDB4ODBcblx0ZGVsaW1pdGVyID0gJy0nLCAvLyAnXFx4MkQnXG5cblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cblx0cmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sXG5cdHJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuXHRyZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cblx0LyoqIEVycm9yIG1lc3NhZ2VzICovXG5cdGVycm9ycyA9IHtcblx0XHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHRcdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdFx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcblx0fSxcblxuXHQvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5cdGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbixcblx0Zmxvb3IgPSBNYXRoLmZsb29yLFxuXHRzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuXG5cdC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cblx0a2V5O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcblx0ICogaXRlbS5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdFx0cmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcblx0ICogYWRkcmVzc2VzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcblx0ICogY2hhcmFjdGVyLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuXHQgKiBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdFx0dmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0XHR9XG5cdFx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdFx0dmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHRcdHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0XHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG5cdCAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcblx0ICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG5cdCAqIG1hdGNoaW5nIFVURi0xNi5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG5cdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBkZWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGNvdW50ZXIgPSAwLFxuXHRcdCAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuXHRcdCAgICB2YWx1ZSxcblx0XHQgICAgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGVuY29kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0cmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH0pLmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cblx0ICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcblx0ICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCAtIDQ4IDwgMTApIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSAyMjtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDY1IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA2NTtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA5Nztcblx0XHR9XG5cdFx0cmV0dXJuIGJhc2U7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3Jcblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2Vcblx0ICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG5cdCAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG5cdCAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG5cdCAqL1xuXHRmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcblx0XHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHRcdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRcdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG5cdH1cblxuXHQvKipcblx0ICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cblx0ICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHRcdHZhciBrID0gMDtcblx0XHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRcdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0XHQvLyBEb24ndCB1c2UgVUNTLTJcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICBvdXQsXG5cdFx0ICAgIGkgPSAwLFxuXHRcdCAgICBuID0gaW5pdGlhbE4sXG5cdFx0ICAgIGJpYXMgPSBpbml0aWFsQmlhcyxcblx0XHQgICAgYmFzaWMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIGluZGV4LFxuXHRcdCAgICBvbGRpLFxuXHRcdCAgICB3LFxuXHRcdCAgICBrLFxuXHRcdCAgICBkaWdpdCxcblx0XHQgICAgdCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGJhc2VNaW51c1Q7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHRcdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRcdGlmIChiYXNpYyA8IDApIHtcblx0XHRcdGJhc2ljID0gMDtcblx0XHR9XG5cblx0XHRmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHRcdH1cblx0XHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0XHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdFx0Zm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdFx0Zm9yIChvbGRpID0gaSwgdyA9IDEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdFx0aSAlPSBvdXQ7XG5cblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcblx0XHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcblx0ICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdFx0dmFyIG4sXG5cdFx0ICAgIGRlbHRhLFxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcblx0XHQgICAgYmFzaWNMZW5ndGgsXG5cdFx0ICAgIGJpYXMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIG0sXG5cdFx0ICAgIHEsXG5cdFx0ICAgIGssXG5cdFx0ICAgIHQsXG5cdFx0ICAgIGN1cnJlbnRWYWx1ZSxcblx0XHQgICAgb3V0cHV0ID0gW10sXG5cdFx0ICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG5cdFx0ICAgIGlucHV0TGVuZ3RoLFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuXHRcdCAgICBiYXNlTWludXNULFxuXHRcdCAgICBxTWludXNUO1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuXHRcdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0XHQvLyBDYWNoZSB0aGUgbGVuZ3RoXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuXHRcdG4gPSBpbml0aWFsTjtcblx0XHRkZWx0YSA9IDA7XG5cdFx0YmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuXHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblxuXHRcdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHRcdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdFx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdFx0biA9IG07XG5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG5cdFx0XHRcdFx0Zm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0KytkZWx0YTtcblx0XHRcdCsrbjtcblxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3Ncblx0ICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuXHQgKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cblx0ICogY29udmVydGVkIHRvIFVuaWNvZGUuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG5cdCAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuXHQgKiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG5cdCAqIFVuaWNvZGUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG5cdCAqIGVtYWlsIGFkZHJlc3MuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cblx0cHVueWNvZGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdCd2ZXJzaW9uJzogJzEuNC4xJyxcblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHRcdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdFx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0J3VjczInOiB7XG5cdFx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdFx0fSxcblx0XHQnZGVjb2RlJzogZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHRcdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcblx0fTtcblxuXHQvKiogRXhwb3NlIGBwdW55Y29kZWAgKi9cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoJ3B1bnljb2RlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gcHVueWNvZGU7XG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuXHRcdGlmIChtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cykge1xuXHRcdFx0Ly8gaW4gTm9kZS5qcywgaW8uanMsIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gcHVueWNvZGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnB1bnljb2RlID0gcHVueWNvZGU7XG5cdH1cblxufSh0aGlzKSk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeVByaW1pdGl2ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdjtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgb2JqID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG1hcChvYmplY3RLZXlzKG9iaiksIGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG4gICAgICBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIHJldHVybiBtYXAob2JqW2tdLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xuICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5mdW5jdGlvbiBtYXAgKHhzLCBmKSB7XG4gIGlmICh4cy5tYXApIHJldHVybiB4cy5tYXAoZik7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgIHJlcy5wdXNoKGYoeHNbaV0sIGkpKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHJlcy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcbiIsIi8qIVxuICogc29ydC1hc2MgPGh0dHBzOi8vZ2l0aHViLmNvbS9oZWxwZXJzL3NvcnQtYXNjPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNCBKb24gU2NobGlua2VydCwgY29udHJpYnV0b3JzLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIHJldHVybiBiIDwgYSA/IC0xIDogMTtcbn07IiwiLyohXG4gKiBzb3J0LWRlc2MgPGh0dHBzOi8vZ2l0aHViLmNvbS9oZWxwZXJzL3NvcnQtZGVzYz5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgSm9uIFNjaGxpbmtlcnQsIGNvbnRyaWJ1dG9ycy5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYSwgYikge1xuICByZXR1cm4gYSA8IGIgPyAtMSA6IDE7XG59OyIsIi8qIVxuICogc29ydC1rZXlzIDxodHRwczovL2dpdGh1Yi5jb20vaGVscGVycy9zb3J0LWtleXM+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0IEJyaWFuIFdvb2R3YXJkLCBKb24gU2NobGlua2VydCwgY29udHJpYnV0b3JzLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc29ydERlc2MgPSByZXF1aXJlKCdzb3J0LWRlc2MnKTtcbnZhciBzb3J0QXNjID0gcmVxdWlyZSgnc29ydC1hc2MnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmosIG9wdGlvbnMpIHtcbiAgdmFyIHNvcnQgPSB7ZGVzYzogc29ydERlc2MsIGFzYzogc29ydEFzY307XG4gIHZhciBmbiwgb3B0cyA9IHt9LCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcblxuICAvLyBpZiBgb3B0aW9uc2AgaXMgYW4gYXJyYXksIGFzc3VtZSBpdCdzIGtleXNcbiAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICBvcHRzLmtleXMgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcblxuICAvLyBpZiBgb3B0aW9uc2AgaXMgYSBmdW5jdGlvbiwgYXNzdW1lIGl0J3MgYSBzb3J0aW5nIGZ1bmN0aW9uXG4gIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBmbiA9IG9wdGlvbnM7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgb3B0IGluIG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KG9wdCkpIHtcbiAgICAgICAgb3B0c1tvcHRdID0gb3B0aW9uc1tvcHRdXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gRGVmYXVsdCBzb3J0IG9yZGVyIGlzIGRlc2NlbmRpbmdcbiAgZm4gPSBvcHRzLnNvcnQgfHwgc29ydERlc2M7XG5cbiAgaWYgKEJvb2xlYW4ob3B0cy5zb3J0T3JkZXIpKSB7XG4gICAgZm4gPSBzb3J0W29wdHMuc29ydE9yZGVyLnRvTG93ZXJDYXNlKCldO1xuICB9XG5cbiAgaWYgKEJvb2xlYW4ob3B0cy5zb3J0QnkpKSB7XG4gICAga2V5cyA9IG9wdHMuc29ydEJ5KG9iaik7XG4gICAgZm4gPSBudWxsO1xuICB9XG5cbiAgaWYgKEJvb2xlYW4ob3B0cy5rZXlzKSkge1xuICAgIGtleXMgPSBvcHRzLmtleXM7XG4gICAgaWYgKCFvcHRzLnNvcnQgJiYgIW9wdHMuc29ydE9yZGVyICYmICFvcHRzLnNvcnRCeSkge1xuICAgICAgZm4gPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGlmIChmbikge1xuICAgIGtleXMgPSBrZXlzLnNvcnQoZm4pO1xuICB9XG5cbiAgdmFyIG8gPSB7fTtcbiAgdmFyIGxlbiA9IGtleXMubGVuZ3RoO1xuICB2YXIgaSA9IC0xO1xuXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBvW2tleXNbaV1dID0gb2JqW2tleXNbaV1dO1xuICB9XG5cbiAgcmV0dXJuIG87XG59OyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5leHBvcnRzLnBhcnNlID0gdXJsUGFyc2U7XG5leHBvcnRzLnJlc29sdmUgPSB1cmxSZXNvbHZlO1xuZXhwb3J0cy5yZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdDtcbmV4cG9ydHMuZm9ybWF0ID0gdXJsRm9ybWF0O1xuXG5leHBvcnRzLlVybCA9IFVybDtcblxuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5xdWVyeSA9IG51bGw7XG4gIHRoaXMucGF0aG5hbWUgPSBudWxsO1xuICB0aGlzLnBhdGggPSBudWxsO1xuICB0aGlzLmhyZWYgPSBudWxsO1xufVxuXG4vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcblxuLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbi8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxudmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksXG4gICAgcG9ydFBhdHRlcm4gPSAvOlswLTldKiQvLFxuXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBhIHNpbXBsZSBwYXRoIFVSTFxuICAgIHNpbXBsZVBhdGhQYXR0ZXJuID0gL14oXFwvXFwvPyg/IVxcLylbXlxcP1xcc10qKShcXD9bXlxcc10qKT8kLyxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4gICAgLy8gV2UgYWN0dWFsbHkganVzdCBhdXRvLWVzY2FwZSB0aGVzZS5cbiAgICBkZWxpbXMgPSBbJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnXSxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gICAgdW53aXNlID0gWyd7JywgJ30nLCAnfCcsICdcXFxcJywgJ14nLCAnYCddLmNvbmNhdChkZWxpbXMpLFxuXG4gICAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuICAgIGF1dG9Fc2NhcGUgPSBbJ1xcJyddLmNvbmNhdCh1bndpc2UpLFxuICAgIC8vIENoYXJhY3RlcnMgdGhhdCBhcmUgbmV2ZXIgZXZlciBhbGxvd2VkIGluIGEgaG9zdG5hbWUuXG4gICAgLy8gTm90ZSB0aGF0IGFueSBpbnZhbGlkIGNoYXJzIGFyZSBhbHNvIGhhbmRsZWQsIGJ1dCB0aGVzZVxuICAgIC8vIGFyZSB0aGUgb25lcyB0aGF0IGFyZSAqZXhwZWN0ZWQqIHRvIGJlIHNlZW4sIHNvIHdlIGZhc3QtcGF0aFxuICAgIC8vIHRoZW0uXG4gICAgbm9uSG9zdENoYXJzID0gWyclJywgJy8nLCAnPycsICc7JywgJyMnXS5jb25jYXQoYXV0b0VzY2FwZSksXG4gICAgaG9zdEVuZGluZ0NoYXJzID0gWycvJywgJz8nLCAnIyddLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlsrYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbK2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgdW5zYWZlUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuXG4gICAgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH0sXG4gICAgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgdXRpbC5pc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHVybDtcblxuICB2YXIgdSA9IG5ldyBVcmw7XG4gIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAoIXV0aWwuaXNTdHJpbmcodXJsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHVybCk7XG4gIH1cblxuICAvLyBDb3B5IGNocm9tZSwgSUUsIG9wZXJhIGJhY2tzbGFzaC1oYW5kbGluZyBiZWhhdmlvci5cbiAgLy8gQmFjayBzbGFzaGVzIGJlZm9yZSB0aGUgcXVlcnkgc3RyaW5nIGdldCBjb252ZXJ0ZWQgdG8gZm9yd2FyZCBzbGFzaGVzXG4gIC8vIFNlZTogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTI1OTE2XG4gIHZhciBxdWVyeUluZGV4ID0gdXJsLmluZGV4T2YoJz8nKSxcbiAgICAgIHNwbGl0dGVyID1cbiAgICAgICAgICAocXVlcnlJbmRleCAhPT0gLTEgJiYgcXVlcnlJbmRleCA8IHVybC5pbmRleE9mKCcjJykpID8gJz8nIDogJyMnLFxuICAgICAgdVNwbGl0ID0gdXJsLnNwbGl0KHNwbGl0dGVyKSxcbiAgICAgIHNsYXNoUmVnZXggPSAvXFxcXC9nO1xuICB1U3BsaXRbMF0gPSB1U3BsaXRbMF0ucmVwbGFjZShzbGFzaFJlZ2V4LCAnLycpO1xuICB1cmwgPSB1U3BsaXQuam9pbihzcGxpdHRlcik7XG5cbiAgdmFyIHJlc3QgPSB1cmw7XG5cbiAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICByZXN0ID0gcmVzdC50cmltKCk7XG5cbiAgaWYgKCFzbGFzaGVzRGVub3RlSG9zdCAmJiB1cmwuc3BsaXQoJyMnKS5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBUcnkgZmFzdCBwYXRoIHJlZ2V4cFxuICAgIHZhciBzaW1wbGVQYXRoID0gc2ltcGxlUGF0aFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgICBpZiAoc2ltcGxlUGF0aCkge1xuICAgICAgdGhpcy5wYXRoID0gcmVzdDtcbiAgICAgIHRoaXMuaHJlZiA9IHJlc3Q7XG4gICAgICB0aGlzLnBhdGhuYW1lID0gc2ltcGxlUGF0aFsxXTtcbiAgICAgIGlmIChzaW1wbGVQYXRoWzJdKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTtcbiAgICAgICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5zZWFyY2guc3Vic3RyKDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5zZWFyY2guc3Vic3RyKDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICAgICAgdGhpcy5xdWVyeSA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSlcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcblxuICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KCk7XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnljb2RlZCByZXByZXNlbnRhdGlvbiBvZiBcImRvbWFpblwiLlxuICAgICAgLy8gSXQgb25seSBjb252ZXJ0cyBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgdGhhdFxuICAgICAgLy8gaGF2ZSBub24tQVNDSUkgY2hhcmFjdGVycywgaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZlxuICAgICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgQVNDSUktb25seS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSBwdW55Y29kZS50b0FTQ0lJKHRoaXMuaG9zdG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgIHRoaXMuaG9zdCA9IGggKyBwO1xuICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIGlmIChyZXN0LmluZGV4T2YoYWUpID09PSAtMSlcbiAgICAgICAgY29udGludWU7XG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcbiAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICB9XG4gICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgdGhpcy5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSk7XG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgdGhpcy5xdWVyeSA9IHt9O1xuICB9XG4gIGlmIChyZXN0KSB0aGlzLnBhdGhuYW1lID0gcmVzdDtcbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxuICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgIHRoaXMucGF0aG5hbWUgPSAnLyc7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gIGlmICh0aGlzLnBhdGhuYW1lIHx8IHRoaXMuc2VhcmNoKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8ICcnO1xuICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgJyc7XG4gICAgdGhpcy5wYXRoID0gcCArIHM7XG4gIH1cblxuICAvLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC5cbiAgdGhpcy5ocmVmID0gdGhpcy5mb3JtYXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXG5mdW5jdGlvbiB1cmxGb3JtYXQob2JqKSB7XG4gIC8vIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuXG4gIC8vIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXG4gIC8vIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3NcbiAgLy8gdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy5cbiAgaWYgKHV0aWwuaXNTdHJpbmcob2JqKSkgb2JqID0gdXJsUGFyc2Uob2JqKTtcbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcbiAgcmV0dXJuIG9iai5mb3JtYXQoKTtcbn1cblxuVXJsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsXG4gICAgICBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgJycsXG4gICAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxuICAgICAgaG9zdCA9IGZhbHNlLFxuICAgICAgcXVlcnkgPSAnJztcblxuICBpZiAodGhpcy5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XG4gIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgOlxuICAgICAgICAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5xdWVyeSAmJlxuICAgICAgdXRpbC5pc09iamVjdCh0aGlzLnF1ZXJ5KSAmJlxuICAgICAgT2JqZWN0LmtleXModGhpcy5xdWVyeSkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkodGhpcy5xdWVyeSk7XG4gIH1cblxuICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2ggfHwgKHF1ZXJ5ICYmICgnPycgKyBxdWVyeSkpIHx8ICcnO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICAvLyBvbmx5IHRoZSBzbGFzaGVkUHJvdG9jb2xzIGdldCB0aGUgLy8uICBOb3QgbWFpbHRvOiwgeG1wcDosIGV0Yy5cbiAgLy8gdW5sZXNzIHRoZXkgaGFkIHRoZW0gdG8gYmVnaW4gd2l0aC5cbiAgaWYgKHRoaXMuc2xhc2hlcyB8fFxuICAgICAgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJztcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoO1xuXG4gIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO1xuICB9KTtcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJyk7XG5cbiAgcmV0dXJuIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZShyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIHJldHVybiB0aGlzLnJlc29sdmVPYmplY3QodXJsUGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKSkuZm9ybWF0KCk7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgaWYgKCFzb3VyY2UpIHJldHVybiByZWxhdGl2ZTtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmVPYmplY3QocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmVPYmplY3QgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICBpZiAodXRpbC5pc1N0cmluZyhyZWxhdGl2ZSkpIHtcbiAgICB2YXIgcmVsID0gbmV3IFVybCgpO1xuICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuICAgIHJlbGF0aXZlID0gcmVsO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBVcmwoKTtcbiAgdmFyIHRrZXlzID0gT2JqZWN0LmtleXModGhpcyk7XG4gIGZvciAodmFyIHRrID0gMDsgdGsgPCB0a2V5cy5sZW5ndGg7IHRrKyspIHtcbiAgICB2YXIgdGtleSA9IHRrZXlzW3RrXTtcbiAgICByZXN1bHRbdGtleV0gPSB0aGlzW3RrZXldO1xuICB9XG5cbiAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gIC8vIGV2ZW4gaHJlZj1cIlwiIHdpbGwgcmVtb3ZlIGl0LlxuICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XG5cbiAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaHJlZnMgbGlrZSAvL2Zvby9iYXIgYWx3YXlzIGN1dCB0byB0aGUgcHJvdG9jb2wuXG4gIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcbiAgICB2YXIgcmtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgZm9yICh2YXIgcmsgPSAwOyByayA8IHJrZXlzLmxlbmd0aDsgcmsrKykge1xuICAgICAgdmFyIHJrZXkgPSBya2V5c1tya107XG4gICAgICBpZiAocmtleSAhPT0gJ3Byb3RvY29sJylcbiAgICAgICAgcmVzdWx0W3JrZXldID0gcmVsYXRpdmVbcmtleV07XG4gICAgfVxuXG4gICAgLy91cmxQYXJzZSBhcHBlbmRzIHRyYWlsaW5nIC8gdG8gdXJscyBsaWtlIGh0dHA6Ly93d3cuZXhhbXBsZS5jb21cbiAgICBpZiAoc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF0gJiZcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lICYmICFyZXN1bHQucGF0aG5hbWUpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gcmVzdWx0LnBhdGhuYW1lID0gJy8nO1xuICAgIH1cblxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHJlc3VsdC5wcm90b2NvbCkge1xuICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAvLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgICAgIHZhciBrID0ga2V5c1t2XTtcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgICB9XG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSk7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSAnJztcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7XG4gICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHZhciBwID0gcmVzdWx0LnBhdGhuYW1lIHx8ICcnO1xuICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnO1xuICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcbiAgICB9XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgaXNTb3VyY2VBYnMgPSAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksXG4gICAgICBpc1JlbEFicyA9IChcbiAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLydcbiAgICAgICksXG4gICAgICBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLFxuICAgICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XG4gICAgcmVzdWx0LnBvcnQgPSBudWxsO1xuICAgIGlmIChyZXN1bHQuaG9zdCkge1xuICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7XG4gICAgICBlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XG4gICAgfVxuICAgIHJlc3VsdC5ob3N0ID0gJyc7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XG4gICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGw7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHJlc3VsdC5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAocmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgOiByZXN1bHQuaG9zdG5hbWU7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIGRvdC1oYW5kbGluZyBiZWxvdy5cbiAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgIC8vIGl0J3MgcmVsYXRpdmVcbiAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICBpZiAoIXNyY1BhdGgpIHNyY1BhdGggPSBbXTtcbiAgICBzcmNQYXRoLnBvcCgpO1xuICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKCF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKHJlbGF0aXZlLnNlYXJjaCkpIHtcbiAgICAvLyBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXG4gICAgLy8gbGlrZSBocmVmPSc/Zm9vJy5cbiAgICAvLyBQdXQgdGhpcyBhZnRlciB0aGUgb3RoZXIgdHdvIGNhc2VzIGJlY2F1c2UgaXQgc2ltcGxpZmllcyB0aGUgYm9vbGVhbnNcbiAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTtcbiAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLlxuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQuc2VhcmNoKSB7XG4gICAgICByZXN1bHQucGF0aCA9ICcvJyArIHJlc3VsdC5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAoXG4gICAgICAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCB8fCBzcmNQYXRoLmxlbmd0aCA+IDEpICYmXG4gICAgICAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8IGxhc3QgPT09ICcnKTtcblxuICAvLyBzdHJpcCBzaW5nbGUgZG90cywgcmVzb2x2ZSBkb3VibGUgZG90cyB0byBwYXJlbnQgZGlyXG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBzcmNQYXRoLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICBsYXN0ID0gc3JjUGF0aFtpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgKHJlc3VsdC5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoKTtcblxuICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5qb2luKCcvJyk7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICB9XG4gIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCByZXN1bHQuYXV0aDtcbiAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBob3N0ID0gdGhpcy5ob3N0O1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gIGlmIChwb3J0KSB7XG4gICAgcG9ydCA9IHBvcnRbMF07XG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgdGhpcy5ob3N0bmFtZSA9IGhvc3Q7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNTdHJpbmc6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ3N0cmluZyc7XG4gIH0sXG4gIGlzT2JqZWN0OiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09PSBudWxsO1xuICB9LFxuICBpc051bGxPclVuZGVmaW5lZDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PSBudWxsO1xuICB9XG59O1xuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuIl19
